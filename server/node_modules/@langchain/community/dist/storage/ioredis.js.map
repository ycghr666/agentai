{"version":3,"file":"ioredis.js","names":[],"sources":["../../src/storage/ioredis.ts"],"sourcesContent":["import type { Redis } from \"ioredis\";\n\nimport { BaseStore } from \"@langchain/core/stores\";\n\n/**\n * Class that extends the BaseStore class to interact with a Redis\n * database. It provides methods for getting, setting, and deleting data,\n * as well as yielding keys from the database.\n * @example\n * ```typescript\n * const store = new RedisByteStore({ client: new Redis({}) });\n * await store.mset([\n *   [\n *     \"message:id:0\",\n *     new TextEncoder().encode(JSON.stringify(new AIMessage(\"ai stuff...\"))),\n *   ],\n *   [\n *     \"message:id:1\",\n *     new TextEncoder().encode(\n *       JSON.stringify(new HumanMessage(\"human stuff...\")),\n *     ),\n *   ],\n * ]);\n * const retrievedMessages = await store.mget([\"message:id:0\", \"message:id:1\"]);\n * console.log(retrievedMessages.map((v) => new TextDecoder().decode(v)));\n * const yieldedKeys = [];\n * for await (const key of store.yieldKeys(\"message:id:\")) {\n *   yieldedKeys.push(key);\n * }\n * console.log(yieldedKeys);\n * await store.mdelete(yieldedKeys);\n * ```\n */\nexport class RedisByteStore extends BaseStore<string, Uint8Array> {\n  lc_namespace = [\"langchain\", \"storage\"];\n\n  protected client: Redis;\n\n  protected ttl?: number;\n\n  protected namespace?: string;\n\n  protected yieldKeysScanBatchSize = 1000;\n\n  constructor(fields: {\n    client: Redis;\n    ttl?: number;\n    namespace?: string;\n    yieldKeysScanBatchSize?: number;\n  }) {\n    super(fields);\n    this.client = fields.client;\n    this.ttl = fields.ttl;\n    this.namespace = fields.namespace;\n    this.yieldKeysScanBatchSize =\n      fields.yieldKeysScanBatchSize ?? this.yieldKeysScanBatchSize;\n  }\n\n  _getPrefixedKey(key: string) {\n    if (this.namespace) {\n      const delimiter = \"/\";\n      return `${this.namespace}${delimiter}${key}`;\n    }\n    return key;\n  }\n\n  _getDeprefixedKey(key: string) {\n    if (this.namespace) {\n      const delimiter = \"/\";\n      return key.slice(this.namespace.length + delimiter.length);\n    }\n    return key;\n  }\n\n  /**\n   * Gets multiple keys from the Redis database.\n   * @param keys Array of keys to be retrieved.\n   * @returns An array of retrieved values.\n   */\n  async mget(keys: string[]) {\n    const prefixedKeys = keys.map(this._getPrefixedKey.bind(this));\n    const retrievedValues = await this.client.mgetBuffer(prefixedKeys);\n    return retrievedValues.map((value) => {\n      if (!value) {\n        return undefined;\n      } else {\n        return value;\n      }\n    });\n  }\n\n  /**\n   * Sets multiple keys in the Redis database.\n   * @param keyValuePairs Array of key-value pairs to be set.\n   * @returns Promise that resolves when all keys have been set.\n   */\n  async mset(keyValuePairs: [string, Uint8Array][]): Promise<void> {\n    const decoder = new TextDecoder();\n    const encodedKeyValuePairs = keyValuePairs.map(([key, value]) => [\n      this._getPrefixedKey(key),\n      decoder.decode(value),\n    ]);\n    const pipeline = this.client.pipeline();\n    for (const [key, value] of encodedKeyValuePairs) {\n      if (this.ttl) {\n        pipeline.set(key, value, \"EX\", this.ttl);\n      } else {\n        pipeline.set(key, value);\n      }\n    }\n    await pipeline.exec();\n  }\n\n  /**\n   * Deletes multiple keys from the Redis database.\n   * @param keys Array of keys to be deleted.\n   * @returns Promise that resolves when all keys have been deleted.\n   */\n  async mdelete(keys: string[]): Promise<void> {\n    await this.client.del(...keys.map(this._getPrefixedKey.bind(this)));\n  }\n\n  /**\n   * Yields keys from the Redis database.\n   * @param prefix Optional prefix to filter the keys.\n   * @returns An AsyncGenerator that yields keys from the Redis database.\n   */\n  async *yieldKeys(prefix?: string): AsyncGenerator<string> {\n    let pattern;\n    if (prefix) {\n      const wildcardPrefix = prefix.endsWith(\"*\") ? prefix : `${prefix}*`;\n      pattern = this._getPrefixedKey(wildcardPrefix);\n    } else {\n      pattern = this._getPrefixedKey(\"*\");\n    }\n    let [cursor, batch] = await this.client.scan(\n      0,\n      \"MATCH\",\n      pattern,\n      \"COUNT\",\n      this.yieldKeysScanBatchSize\n    );\n    for (const key of batch) {\n      yield this._getDeprefixedKey(key);\n    }\n    while (cursor !== \"0\") {\n      [cursor, batch] = await this.client.scan(\n        cursor,\n        \"MATCH\",\n        pattern,\n        \"COUNT\",\n        this.yieldKeysScanBatchSize\n      );\n      for (const key of batch) {\n        yield this._getDeprefixedKey(key);\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,IAAa,iBAAb,cAAoC,UAA8B;CAChE,eAAe,CAAC,aAAa,UAAU;CAEvC,AAAU;CAEV,AAAU;CAEV,AAAU;CAEV,AAAU,yBAAyB;CAEnC,YAAY,QAKT;AACD,QAAM,OAAO;AACb,OAAK,SAAS,OAAO;AACrB,OAAK,MAAM,OAAO;AAClB,OAAK,YAAY,OAAO;AACxB,OAAK,yBACH,OAAO,0BAA0B,KAAK;;CAG1C,gBAAgB,KAAa;AAC3B,MAAI,KAAK,UAEP,QAAO,GAAG,KAAK,aAAwB;AAEzC,SAAO;;CAGT,kBAAkB,KAAa;AAC7B,MAAI,KAAK,UAEP,QAAO,IAAI,MAAM,KAAK,UAAU,SAAS,EAAiB;AAE5D,SAAO;;;;;;;CAQT,MAAM,KAAK,MAAgB;EACzB,MAAM,eAAe,KAAK,IAAI,KAAK,gBAAgB,KAAK,KAAK,CAAC;AAE9D,UADwB,MAAM,KAAK,OAAO,WAAW,aAAa,EAC3C,KAAK,UAAU;AACpC,OAAI,CAAC,MACH;OAEA,QAAO;IAET;;;;;;;CAQJ,MAAM,KAAK,eAAsD;EAC/D,MAAM,UAAU,IAAI,aAAa;EACjC,MAAM,uBAAuB,cAAc,KAAK,CAAC,KAAK,WAAW,CAC/D,KAAK,gBAAgB,IAAI,EACzB,QAAQ,OAAO,MAAM,CACtB,CAAC;EACF,MAAM,WAAW,KAAK,OAAO,UAAU;AACvC,OAAK,MAAM,CAAC,KAAK,UAAU,qBACzB,KAAI,KAAK,IACP,UAAS,IAAI,KAAK,OAAO,MAAM,KAAK,IAAI;MAExC,UAAS,IAAI,KAAK,MAAM;AAG5B,QAAM,SAAS,MAAM;;;;;;;CAQvB,MAAM,QAAQ,MAA+B;AAC3C,QAAM,KAAK,OAAO,IAAI,GAAG,KAAK,IAAI,KAAK,gBAAgB,KAAK,KAAK,CAAC,CAAC;;;;;;;CAQrE,OAAO,UAAU,QAAyC;EACxD,IAAI;AACJ,MAAI,QAAQ;GACV,MAAM,iBAAiB,OAAO,SAAS,IAAI,GAAG,SAAS,GAAG,OAAO;AACjE,aAAU,KAAK,gBAAgB,eAAe;QAE9C,WAAU,KAAK,gBAAgB,IAAI;EAErC,IAAI,CAAC,QAAQ,SAAS,MAAM,KAAK,OAAO,KACtC,GACA,SACA,SACA,SACA,KAAK,uBACN;AACD,OAAK,MAAM,OAAO,MAChB,OAAM,KAAK,kBAAkB,IAAI;AAEnC,SAAO,WAAW,KAAK;AACrB,IAAC,QAAQ,SAAS,MAAM,KAAK,OAAO,KAClC,QACA,SACA,SACA,SACA,KAAK,uBACN;AACD,QAAK,MAAM,OAAO,MAChB,OAAM,KAAK,kBAAkB,IAAI"}