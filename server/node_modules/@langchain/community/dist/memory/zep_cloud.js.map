{"version":3,"file":"zep_cloud.js","names":["BaseChatMemory"],"sources":["../../src/memory/zep_cloud.ts"],"sourcesContent":["import { Zep, ZepClient } from \"@getzep/zep-cloud\";\nimport { Memory, NotFoundError } from \"@getzep/zep-cloud/api\";\nimport {\n  InputValues,\n  OutputValues,\n  MemoryVariables,\n  getInputValue,\n  getOutputValue,\n} from \"@langchain/core/memory\";\nimport {\n  AIMessage,\n  BaseMessage,\n  ChatMessage,\n  getBufferString,\n  HumanMessage,\n  SystemMessage,\n} from \"@langchain/core/messages\";\nimport { BaseChatMemory, BaseChatMemoryInput } from \"./chat_memory.js\";\n\n// Extract Summary and Facts from Zep memory, if present and compose a system prompt\nexport const zepMemoryContextToSystemPrompt = (memory: Memory) => {\n  let systemPrompt = \"\";\n\n  // Extract conversation facts, if present\n  if (memory.facts) {\n    systemPrompt += memory.facts.join(\"\\n\");\n  }\n\n  // Extract summary, if present\n  if (memory.summary && memory.summary?.content) {\n    systemPrompt += memory.summary.content;\n  }\n\n  return systemPrompt;\n};\n\n// We are condensing the Zep context into a human message in order to satisfy\n// some models' input requirements and allow more flexibility for devs.\n// (for example, Anthropic only supports one system message, and does not support multiple user messages in a row)\nexport const condenseZepMemoryIntoHumanMessage = (memory: Memory) => {\n  const systemPrompt = zepMemoryContextToSystemPrompt(memory);\n\n  let concatMessages = \"\";\n\n  // Add message history to the prompt, if present\n  if (memory.messages) {\n    concatMessages = memory.messages\n      .map((msg) => `${msg.role ?? msg.roleType}: ${msg.content}`)\n      .join(\"\\n\");\n  }\n\n  return new HumanMessage(`${systemPrompt}\\n${concatMessages}`);\n};\n\n// Convert Zep Memory to a list of BaseMessages\nexport const zepMemoryToMessages = (memory: Memory) => {\n  const systemPrompt = zepMemoryContextToSystemPrompt(memory);\n\n  let messages: BaseMessage[] = systemPrompt\n    ? [new SystemMessage(systemPrompt)]\n    : [];\n\n  if (memory && memory.messages) {\n    messages = messages.concat(\n      memory.messages\n        .filter((m) => m.content)\n        .map((message) => {\n          const { content, role, roleType } = message;\n          const messageContent = content as string;\n          if (roleType === \"user\") {\n            return new HumanMessage(messageContent);\n          } else if (role === \"assistant\") {\n            return new AIMessage(messageContent);\n          } else {\n            // default to generic ChatMessage\n            return new ChatMessage(\n              messageContent,\n              (roleType ?? role) as string\n            );\n          }\n        })\n    );\n  }\n\n  return messages;\n};\n\n/**\n * Interface defining the structure of the input data for the ZepMemory\n * class. It includes properties like humanPrefix, aiPrefix, memoryKey, memoryType\n * sessionId, and apiKey.\n */\nexport interface ZepCloudMemoryInput extends BaseChatMemoryInput {\n  humanPrefix?: string;\n\n  aiPrefix?: string;\n\n  memoryKey?: string;\n\n  sessionId: string;\n\n  apiKey: string;\n\n  memoryType?: Zep.MemoryType;\n\n  // Whether to return separate messages for chat history with a SystemMessage containing (facts and summary) or return a single HumanMessage with the entire memory context.\n  // Defaults to false (return a single HumanMessage) in order to allow more flexibility with different models.\n  separateMessages?: boolean;\n}\n\n/**\n * Class used to manage the memory of a chat session, including loading\n * and saving the chat history, and clearing the memory when needed. It\n * uses the ZepClient to interact with the Zep service for managing the\n * chat session's memory.\n * @example\n * ```typescript\n * const sessionId = randomUUID();\n *\n * // Initialize ZepCloudMemory with session ID and API key\n * const memory = new ZepCloudMemory({\n *   sessionId,\n *   apiKey: \"<zep api key>\",\n * });\n *\n * // Create a ChatOpenAI model instance with specific parameters\n * const model = new ChatOpenAI({\n *   model: \"gpt-3.5-turbo\",\n *   temperature: 0,\n * });\n *\n * // Create a ConversationChain with the model and memory\n * const chain = new ConversationChain({ llm: model, memory });\n *\n * // Example of calling the chain with an input\n * const res1 = await chain.call({ input: \"Hi! I'm Jim.\" });\n * console.log({ res1 });\n *\n * // Follow-up call to the chain to demonstrate memory usage\n * const res2 = await chain.call({ input: \"What did I just say my name was?\" });\n * console.log({ res2 });\n *\n * // Output the session ID and the current state of memory\n * console.log(\"Session ID: \", sessionId);\n * console.log(\"Memory: \", await memory.loadMemoryVariables({}));\n *\n * ```\n */\nexport class ZepCloudMemory\n  extends BaseChatMemory\n  implements ZepCloudMemoryInput\n{\n  humanPrefix = \"Human\";\n\n  aiPrefix = \"AI\";\n\n  memoryKey = \"history\";\n\n  apiKey: string;\n\n  sessionId: string;\n\n  zepClient: ZepClient;\n\n  memoryType: Zep.MemoryType;\n\n  separateMessages: boolean;\n\n  constructor(fields: ZepCloudMemoryInput) {\n    super({\n      returnMessages: fields?.returnMessages ?? false,\n      inputKey: fields?.inputKey,\n      outputKey: fields?.outputKey,\n    });\n\n    this.humanPrefix = fields.humanPrefix ?? this.humanPrefix;\n    this.aiPrefix = fields.aiPrefix ?? this.aiPrefix;\n    this.memoryKey = fields.memoryKey ?? this.memoryKey;\n    this.apiKey = fields.apiKey;\n    this.sessionId = fields.sessionId;\n    this.memoryType = fields.memoryType ?? \"perpetual\";\n    this.separateMessages = fields.separateMessages ?? false;\n    this.zepClient = new ZepClient({\n      apiKey: this.apiKey,\n    });\n  }\n\n  get memoryKeys() {\n    return [this.memoryKey];\n  }\n\n  /**\n   * Method that retrieves the chat history from the Zep service and formats\n   * it into a list of messages.\n   * @param values Input values for the method.\n   * @returns Promise that resolves with the chat history formatted into a list of messages.\n   */\n  async loadMemoryVariables(values: InputValues): Promise<MemoryVariables> {\n    const memoryType = values.memoryType ?? \"perpetual\";\n    let memory: Memory | null = null;\n    try {\n      memory = await this.zepClient.memory.get(this.sessionId, {\n        memoryType,\n      });\n    } catch (error) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (error instanceof NotFoundError) {\n        return this.returnMessages\n          ? { [this.memoryKey]: [] }\n          : { [this.memoryKey]: \"\" };\n      }\n      throw error;\n    }\n\n    if (this.returnMessages) {\n      return {\n        [this.memoryKey]: this.separateMessages\n          ? zepMemoryToMessages(memory)\n          : [condenseZepMemoryIntoHumanMessage(memory)],\n      };\n    }\n    return {\n      [this.memoryKey]: this.separateMessages\n        ? getBufferString(\n            zepMemoryToMessages(memory),\n            this.humanPrefix,\n            this.aiPrefix\n          )\n        : condenseZepMemoryIntoHumanMessage(memory).content,\n    };\n  }\n\n  /**\n   * Method that saves the input and output messages to the Zep service.\n   * @param inputValues Input messages to be saved.\n   * @param outputValues Output messages to be saved.\n   * @returns Promise that resolves when the messages have been saved.\n   */\n  async saveContext(\n    inputValues: InputValues,\n    outputValues: OutputValues\n  ): Promise<void> {\n    const input = getInputValue(inputValues, this.inputKey);\n    const output = getOutputValue(outputValues, this.outputKey);\n\n    // Add the new memory to the session using the ZepClient\n    if (this.sessionId) {\n      try {\n        await this.zepClient.memory.add(this.sessionId, {\n          messages: [\n            {\n              role: this.humanPrefix,\n              roleType: \"user\",\n              content: `${input}`,\n            },\n            {\n              role: this.aiPrefix,\n              roleType: \"assistant\",\n              content: `${output}`,\n            },\n          ],\n        });\n      } catch (error) {\n        console.error(\"Error adding memory: \", error);\n      }\n    }\n\n    // Call the superclass's saveContext method\n    await super.saveContext(inputValues, outputValues);\n  }\n\n  /**\n   * Method that deletes the chat history from the Zep service.\n   * @returns Promise that resolves when the chat history has been deleted.\n   */\n  async clear(): Promise<void> {\n    try {\n      await this.zepClient.memory.delete(this.sessionId);\n    } catch (error) {\n      console.error(\"Error deleting session: \", error);\n    }\n\n    // Clear the superclass's chat history\n    await super.clear();\n  }\n}\n"],"mappings":"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"}