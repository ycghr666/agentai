{"version":3,"file":"portkey.cjs","names":["HumanMessage","AIMessage","SystemMessage","ChatMessage","HumanMessageChunk","AIMessageChunk","SystemMessageChunk","FunctionMessageChunk","ChatMessageChunk","BaseChatModel","getPortkeySession","ChatGenerationChunk"],"sources":["../../src/chat_models/portkey.ts"],"sourcesContent":["import { LLMOptions } from \"portkey-ai\";\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  ChatMessage,\n  ChatMessageChunk,\n  FunctionMessageChunk,\n  HumanMessage,\n  HumanMessageChunk,\n  SystemMessage,\n  SystemMessageChunk,\n} from \"@langchain/core/messages\";\nimport {\n  ChatResult,\n  ChatGeneration,\n  ChatGenerationChunk,\n} from \"@langchain/core/outputs\";\nimport { BaseChatModel } from \"@langchain/core/language_models/chat_models\";\n\nimport { PortkeySession, getPortkeySession } from \"../llms/portkey.js\";\n\ninterface Message {\n  role?: string;\n  content?: string;\n}\n\nfunction portkeyResponseToChatMessage(message: Message): BaseMessage {\n  switch (message.role) {\n    case \"user\":\n      return new HumanMessage(message.content || \"\");\n    case \"assistant\":\n      return new AIMessage(message.content || \"\");\n    case \"system\":\n      return new SystemMessage(message.content || \"\");\n    default:\n      return new ChatMessage(message.content || \"\", message.role ?? \"unknown\");\n  }\n}\n\nfunction _convertDeltaToMessageChunk(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  delta: Record<string, any>\n) {\n  const { role } = delta;\n  const content = delta.content ?? \"\";\n  let additional_kwargs;\n  if (delta.function_call) {\n    additional_kwargs = {\n      function_call: delta.function_call,\n    };\n  } else {\n    additional_kwargs = {};\n  }\n  if (role === \"user\") {\n    return new HumanMessageChunk({ content });\n  } else if (role === \"assistant\") {\n    return new AIMessageChunk({ content, additional_kwargs });\n  } else if (role === \"system\") {\n    return new SystemMessageChunk({ content });\n  } else if (role === \"function\") {\n    return new FunctionMessageChunk({\n      content,\n      additional_kwargs,\n      name: delta.name,\n    });\n  } else {\n    return new ChatMessageChunk({ content, role });\n  }\n}\n\nexport class PortkeyChat extends BaseChatModel {\n  apiKey?: string = undefined;\n\n  baseURL?: string = undefined;\n\n  mode?: string = undefined;\n\n  llms?: [LLMOptions] | null = undefined;\n\n  session: PortkeySession;\n\n  constructor(init?: Partial<PortkeyChat>) {\n    super(init ?? {});\n    this.apiKey = init?.apiKey;\n    this.baseURL = init?.baseURL;\n    this.mode = init?.mode;\n    this.llms = init?.llms;\n    this.session = getPortkeySession({\n      apiKey: this.apiKey,\n      baseURL: this.baseURL,\n      llms: this.llms,\n      mode: this.mode,\n    });\n  }\n\n  _llmType() {\n    return \"portkey\";\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    _?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const messagesList = messages.map((message) => {\n      if (typeof message.content !== \"string\") {\n        throw new Error(\n          \"PortkeyChat does not support non-string message content.\"\n        );\n      }\n      return {\n        role: message._getType() as string,\n        content: message.content,\n      };\n    });\n    const response = await this.session.portkey.chatCompletions.create({\n      messages: messagesList,\n      ...options,\n      stream: false,\n    });\n    const generations: ChatGeneration[] = [];\n    for (const data of response.choices ?? []) {\n      const text = data.message?.content ?? \"\";\n      const generation: ChatGeneration = {\n        text,\n        message: portkeyResponseToChatMessage(data.message ?? {}),\n      };\n      if (data.finish_reason) {\n        generation.generationInfo = { finish_reason: data.finish_reason };\n      }\n      generations.push(generation);\n    }\n\n    return {\n      generations,\n    };\n  }\n\n  async *_streamResponseChunks(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const messagesList = messages.map((message) => {\n      if (typeof message.content !== \"string\") {\n        throw new Error(\n          \"PortkeyChat does not support non-string message content.\"\n        );\n      }\n      return {\n        role: message._getType() as string,\n        content: message.content,\n      };\n    });\n    const response = await this.session.portkey.chatCompletions.create({\n      messages: messagesList,\n      ...options,\n      stream: true,\n    });\n    for await (const data of response) {\n      const choice = data?.choices[0];\n      if (!choice) {\n        continue;\n      }\n      const chunk = new ChatGenerationChunk({\n        message: _convertDeltaToMessageChunk(choice.delta ?? {}),\n        text: choice.message?.content ?? \"\",\n        generationInfo: {\n          finishReason: choice.finish_reason,\n        },\n      });\n      yield chunk;\n      // eslint-disable-next-line no-void\n      void runManager?.handleLLMNewToken(chunk.text ?? \"\");\n    }\n    if (options.signal?.aborted) {\n      throw new Error(\"AbortError\");\n    }\n  }\n\n  _combineLLMOutput() {\n    return {};\n  }\n}\n"],"mappings":"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"}