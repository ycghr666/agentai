{"version":3,"file":"minimax.cjs","names":["Embeddings"],"sources":["../../src/embeddings/minimax.ts"],"sourcesContent":["import { getEnvironmentVariable } from \"@langchain/core/utils/env\";\nimport { Embeddings, EmbeddingsParams } from \"@langchain/core/embeddings\";\nimport { chunkArray } from \"@langchain/core/utils/chunk_array\";\nimport { ConfigurationParameters } from \"../chat_models/minimax.js\";\n\n/**\n * Interface for MinimaxEmbeddings parameters. Extends EmbeddingsParams and\n * defines additional parameters specific to the MinimaxEmbeddings class.\n */\nexport interface MinimaxEmbeddingsParams extends EmbeddingsParams {\n  /**\n   * Model name to use\n   * Alias for `model`\n   */\n  modelName: string;\n  /** Model name to use */\n  model: string;\n\n  /**\n   * API key to use when making requests. Defaults to the value of\n   * `MINIMAX_GROUP_ID` environment variable.\n   */\n  minimaxGroupId?: string;\n\n  /**\n   * Secret key to use when making requests. Defaults to the value of\n   * `MINIMAX_API_KEY` environment variable.\n   * Alias for `apiKey`\n   */\n  minimaxApiKey?: string;\n  /**\n   * Secret key to use when making requests. Defaults to the value of\n   * `MINIMAX_API_KEY` environment variable.\n   */\n  apiKey?: string;\n\n  /**\n   * The maximum number of documents to embed in a single request. This is\n   * limited by the Minimax API to a maximum of 4096.\n   */\n  batchSize?: number;\n\n  /**\n   * Whether to strip new lines from the input text. This is recommended by\n   * Minimax, but may not be suitable for all use cases.\n   */\n  stripNewLines?: boolean;\n\n  /**\n   *  The target use-case after generating the vector.\n   *  When using embeddings, the vector of the target content is first generated through the db and stored in the vector database,\n   *  and then the vector of the retrieval text is generated through the query.\n   *  Note: For the parameters of the partial algorithm, we adopted a separate algorithm plan for query and db.\n   *  Therefore, for a paragraph of text, if it is to be used as a retrieval text, it should use the db,\n   *  and if it is used as a retrieval text, it should use the query.\n   */\n  type?: \"db\" | \"query\";\n}\n\nexport interface CreateMinimaxEmbeddingRequest {\n  /**\n   * @type {string}\n   * @memberof CreateMinimaxEmbeddingRequest\n   */\n  model: string;\n\n  /**\n   *  Text to generate vector expectation\n   * @type {CreateEmbeddingRequestInput}\n   * @memberof CreateMinimaxEmbeddingRequest\n   */\n  texts: string[];\n\n  /**\n   *  The target use-case after generating the vector. When using embeddings,\n   *  first generate the vector of the target content through the db and store it in the vector database,\n   *  and then generate the vector of the retrieval text through the query.\n   *  Note: For the parameter of the algorithm, we use the algorithm scheme of query and db separation,\n   *  so a text, if it is to be retrieved as a text, should use the db,\n   *  if it is used as a retrieval text, should use the query.\n   * @type {string}\n   * @memberof CreateMinimaxEmbeddingRequest\n   */\n  type: \"db\" | \"query\";\n}\n\n/**\n * Class for generating embeddings using the Minimax API. Extends the\n * Embeddings class and implements MinimaxEmbeddingsParams\n * @example\n * ```typescript\n * const embeddings = new MinimaxEmbeddings();\n *\n * // Embed a single query\n * const queryEmbedding = await embeddings.embedQuery(\"Hello world\");\n * console.log(queryEmbedding);\n *\n * // Embed multiple documents\n * const documentsEmbedding = await embeddings.embedDocuments([\n *   \"Hello world\",\n *   \"Bye bye\",\n * ]);\n * console.log(documentsEmbedding);\n * ```\n */\nexport class MinimaxEmbeddings\n  extends Embeddings\n  implements MinimaxEmbeddingsParams\n{\n  modelName = \"embo-01\";\n\n  model = \"embo-01\";\n\n  batchSize = 512;\n\n  stripNewLines = true;\n\n  minimaxGroupId?: string;\n\n  minimaxApiKey?: string;\n\n  apiKey?: string;\n\n  type: \"db\" | \"query\" = \"db\";\n\n  apiUrl: string;\n\n  basePath?: string = \"https://api.minimax.chat/v1\";\n\n  headers?: Record<string, string>;\n\n  constructor(\n    fields?: Partial<MinimaxEmbeddingsParams> & {\n      configuration?: ConfigurationParameters;\n    }\n  ) {\n    const fieldsWithDefaults = { maxConcurrency: 2, ...fields };\n    super(fieldsWithDefaults);\n\n    this.minimaxGroupId =\n      fields?.minimaxGroupId ?? getEnvironmentVariable(\"MINIMAX_GROUP_ID\");\n    if (!this.minimaxGroupId) {\n      throw new Error(\"Minimax GroupID  not found\");\n    }\n\n    this.minimaxApiKey =\n      fields?.apiKey ??\n      fields?.minimaxApiKey ??\n      getEnvironmentVariable(\"MINIMAX_API_KEY\");\n    this.apiKey = this.minimaxApiKey;\n    if (!this.apiKey) {\n      throw new Error(\"Minimax ApiKey not found\");\n    }\n\n    this.modelName =\n      fieldsWithDefaults?.model ?? fieldsWithDefaults?.modelName ?? this.model;\n    this.model = this.modelName;\n    this.batchSize = fieldsWithDefaults?.batchSize ?? this.batchSize;\n    this.type = fieldsWithDefaults?.type ?? this.type;\n    this.stripNewLines =\n      fieldsWithDefaults?.stripNewLines ?? this.stripNewLines;\n    this.basePath = fields?.configuration?.basePath ?? this.basePath;\n    this.apiUrl = `${this.basePath}/embeddings`;\n    this.headers = fields?.configuration?.headers ?? this.headers;\n  }\n\n  /**\n   * Method to generate embeddings for an array of documents. Splits the\n   * documents into batches and makes requests to the Minimax API to generate\n   * embeddings.\n   * @param texts Array of documents to generate embeddings for.\n   * @returns Promise that resolves to a 2D array of embeddings for each document.\n   */\n  async embedDocuments(texts: string[]): Promise<number[][]> {\n    const batches = chunkArray(\n      this.stripNewLines ? texts.map((t) => t.replace(/\\n/g, \" \")) : texts,\n      this.batchSize\n    );\n\n    const batchRequests = batches.map((batch) =>\n      this.embeddingWithRetry({\n        model: this.model,\n        texts: batch,\n        type: this.type,\n      })\n    );\n    const batchResponses = await Promise.all(batchRequests);\n\n    const embeddings: number[][] = [];\n    for (let i = 0; i < batchResponses.length; i += 1) {\n      const batch = batches[i];\n      const { vectors: batchResponse } = batchResponses[i];\n      for (let j = 0; j < batch.length; j += 1) {\n        embeddings.push(batchResponse[j]);\n      }\n    }\n    return embeddings;\n  }\n\n  /**\n   * Method to generate an embedding for a single document. Calls the\n   * embeddingWithRetry method with the document as the input.\n   * @param text Document to generate an embedding for.\n   * @returns Promise that resolves to an embedding for the document.\n   */\n  async embedQuery(text: string): Promise<number[]> {\n    const { vectors } = await this.embeddingWithRetry({\n      model: this.model,\n      texts: [this.stripNewLines ? text.replace(/\\n/g, \" \") : text],\n      type: this.type,\n    });\n    return vectors[0];\n  }\n\n  /**\n   * Private method to make a request to the Minimax API to generate\n   * embeddings. Handles the retry logic and returns the response from the\n   * API.\n   * @param request Request to send to the Minimax API.\n   * @returns Promise that resolves to the response from the API.\n   */\n  private async embeddingWithRetry(request: CreateMinimaxEmbeddingRequest) {\n    const makeCompletionRequest = async () => {\n      const url = `${this.apiUrl}?GroupId=${this.minimaxGroupId}`;\n      const response = await fetch(url, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${this.apiKey}`,\n          ...this.headers,\n        },\n        body: JSON.stringify(request),\n      });\n\n      const json = await response.json();\n      return json;\n    };\n\n    return this.caller.call(makeCompletionRequest);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAyGA,IAAa,oBAAb,cACUA,sCAEV;CACE,YAAY;CAEZ,QAAQ;CAER,YAAY;CAEZ,gBAAgB;CAEhB;CAEA;CAEA;CAEA,OAAuB;CAEvB;CAEA,WAAoB;CAEpB;CAEA,YACE,QAGA;EACA,MAAM,qBAAqB;GAAE,gBAAgB;GAAG,GAAG;GAAQ;AAC3D,QAAM,mBAAmB;AAEzB,OAAK,iBACH,QAAQ,wEAAyC,mBAAmB;AACtE,MAAI,CAAC,KAAK,eACR,OAAM,IAAI,MAAM,6BAA6B;AAG/C,OAAK,gBACH,QAAQ,UACR,QAAQ,uEACe,kBAAkB;AAC3C,OAAK,SAAS,KAAK;AACnB,MAAI,CAAC,KAAK,OACR,OAAM,IAAI,MAAM,2BAA2B;AAG7C,OAAK,YACH,oBAAoB,SAAS,oBAAoB,aAAa,KAAK;AACrE,OAAK,QAAQ,KAAK;AAClB,OAAK,YAAY,oBAAoB,aAAa,KAAK;AACvD,OAAK,OAAO,oBAAoB,QAAQ,KAAK;AAC7C,OAAK,gBACH,oBAAoB,iBAAiB,KAAK;AAC5C,OAAK,WAAW,QAAQ,eAAe,YAAY,KAAK;AACxD,OAAK,SAAS,GAAG,KAAK,SAAS;AAC/B,OAAK,UAAU,QAAQ,eAAe,WAAW,KAAK;;;;;;;;;CAUxD,MAAM,eAAe,OAAsC;EACzD,MAAM,4DACJ,KAAK,gBAAgB,MAAM,KAAK,MAAM,EAAE,QAAQ,OAAO,IAAI,CAAC,GAAG,OAC/D,KAAK,UACN;EAED,MAAM,gBAAgB,QAAQ,KAAK,UACjC,KAAK,mBAAmB;GACtB,OAAO,KAAK;GACZ,OAAO;GACP,MAAM,KAAK;GACZ,CAAC,CACH;EACD,MAAM,iBAAiB,MAAM,QAAQ,IAAI,cAAc;EAEvD,MAAM,aAAyB,EAAE;AACjC,OAAK,IAAI,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK,GAAG;GACjD,MAAM,QAAQ,QAAQ;GACtB,MAAM,EAAE,SAAS,kBAAkB,eAAe;AAClD,QAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,EACrC,YAAW,KAAK,cAAc,GAAG;;AAGrC,SAAO;;;;;;;;CAST,MAAM,WAAW,MAAiC;EAChD,MAAM,EAAE,YAAY,MAAM,KAAK,mBAAmB;GAChD,OAAO,KAAK;GACZ,OAAO,CAAC,KAAK,gBAAgB,KAAK,QAAQ,OAAO,IAAI,GAAG,KAAK;GAC7D,MAAM,KAAK;GACZ,CAAC;AACF,SAAO,QAAQ;;;;;;;;;CAUjB,MAAc,mBAAmB,SAAwC;EACvE,MAAM,wBAAwB,YAAY;GACxC,MAAM,MAAM,GAAG,KAAK,OAAO,WAAW,KAAK;AAY3C,UADa,OAVI,MAAM,MAAM,KAAK;IAChC,QAAQ;IACR,SAAS;KACP,gBAAgB;KAChB,eAAe,UAAU,KAAK;KAC9B,GAAG,KAAK;KACT;IACD,MAAM,KAAK,UAAU,QAAQ;IAC9B,CAAC,EAE0B,MAAM;;AAIpC,SAAO,KAAK,OAAO,KAAK,sBAAsB"}