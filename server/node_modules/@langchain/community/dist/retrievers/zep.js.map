{"version":3,"file":"zep.js","names":[],"sources":["../../src/retrievers/zep.ts"],"sourcesContent":["import {\n  MemorySearchPayload,\n  MemorySearchResult,\n  NotFoundError,\n  ZepClient,\n} from \"@getzep/zep-js\";\nimport { BaseRetriever, BaseRetrieverInput } from \"@langchain/core/retrievers\";\nimport { Document } from \"@langchain/core/documents\";\n\n/**\n * Configuration interface for the ZepRetriever class. Extends the\n * BaseRetrieverInput interface.\n *\n * @argument {string} sessionId - The ID of the Zep session.\n * @argument {string} url - The URL of the Zep API.\n * @argument {number} [topK] - The number of results to return.\n * @argument {string} [apiKey] - The API key for the Zep API.\n * @argument [searchScope] [searchScope] - The scope of the search: \"messages\" or \"summary\".\n * @argument [searchType] [searchType] - The type of search to perform: \"similarity\" or \"mmr\".\n * @argument {number} [mmrLambda] - The lambda value for the MMR search.\n * @argument {Record<string, unknown>} [filter] - The metadata filter to apply to the search.\n */\nexport interface ZepRetrieverConfig extends BaseRetrieverInput {\n  sessionId: string;\n  url: string;\n  topK?: number;\n  apiKey?: string;\n  searchScope?: \"messages\" | \"summary\";\n  searchType?: \"similarity\" | \"mmr\";\n  mmrLambda?: number;\n  filter?: Record<string, unknown>;\n}\n\n/**\n * Class for retrieving information from a Zep long-term memory store.\n * Extends the BaseRetriever class.\n * @example\n * ```typescript\n * const retriever = new ZepRetriever({\n *   url: \"http:\n *   sessionId: \"session_exampleUUID\",\n *   topK: 3,\n * });\n * const query = \"Can I drive red cars in France?\";\n * const docs = await retriever.getRelevantDocuments(query);\n * ```\n */\nexport class ZepRetriever extends BaseRetriever {\n  static lc_name() {\n    return \"ZepRetriever\";\n  }\n\n  lc_namespace = [\"langchain\", \"retrievers\", \"zep\"];\n\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return {\n      apiKey: \"ZEP_API_KEY\",\n      url: \"ZEP_API_URL\",\n    };\n  }\n\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return { apiKey: \"api_key\" };\n  }\n\n  zepClientPromise: Promise<ZepClient>;\n\n  private sessionId: string;\n\n  private topK?: number;\n\n  private searchScope?: \"messages\" | \"summary\";\n\n  private searchType?: \"similarity\" | \"mmr\";\n\n  private mmrLambda?: number;\n\n  private filter?: Record<string, unknown>;\n\n  constructor(config: ZepRetrieverConfig) {\n    super(config);\n    this.sessionId = config.sessionId;\n    this.topK = config.topK;\n    this.searchScope = config.searchScope;\n    this.searchType = config.searchType;\n    this.mmrLambda = config.mmrLambda;\n    this.filter = config.filter;\n    this.zepClientPromise = ZepClient.init(config.url, config.apiKey);\n  }\n\n  /**\n   *  Converts an array of message search results to an array of Document objects.\n   *  @param {MemorySearchResult[]} results - The array of search results.\n   *  @returns {Document[]} An array of Document objects representing the search results.\n   */\n  private searchMessageResultToDoc(results: MemorySearchResult[]): Document[] {\n    return results\n      .filter((r) => r.message)\n      .map(\n        ({\n          message: { content, metadata: messageMetadata } = {},\n          dist,\n          ...rest\n        }) =>\n          new Document({\n            pageContent: content ?? \"\",\n            metadata: { score: dist, ...messageMetadata, ...rest },\n          })\n      );\n  }\n\n  /**\n   *  Converts an array of summary search results to an array of Document objects.\n   *  @param {MemorySearchResult[]} results - The array of search results.\n   *  @returns {Document[]} An array of Document objects representing the search results.\n   */\n  private searchSummaryResultToDoc(results: MemorySearchResult[]): Document[] {\n    return results\n      .filter((r) => r.summary)\n      .map(\n        ({\n          summary: { content, metadata: summaryMetadata } = {},\n          dist,\n          ...rest\n        }) =>\n          new Document({\n            pageContent: content ?? \"\",\n            metadata: { score: dist, ...summaryMetadata, ...rest },\n          })\n      );\n  }\n\n  /**\n   *  Retrieves the relevant documents based on the given query.\n   *  @param {string} query - The query string.\n   *  @returns {Promise<Document[]>} A promise that resolves to an array of relevant Document objects.\n   */\n  async _getRelevantDocuments(query: string): Promise<Document[]> {\n    const payload: MemorySearchPayload = {\n      text: query,\n      metadata: this.filter,\n      search_scope: this.searchScope,\n      search_type: this.searchType,\n      mmr_lambda: this.mmrLambda,\n    };\n    // Wait for ZepClient to be initialized\n    const zepClient = await this.zepClientPromise;\n    if (!zepClient) {\n      throw new Error(\"ZepClient is not initialized\");\n    }\n    try {\n      const results: MemorySearchResult[] = await zepClient.memory.searchMemory(\n        this.sessionId,\n        payload,\n        this.topK\n      );\n      return this.searchScope === \"summary\"\n        ? this.searchSummaryResultToDoc(results)\n        : this.searchMessageResultToDoc(results);\n    } catch (error) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (error instanceof NotFoundError) {\n        return Promise.resolve([]); // Return an empty Document array\n      }\n      // If it's not a NotFoundError, throw the error again\n      throw error;\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AA+CA,IAAa,eAAb,cAAkC,cAAc;CAC9C,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe;EAAC;EAAa;EAAc;EAAM;CAEjD,IAAI,aAAoD;AACtD,SAAO;GACL,QAAQ;GACR,KAAK;GACN;;CAGH,IAAI,aAAoD;AACtD,SAAO,EAAE,QAAQ,WAAW;;CAG9B;CAEA,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,AAAQ;CAER,YAAY,QAA4B;AACtC,QAAM,OAAO;AACb,OAAK,YAAY,OAAO;AACxB,OAAK,OAAO,OAAO;AACnB,OAAK,cAAc,OAAO;AAC1B,OAAK,aAAa,OAAO;AACzB,OAAK,YAAY,OAAO;AACxB,OAAK,SAAS,OAAO;AACrB,OAAK,mBAAmB,UAAU,KAAK,OAAO,KAAK,OAAO,OAAO;;;;;;;CAQnE,AAAQ,yBAAyB,SAA2C;AAC1E,SAAO,QACJ,QAAQ,MAAM,EAAE,QAAQ,CACxB,KACE,EACC,SAAS,EAAE,SAAS,UAAU,oBAAoB,EAAE,EACpD,MACA,GAAG,WAEH,IAAI,SAAS;GACX,aAAa,WAAW;GACxB,UAAU;IAAE,OAAO;IAAM,GAAG;IAAiB,GAAG;IAAM;GACvD,CAAC,CACL;;;;;;;CAQL,AAAQ,yBAAyB,SAA2C;AAC1E,SAAO,QACJ,QAAQ,MAAM,EAAE,QAAQ,CACxB,KACE,EACC,SAAS,EAAE,SAAS,UAAU,oBAAoB,EAAE,EACpD,MACA,GAAG,WAEH,IAAI,SAAS;GACX,aAAa,WAAW;GACxB,UAAU;IAAE,OAAO;IAAM,GAAG;IAAiB,GAAG;IAAM;GACvD,CAAC,CACL;;;;;;;CAQL,MAAM,sBAAsB,OAAoC;EAC9D,MAAM,UAA+B;GACnC,MAAM;GACN,UAAU,KAAK;GACf,cAAc,KAAK;GACnB,aAAa,KAAK;GAClB,YAAY,KAAK;GAClB;EAED,MAAM,YAAY,MAAM,KAAK;AAC7B,MAAI,CAAC,UACH,OAAM,IAAI,MAAM,+BAA+B;AAEjD,MAAI;GACF,MAAM,UAAgC,MAAM,UAAU,OAAO,aAC3D,KAAK,WACL,SACA,KAAK,KACN;AACD,UAAO,KAAK,gBAAgB,YACxB,KAAK,yBAAyB,QAAQ,GACtC,KAAK,yBAAyB,QAAQ;WACnC,OAAO;AAEd,OAAI,iBAAiB,cACnB,QAAO,QAAQ,QAAQ,EAAE,CAAC;AAG5B,SAAM"}