{"version":3,"file":"googlevertexai.cjs","names":["Document","GoogleVertexAIConnection","GoogleAuth","VectorStore","AsyncCaller"],"sources":["../../src/vectorstores/googlevertexai.ts"],"sourcesContent":["import * as uuid from \"uuid\";\nimport flatten from \"flat\";\nimport { GoogleAuth, GoogleAuthOptions } from \"google-auth-library\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { Document, DocumentInput } from \"@langchain/core/documents\";\nimport {\n  AsyncCaller,\n  AsyncCallerCallOptions,\n  AsyncCallerParams,\n} from \"@langchain/core/utils/async_caller\";\n\nimport { GoogleVertexAIConnection } from \"../utils/googlevertexai-connection.js\";\nimport { Docstore } from \"../stores/doc/base.js\";\nimport {\n  GoogleVertexAIConnectionParams,\n  GoogleResponse,\n  GoogleAbstractedClientOpsMethod,\n} from \"../types/googlevertexai-types.js\";\n\n/**\n * Allows us to create IdDocument classes that contain the ID.\n */\nexport interface IdDocumentInput extends DocumentInput {\n  id?: string;\n}\n\n/**\n * A Document that optionally includes the ID of the document.\n */\nexport class IdDocument extends Document implements IdDocumentInput {\n  id?: string;\n\n  constructor(fields: IdDocumentInput) {\n    super(fields);\n    this.id = fields.id;\n  }\n}\n\ninterface IndexEndpointConnectionParams extends GoogleVertexAIConnectionParams<GoogleAuthOptions> {\n  indexEndpoint: string;\n}\n\ninterface DeployedIndex {\n  id: string;\n  index: string;\n  // There are other attributes, but we don't care about them right now\n}\n\ninterface IndexEndpointResponse extends GoogleResponse {\n  data: {\n    deployedIndexes: DeployedIndex[];\n    publicEndpointDomainName: string;\n    // There are other attributes, but we don't care about them right now\n  };\n}\n\nclass IndexEndpointConnection extends GoogleVertexAIConnection<\n  AsyncCallerCallOptions,\n  IndexEndpointResponse,\n  GoogleAuthOptions\n> {\n  indexEndpoint: string;\n\n  constructor(fields: IndexEndpointConnectionParams, caller: AsyncCaller) {\n    super(fields, caller, new GoogleAuth(fields.authOptions));\n\n    this.indexEndpoint = fields.indexEndpoint;\n  }\n\n  async buildUrl(): Promise<string> {\n    const projectId = await this.client.getProjectId();\n    const url = `https://${this.endpoint}/${this.apiVersion}/projects/${projectId}/locations/${this.location}/indexEndpoints/${this.indexEndpoint}`;\n    return url;\n  }\n\n  buildMethod(): GoogleAbstractedClientOpsMethod {\n    return \"GET\";\n  }\n\n  async request(\n    options: AsyncCallerCallOptions\n  ): Promise<IndexEndpointResponse> {\n    return this._request(undefined, options);\n  }\n}\n\n/**\n * Used to represent parameters that are necessary to delete documents\n * from the matching engine. These must be a list of string IDs\n */\nexport interface MatchingEngineDeleteParams {\n  ids: string[];\n}\n\ninterface RemoveDatapointParams extends GoogleVertexAIConnectionParams<GoogleAuthOptions> {\n  index: string;\n}\n\ninterface RemoveDatapointRequest {\n  datapointIds: string[];\n}\n\ninterface RemoveDatapointResponse extends GoogleResponse {\n  // Should be empty\n}\n\nclass RemoveDatapointConnection extends GoogleVertexAIConnection<\n  AsyncCallerCallOptions,\n  RemoveDatapointResponse,\n  GoogleAuthOptions\n> {\n  index: string;\n\n  constructor(fields: RemoveDatapointParams, caller: AsyncCaller) {\n    super(fields, caller, new GoogleAuth(fields.authOptions));\n\n    this.index = fields.index;\n  }\n\n  async buildUrl(): Promise<string> {\n    const projectId = await this.client.getProjectId();\n    const url = `https://${this.endpoint}/${this.apiVersion}/projects/${projectId}/locations/${this.location}/indexes/${this.index}:removeDatapoints`;\n    return url;\n  }\n\n  buildMethod(): GoogleAbstractedClientOpsMethod {\n    return \"POST\";\n  }\n\n  async request(\n    datapointIds: string[],\n    options: AsyncCallerCallOptions\n  ): Promise<RemoveDatapointResponse> {\n    const data: RemoveDatapointRequest = {\n      datapointIds,\n    };\n    return this._request(data, options);\n  }\n}\n\ninterface UpsertDatapointParams extends GoogleVertexAIConnectionParams<GoogleAuthOptions> {\n  index: string;\n}\n\nexport interface Restriction {\n  namespace: string;\n  allowList?: string[];\n  denyList?: string[];\n}\n\ninterface CrowdingTag {\n  crowdingAttribute: string;\n}\n\ninterface IndexDatapoint {\n  datapointId: string;\n  featureVector: number[];\n  restricts?: Restriction[];\n  crowdingTag?: CrowdingTag;\n}\n\ninterface UpsertDatapointRequest {\n  datapoints: IndexDatapoint[];\n}\n\ninterface UpsertDatapointResponse extends GoogleResponse {\n  // Should be empty\n}\n\nclass UpsertDatapointConnection extends GoogleVertexAIConnection<\n  AsyncCallerCallOptions,\n  UpsertDatapointResponse,\n  GoogleAuthOptions\n> {\n  index: string;\n\n  constructor(fields: UpsertDatapointParams, caller: AsyncCaller) {\n    super(fields, caller, new GoogleAuth(fields.authOptions));\n\n    this.index = fields.index;\n  }\n\n  async buildUrl(): Promise<string> {\n    const projectId = await this.client.getProjectId();\n    const url = `https://${this.endpoint}/${this.apiVersion}/projects/${projectId}/locations/${this.location}/indexes/${this.index}:upsertDatapoints`;\n    return url;\n  }\n\n  buildMethod(): GoogleAbstractedClientOpsMethod {\n    return \"POST\";\n  }\n\n  async request(\n    datapoints: IndexDatapoint[],\n    options: AsyncCallerCallOptions\n  ): Promise<UpsertDatapointResponse> {\n    const data: UpsertDatapointRequest = {\n      datapoints,\n    };\n    return this._request(data, options);\n  }\n}\n\ninterface FindNeighborsConnectionParams extends GoogleVertexAIConnectionParams<GoogleAuthOptions> {\n  indexEndpoint: string;\n\n  deployedIndexId: string;\n}\n\ninterface FindNeighborsRequestQuery {\n  datapoint: {\n    datapointId: string;\n    featureVector: number[];\n    restricts?: Restriction[];\n  };\n  neighborCount: number;\n}\n\ninterface FindNeighborsRequest {\n  deployedIndexId: string;\n  queries: FindNeighborsRequestQuery[];\n}\n\ninterface FindNeighborsResponseNeighbor {\n  datapoint: {\n    datapointId: string;\n    crowdingTag: {\n      crowdingTagAttribute: string;\n    };\n  };\n  distance: number;\n}\n\ninterface FindNeighborsResponseNearestNeighbor {\n  id: string;\n  neighbors: FindNeighborsResponseNeighbor[];\n}\n\ninterface FindNeighborsResponse extends GoogleResponse {\n  data: {\n    nearestNeighbors: FindNeighborsResponseNearestNeighbor[];\n  };\n}\n\nclass FindNeighborsConnection\n  extends GoogleVertexAIConnection<\n    AsyncCallerCallOptions,\n    FindNeighborsResponse,\n    GoogleAuthOptions\n  >\n  implements FindNeighborsConnectionParams\n{\n  indexEndpoint: string;\n\n  deployedIndexId: string;\n\n  constructor(params: FindNeighborsConnectionParams, caller: AsyncCaller) {\n    super(params, caller, new GoogleAuth(params.authOptions));\n\n    this.indexEndpoint = params.indexEndpoint;\n    this.deployedIndexId = params.deployedIndexId;\n  }\n\n  async buildUrl(): Promise<string> {\n    const projectId = await this.client.getProjectId();\n    const url = `https://${this.endpoint}/${this.apiVersion}/projects/${projectId}/locations/${this.location}/indexEndpoints/${this.indexEndpoint}:findNeighbors`;\n    return url;\n  }\n\n  buildMethod(): GoogleAbstractedClientOpsMethod {\n    return \"POST\";\n  }\n\n  async request(\n    request: FindNeighborsRequest,\n    options: AsyncCallerCallOptions\n  ): Promise<FindNeighborsResponse> {\n    return this._request(request, options);\n  }\n}\n\n/**\n * Information about the Matching Engine public API endpoint.\n * Primarily exported to allow for testing.\n */\nexport interface PublicAPIEndpointInfo {\n  apiEndpoint?: string;\n\n  deployedIndexId?: string;\n}\n\n/**\n * Parameters necessary to configure the Matching Engine.\n */\nexport interface MatchingEngineArgs\n  extends\n    GoogleVertexAIConnectionParams<GoogleAuthOptions>,\n    IndexEndpointConnectionParams,\n    UpsertDatapointParams {\n  docstore: Docstore;\n\n  callerParams?: AsyncCallerParams;\n\n  callerOptions?: AsyncCallerCallOptions;\n\n  apiEndpoint?: string;\n\n  deployedIndexId?: string;\n}\n\n/**\n * A class that represents a connection to a Google Vertex AI Matching Engine\n * instance.\n */\nexport class MatchingEngine extends VectorStore implements MatchingEngineArgs {\n  declare FilterType: Restriction[];\n\n  /**\n   * Docstore that retains the document, stored by ID\n   */\n  docstore: Docstore;\n\n  /**\n   * The host to connect to for queries and upserts.\n   */\n  apiEndpoint: string;\n\n  apiVersion = \"v1\";\n\n  endpoint = \"us-central1-aiplatform.googleapis.com\";\n\n  location = \"us-central1\";\n\n  /**\n   * The id for the index endpoint\n   */\n  indexEndpoint: string;\n\n  /**\n   * The id for the index\n   */\n  index: string;\n\n  /**\n   * Explicitly set Google Auth credentials if you cannot get them from google auth application-default login\n   * This is useful for serverless or autoscaling environments like Fargate\n   */\n  authOptions: GoogleAuthOptions;\n\n  /**\n   * The id for the \"deployed index\", which is an identifier in the\n   * index endpoint that references the index (but is not the index id)\n   */\n  deployedIndexId: string;\n\n  callerParams: AsyncCallerParams;\n\n  callerOptions: AsyncCallerCallOptions;\n\n  caller: AsyncCaller;\n\n  indexEndpointClient: IndexEndpointConnection;\n\n  removeDatapointClient: RemoveDatapointConnection;\n\n  upsertDatapointClient: UpsertDatapointConnection;\n\n  constructor(embeddings: EmbeddingsInterface, args: MatchingEngineArgs) {\n    super(embeddings, args);\n\n    this.embeddings = embeddings;\n    this.docstore = args.docstore;\n\n    this.apiEndpoint = args.apiEndpoint ?? this.apiEndpoint;\n    this.deployedIndexId = args.deployedIndexId ?? this.deployedIndexId;\n\n    this.apiVersion = args.apiVersion ?? this.apiVersion;\n    this.endpoint = args.endpoint ?? this.endpoint;\n    this.location = args.location ?? this.location;\n    this.indexEndpoint = args.indexEndpoint ?? this.indexEndpoint;\n    this.index = args.index ?? this.index;\n    this.authOptions = args.authOptions ?? this.authOptions;\n\n    this.callerParams = args.callerParams ?? this.callerParams;\n    this.callerOptions = args.callerOptions ?? this.callerOptions;\n    this.caller = new AsyncCaller(this.callerParams || {});\n\n    const indexClientParams: IndexEndpointConnectionParams = {\n      endpoint: this.endpoint,\n      location: this.location,\n      apiVersion: this.apiVersion,\n      indexEndpoint: this.indexEndpoint,\n      authOptions: this.authOptions,\n    };\n    this.indexEndpointClient = new IndexEndpointConnection(\n      indexClientParams,\n      this.caller\n    );\n\n    const removeClientParams: RemoveDatapointParams = {\n      endpoint: this.endpoint,\n      location: this.location,\n      apiVersion: this.apiVersion,\n      index: this.index,\n      authOptions: this.authOptions,\n    };\n    this.removeDatapointClient = new RemoveDatapointConnection(\n      removeClientParams,\n      this.caller\n    );\n\n    const upsertClientParams: UpsertDatapointParams = {\n      endpoint: this.endpoint,\n      location: this.location,\n      apiVersion: this.apiVersion,\n      index: this.index,\n      authOptions: this.authOptions,\n    };\n    this.upsertDatapointClient = new UpsertDatapointConnection(\n      upsertClientParams,\n      this.caller\n    );\n  }\n\n  _vectorstoreType(): string {\n    return \"googlevertexai\";\n  }\n\n  async addDocuments(documents: Document[]): Promise<void> {\n    const texts: string[] = documents.map((doc) => doc.pageContent);\n    const vectors: number[][] = await this.embeddings.embedDocuments(texts);\n    return this.addVectors(vectors, documents);\n  }\n\n  async addVectors(vectors: number[][], documents: Document[]): Promise<void> {\n    if (vectors.length !== documents.length) {\n      throw new Error(`Vectors and metadata must have the same length`);\n    }\n    const datapoints: IndexDatapoint[] = vectors.map((vector, idx) =>\n      this.buildDatapoint(vector, documents[idx])\n    );\n    const options = {};\n    const response = await this.upsertDatapointClient.request(\n      datapoints,\n      options\n    );\n    if (Object.keys(response?.data ?? {}).length === 0) {\n      // Nothing in the response in the body means we saved it ok\n      const idDoc = documents as IdDocument[];\n      const docsToStore: Record<string, Document> = {};\n      idDoc.forEach((doc) => {\n        if (doc.id) {\n          docsToStore[doc.id] = doc;\n        }\n      });\n      await this.docstore.add(docsToStore);\n    }\n  }\n\n  // TODO: Refactor this into a utility type and use with pinecone as well?\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  cleanMetadata(documentMetadata: Record<string, any>): {\n    [key: string]: string | number | boolean | string[] | null;\n  } {\n    type metadataType = {\n      [key: string]: string | number | boolean | string[] | null;\n    };\n\n    function getStringArrays(\n      prefix: string,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      m: Record<string, any>\n    ): Record<string, string[]> {\n      let ret: Record<string, string[]> = {};\n\n      Object.keys(m).forEach((key) => {\n        const newPrefix = prefix.length > 0 ? `${prefix}.${key}` : key;\n        const val = m[key];\n        if (!val) {\n          // Ignore it\n        } else if (Array.isArray(val)) {\n          // Make sure everything in the array is a string\n          ret[newPrefix] = val.map((v) => `${v}`);\n        } else if (typeof val === \"object\") {\n          const subArrays = getStringArrays(newPrefix, val);\n          ret = { ...ret, ...subArrays };\n        }\n      });\n\n      return ret;\n    }\n\n    const stringArrays: Record<string, string[]> = getStringArrays(\n      \"\",\n      documentMetadata\n    );\n\n    const flatMetadata: metadataType = flatten(documentMetadata);\n    Object.keys(flatMetadata).forEach((key) => {\n      Object.keys(stringArrays).forEach((arrayKey) => {\n        const matchKey = `${arrayKey}.`;\n        if (key.startsWith(matchKey)) {\n          delete flatMetadata[key];\n        }\n      });\n    });\n\n    const metadata: metadataType = {\n      ...flatMetadata,\n      ...stringArrays,\n    };\n    return metadata;\n  }\n\n  /**\n   * Given the metadata from a document, convert it to an array of Restriction\n   * objects that may be passed to the Matching Engine and stored.\n   * The default implementation flattens any metadata and includes it as\n   * an \"allowList\". Subclasses can choose to convert some of these to\n   * \"denyList\" items or to add additional restrictions (for example, to format\n   * dates into a different structure or to add additional restrictions\n   * based on the date).\n   * @param documentMetadata - The metadata from a document\n   * @returns a Restriction[] (or an array of a subclass, from the FilterType)\n   */\n  metadataToRestrictions(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    documentMetadata: Record<string, any>\n  ): this[\"FilterType\"] {\n    const metadata = this.cleanMetadata(documentMetadata);\n\n    const restrictions: this[\"FilterType\"] = [];\n    for (const key of Object.keys(metadata)) {\n      // Make sure the value is an array (or that we'll ignore it)\n      let valArray;\n      const val = metadata[key];\n      if (val === null) {\n        valArray = null;\n      } else if (Array.isArray(val) && val.length > 0) {\n        valArray = val;\n      } else {\n        valArray = [`${val}`];\n      }\n\n      // Add to the restrictions if we do have a valid value\n      if (valArray) {\n        // Determine if this key is for the allowList or denyList\n        // TODO: get which ones should be on the deny list\n        const listType = \"allowList\";\n\n        // Create the restriction\n        const restriction: Restriction = {\n          namespace: key,\n          [listType]: valArray,\n        };\n\n        // Add it to the restriction list\n        restrictions.push(restriction);\n      }\n    }\n    return restrictions;\n  }\n\n  /**\n   * Create an index datapoint for the vector and document id.\n   * If an id does not exist, create it and set the document to its value.\n   * @param vector\n   * @param document\n   */\n  buildDatapoint(vector: number[], document: IdDocument): IndexDatapoint {\n    if (!document.id) {\n      document.id = uuid.v4();\n    }\n    const ret: IndexDatapoint = {\n      datapointId: document.id,\n      featureVector: vector,\n    };\n    const restrictions = this.metadataToRestrictions(document.metadata);\n    if (restrictions?.length > 0) {\n      ret.restricts = restrictions;\n    }\n    return ret;\n  }\n\n  async delete(params: MatchingEngineDeleteParams): Promise<void> {\n    const options = {};\n    await this.removeDatapointClient.request(params.ids, options);\n  }\n\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[Document, number][]> {\n    // Format the query into the request\n    const deployedIndexId = await this.getDeployedIndexId();\n    const requestQuery: FindNeighborsRequestQuery = {\n      neighborCount: k,\n      datapoint: {\n        datapointId: `0`,\n        featureVector: query,\n      },\n    };\n    if (filter) {\n      requestQuery.datapoint.restricts = filter;\n    }\n    const request: FindNeighborsRequest = {\n      deployedIndexId,\n      queries: [requestQuery],\n    };\n\n    // Build the connection.\n    // Has to be done here, since we defer getting the endpoint until\n    // we need it.\n    const apiEndpoint = await this.getPublicAPIEndpoint();\n    const findNeighborsParams: FindNeighborsConnectionParams = {\n      endpoint: apiEndpoint,\n      indexEndpoint: this.indexEndpoint,\n      apiVersion: this.apiVersion,\n      location: this.location,\n      deployedIndexId,\n      authOptions: this.authOptions,\n    };\n    const connection = new FindNeighborsConnection(\n      findNeighborsParams,\n      this.caller\n    );\n\n    // Make the call\n    const options = {};\n    const response = await connection.request(request, options);\n\n    // Get the document for each datapoint id and return them\n    const nearestNeighbors = response?.data?.nearestNeighbors ?? [];\n    const nearestNeighbor = nearestNeighbors[0];\n    const neighbors = nearestNeighbor?.neighbors ?? [];\n    const ret: [Document, number][] = await Promise.all(\n      neighbors.map(async (neighbor) => {\n        const id = neighbor?.datapoint?.datapointId;\n        const distance = neighbor?.distance;\n        let doc: IdDocument;\n        try {\n          doc = await this.docstore.search(id);\n        } catch (xx) {\n          // Documents that are in the index are returned, even if they\n          // are not in the document store, to allow for some way to get\n          // the id so they can be deleted.\n          console.error(xx);\n          console.warn(\n            [\n              `Document with id \"${id}\" is missing from the backing docstore.`,\n              `This can occur if you clear the docstore without deleting from the corresponding Matching Engine index.`,\n              `To resolve this, you should call .delete() with this id as part of the \"ids\" parameter.`,\n            ].join(\"\\n\")\n          );\n          doc = new Document({ pageContent: `Missing document ${id}` });\n        }\n        doc.id ??= id;\n        return [doc, distance];\n      })\n    );\n\n    return ret;\n  }\n\n  /**\n   * For this index endpoint, figure out what API Endpoint URL and deployed\n   * index ID should be used to do upserts and queries.\n   * Also sets the `apiEndpoint` and `deployedIndexId` property for future use.\n   * @return The URL\n   */\n  async determinePublicAPIEndpoint(): Promise<PublicAPIEndpointInfo> {\n    const response: IndexEndpointResponse =\n      await this.indexEndpointClient.request(this.callerOptions);\n\n    // Get the endpoint\n    const publicEndpointDomainName = response?.data?.publicEndpointDomainName;\n    this.apiEndpoint = publicEndpointDomainName;\n\n    // Determine which of the deployed indexes match the index id\n    // and get the deployed index id. The list of deployed index ids\n    // contain the \"index name\" or path, but not the index id by itself,\n    // so we need to extract it from the name\n    const indexPathPattern = /projects\\/.+\\/locations\\/.+\\/indexes\\/(.+)$/;\n    const deployedIndexes = response?.data?.deployedIndexes ?? [];\n    const deployedIndex = deployedIndexes.find((index) => {\n      const deployedIndexPath = index.index;\n      const match = deployedIndexPath.match(indexPathPattern);\n      if (match) {\n        const [, potentialIndexId] = match;\n        if (potentialIndexId === this.index) {\n          return true;\n        }\n      }\n      return false;\n    });\n    if (deployedIndex) {\n      this.deployedIndexId = deployedIndex.id;\n    }\n\n    return {\n      apiEndpoint: this.apiEndpoint,\n      deployedIndexId: this.deployedIndexId,\n    };\n  }\n\n  async getPublicAPIEndpoint(): Promise<string> {\n    return (\n      this.apiEndpoint ?? (await this.determinePublicAPIEndpoint()).apiEndpoint\n    );\n  }\n\n  async getDeployedIndexId(): Promise<string> {\n    return (\n      this.deployedIndexId ??\n      (await this.determinePublicAPIEndpoint()).deployedIndexId\n    );\n  }\n\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig: MatchingEngineArgs\n  ): Promise<VectorStore> {\n    const docs: Document[] = texts.map(\n      (text, index): Document => ({\n        pageContent: text,\n        metadata: Array.isArray(metadatas) ? metadatas[index] : metadatas,\n      })\n    );\n    return this.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig: MatchingEngineArgs\n  ): Promise<VectorStore> {\n    const ret = new MatchingEngine(embeddings, dbConfig);\n    await ret.addDocuments(docs);\n    return ret;\n  }\n}\n"],"mappings":"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"}