{"version":3,"file":"astradb.js","names":[],"sources":["../../src/vectorstores/astradb.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as uuid from \"uuid\";\n\nimport {\n  Collection,\n  DataAPIClient,\n  CreateCollectionOptions,\n  Db,\n  InsertManyError,\n} from \"@datastax/astra-db-ts\";\n\nimport {\n  AsyncCaller,\n  AsyncCallerParams,\n} from \"@langchain/core/utils/async_caller\";\nimport { Document } from \"@langchain/core/documents\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { maximalMarginalRelevance } from \"@langchain/core/utils/math\";\nimport {\n  MaxMarginalRelevanceSearchOptions,\n  VectorStore,\n} from \"@langchain/core/vectorstores\";\n\nexport type CollectionFilter = Record<string, unknown>;\n\nexport interface AstraLibArgs extends AsyncCallerParams {\n  token: string;\n  endpoint: string;\n  collection: string;\n  keyspace?: string;\n  idKey?: string;\n  contentKey?: string;\n  skipCollectionProvisioning?: boolean;\n  collectionOptions?: CreateCollectionOptions<any>;\n  batchSize?: number;\n}\n\nexport type AstraDeleteParams = {\n  ids: string[];\n};\n\nexport class AstraDBVectorStore extends VectorStore {\n  declare FilterType: CollectionFilter;\n\n  private astraDBClient: Db;\n\n  private collectionName: string;\n\n  private collection: Collection | undefined;\n\n  private collectionOptions: CreateCollectionOptions<any> | undefined;\n\n  private readonly idKey: string;\n\n  private readonly contentKey: string; // if undefined the entirety of the content aside from the id and embedding will be stored as content\n\n  caller: AsyncCaller;\n\n  private readonly skipCollectionProvisioning: boolean;\n\n  _vectorstoreType(): string {\n    return \"astradb\";\n  }\n\n  constructor(embeddings: EmbeddingsInterface, args: AstraLibArgs) {\n    super(embeddings, args);\n\n    const {\n      token,\n      endpoint,\n      collection,\n      collectionOptions,\n      keyspace,\n      idKey,\n      contentKey,\n      skipCollectionProvisioning,\n      ...callerArgs\n    } = args;\n    const dataAPIClient = new DataAPIClient(token, { caller: [\"langchainjs\"] });\n    this.astraDBClient = dataAPIClient.db(endpoint, { keyspace });\n    this.skipCollectionProvisioning = skipCollectionProvisioning ?? false;\n    if (this.skipCollectionProvisioning && collectionOptions) {\n      throw new Error(\n        \"If 'skipCollectionProvisioning' has been set to true, 'collectionOptions' must not be defined\"\n      );\n    }\n    this.collectionName = collection;\n    this.collectionOptions =\n      AstraDBVectorStore.applyCollectionOptionsDefaults(collectionOptions);\n    this.idKey = idKey ?? \"_id\";\n    this.contentKey = contentKey ?? \"text\";\n    this.caller = new AsyncCaller(callerArgs);\n\n    if (args.batchSize) {\n      console.warn(\n        \"[WARNING]: `batchSize` is deprecated, and no longer has any effect.\\n`astra-db-ts` > 1.0.0 handles this internally.\"\n      );\n    }\n  }\n\n  private static applyCollectionOptionsDefaults(\n    fromUser?: CreateCollectionOptions<any>\n  ): CreateCollectionOptions<any> {\n    const copy: CreateCollectionOptions<any> = fromUser ? { ...fromUser } : {};\n    if (copy.checkExists === undefined) {\n      copy.checkExists = false;\n    }\n    if (copy.indexing === undefined) {\n      // same default as langchain python AstraDBVectorStore.\n      // this enables to create the collection in python/ts and use it in ts/python with default options.\n      copy.indexing = { allow: [\"metadata\"] };\n    }\n    return copy;\n  }\n\n  /**\n   * Create a new collection in your Astra DB vector database and then connects to it.\n   * If the collection already exists, it will connect to it as well.\n   *\n   * @returns Promise that resolves if connected to the collection.\n   */\n  async initialize(): Promise<void> {\n    if (!this.skipCollectionProvisioning) {\n      await this.astraDBClient.createCollection(\n        this.collectionName,\n        this.collectionOptions\n      );\n    }\n    this.collection = await this.astraDBClient.collection(this.collectionName);\n    console.debug(\"Connected to Astra DB collection\");\n  }\n\n  /**\n   * Method to save vectors to AstraDB.\n   *\n   * @param vectors Vectors to save.\n   * @param documents The documents associated with the vectors.\n   * @returns Promise that resolves when the vectors have been added.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: string[]\n  ) {\n    if (!this.collection) {\n      throw new Error(\"Must connect to a collection before adding vectors\");\n    }\n\n    const docs = vectors.map((embedding, idx) => ({\n      [this.idKey]: options?.[idx] ?? uuid.v4(),\n      [this.contentKey]: documents[idx].pageContent,\n      $vector: embedding,\n      ...documents[idx].metadata,\n    }));\n\n    let insertResults;\n\n    const isInsertManyError = (error: any): error is InsertManyError =>\n      error.name === \"InsertManyError\";\n\n    try {\n      insertResults = await this.collection.insertMany(docs, {\n        ordered: false,\n      });\n    } catch (error) {\n      if (isInsertManyError(error)) {\n        insertResults = error.partialResult;\n      } else {\n        throw error;\n      }\n    }\n\n    const insertedIds = insertResults.insertedIds as string[];\n\n    if (insertedIds.length !== docs.length) {\n      const missingDocs = docs.filter(\n        (doc) => !insertedIds.includes(doc[this.idKey])\n      );\n\n      for (let i = 0; i < missingDocs.length; i += 1) {\n        await this.caller.call(async () => {\n          await this.collection?.replaceOne(\n            { [this.idKey]: missingDocs[i][this.idKey] },\n            missingDocs[i]\n          );\n        });\n      }\n    }\n  }\n\n  /**\n   * Method that adds documents to AstraDB.\n   *\n   * @param documents Array of documents to add to AstraDB.\n   * @param options Optional ids for the documents.\n   * @returns Promise that resolves the documents have been added.\n   */\n  async addDocuments(documents: Document[], options?: string[]) {\n    if (!this.collection) {\n      throw new Error(\"Must connect to a collection before adding vectors\");\n    }\n\n    return this.addVectors(\n      await this.embeddings.embedDocuments(documents.map((d) => d.pageContent)),\n      documents,\n      options\n    );\n  }\n\n  /**\n   * Method that deletes documents from AstraDB.\n   *\n   * @param params AstraDeleteParameters for the delete.\n   * @returns Promise that resolves when the documents have been deleted.\n   */\n  async delete(params: AstraDeleteParams) {\n    if (!this.collection) {\n      throw new Error(\"Must connect to a collection before deleting\");\n    }\n\n    await this.collection.deleteMany({ [this.idKey]: { $in: params.ids } });\n    console.log(`Deleted ${params.ids.length} documents`);\n  }\n\n  /**\n   * Method that performs a similarity search in AstraDB and returns and similarity scores.\n   *\n   * @param query Query vector for the similarity search.\n   * @param k Number of top results to return.\n   * @param filter Optional filter to apply to the search.\n   * @returns Promise that resolves with an array of documents and their scores.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: CollectionFilter\n  ): Promise<[Document, number][]> {\n    if (!this.collection) {\n      throw new Error(\"Must connect to a collection before adding vectors\");\n    }\n\n    const cursor = await this.collection.find(filter ?? {}, {\n      sort: { $vector: query },\n      limit: k,\n      includeSimilarity: true,\n    });\n\n    const results: [Document, number][] = [];\n    for await (const row of cursor) {\n      const {\n        $similarity: similarity,\n        [this.contentKey]: content,\n        ...metadata\n      } = row;\n\n      const doc = new Document({\n        pageContent: content as string,\n        metadata,\n      });\n\n      results.push([doc, similarity as number]);\n    }\n    return results;\n  }\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm.\n   * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {CollectionFilter} options.filter - Optional filter\n   *\n   * @returns {Promise<Document[]>} - List of documents selected by maximal marginal relevance.\n   */\n  async maxMarginalRelevanceSearch(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>\n  ): Promise<Document[]> {\n    if (!this.collection) {\n      throw new Error(\"Must connect to a collection before adding vectors\");\n    }\n\n    const queryEmbedding = await this.embeddings.embedQuery(query);\n\n    const cursor = await this.collection.find(options.filter ?? {}, {\n      sort: { $vector: queryEmbedding },\n      limit: options.k,\n      includeSimilarity: true,\n    });\n\n    const results = (await cursor.toArray()) ?? [];\n    const embeddingList: number[][] = results.map(\n      (row) => row.$vector as number[]\n    );\n\n    const mmrIndexes = maximalMarginalRelevance(\n      queryEmbedding,\n      embeddingList,\n      options.lambda,\n      options.k\n    );\n\n    const topMmrMatches = mmrIndexes.map((idx) => results[idx]);\n\n    const docs: Document[] = [];\n    topMmrMatches.forEach((match) => {\n      const { [this.contentKey]: content, ...metadata } = match;\n\n      const doc: Document = {\n        pageContent: content as string,\n        metadata,\n      };\n\n      docs.push(doc);\n    });\n\n    return docs;\n  }\n\n  /**\n   * Static method to create an instance of AstraDBVectorStore from texts.\n   *\n   * @param texts The texts to use.\n   * @param metadatas The metadata associated with the texts.\n   * @param embeddings The embeddings to use.\n   * @param dbConfig The arguments for the AstraDBVectorStore.\n   * @returns Promise that resolves with a new instance of AstraDBVectorStore.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig: AstraLibArgs\n  ): Promise<AstraDBVectorStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const doc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(doc);\n    }\n    return AstraDBVectorStore.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create an instance of AstraDBVectorStore from documents.\n   *\n   * @param docs The Documents to use.\n   * @param embeddings The embeddings to use.\n   * @param dbConfig The arguments for the AstraDBVectorStore.\n   * @returns Promise that resolves with a new instance of AstraDBVectorStore.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig: AstraLibArgs\n  ): Promise<AstraDBVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n    await instance.initialize();\n\n    await instance.addDocuments(docs);\n    return instance;\n  }\n\n  /**\n   * Static method to create an instance of AstraDBVectorStore from an existing index.\n   *\n   * @param embeddings The embeddings to use.\n   * @param dbConfig The arguments for the AstraDBVectorStore.\n   * @returns Promise that resolves with a new instance of AstraDBVectorStore.\n   */\n  static async fromExistingIndex(\n    embeddings: EmbeddingsInterface,\n    dbConfig: AstraLibArgs\n  ): Promise<AstraDBVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n\n    await instance.initialize();\n    return instance;\n  }\n}\n"],"mappings":"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"}