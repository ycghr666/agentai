{"version":3,"file":"faiss.js","names":[],"sources":["../../src/vectorstores/faiss.ts"],"sourcesContent":["import type { IndexFlatL2 } from \"faiss-node\";\nimport type { NameRegistry, Parser } from \"pickleparser\";\nimport * as uuid from \"uuid\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { SaveableVectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { SynchronousInMemoryDocstore } from \"@langchain/classic/stores/doc/in_memory\";\n\n/**\n * Interface for the arguments required to initialize a FaissStore\n * instance.\n */\nexport interface FaissLibArgs {\n  docstore?: SynchronousInMemoryDocstore;\n  index?: IndexFlatL2;\n  mapping?: Record<number, string>;\n}\n\n/**\n * A class that wraps the FAISS (Facebook AI Similarity Search) vector\n * database for efficient similarity search and clustering of dense\n * vectors.\n */\nexport class FaissStore extends SaveableVectorStore {\n  _index?: IndexFlatL2;\n\n  _mapping: Record<number, string>;\n\n  docstore: SynchronousInMemoryDocstore;\n\n  args: FaissLibArgs;\n\n  _vectorstoreType(): string {\n    return \"faiss\";\n  }\n\n  getMapping(): Record<number, string> {\n    return this._mapping;\n  }\n\n  getDocstore(): SynchronousInMemoryDocstore {\n    return this.docstore;\n  }\n\n  constructor(embeddings: EmbeddingsInterface, args: FaissLibArgs) {\n    super(embeddings, args);\n    this.args = args;\n    this._index = args.index;\n    this._mapping = args.mapping ?? {};\n    this.embeddings = embeddings;\n    this.docstore = args?.docstore ?? new SynchronousInMemoryDocstore();\n  }\n\n  /**\n   * Adds an array of Document objects to the store.\n   * @param documents An array of Document objects.\n   * @returns A Promise that resolves when the documents have been added.\n   */\n  async addDocuments(documents: Document[], options?: { ids?: string[] }) {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n      options\n    );\n  }\n\n  public get index(): IndexFlatL2 {\n    if (!this._index) {\n      throw new Error(\n        \"Vector store not initialised yet. Try calling `fromTexts`, `fromDocuments` or `fromIndex` first.\"\n      );\n    }\n    return this._index;\n  }\n\n  private set index(index: IndexFlatL2) {\n    this._index = index;\n  }\n\n  /**\n   * Adds an array of vectors and their corresponding Document objects to\n   * the store.\n   * @param vectors An array of vectors.\n   * @param documents An array of Document objects corresponding to the vectors.\n   * @returns A Promise that resolves with an array of document IDs when the vectors and documents have been added.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: { ids?: string[] }\n  ) {\n    if (vectors.length === 0) {\n      return [];\n    }\n    if (vectors.length !== documents.length) {\n      throw new Error(`Vectors and documents must have the same length`);\n    }\n    const dv = vectors[0].length;\n    if (!this._index) {\n      const { IndexFlatL2 } = await FaissStore.importFaiss();\n      this._index = new IndexFlatL2(dv);\n    }\n    const d = this.index.getDimension();\n    if (dv !== d) {\n      throw new Error(\n        `Vectors must have the same length as the number of dimensions (${d})`\n      );\n    }\n\n    const docstoreSize = this.index.ntotal();\n    const documentIds = options?.ids ?? documents.map(() => uuid.v4());\n    for (let i = 0; i < vectors.length; i += 1) {\n      const documentId = documentIds[i];\n      const id = docstoreSize + i;\n      this.index.add(vectors[i]);\n      this._mapping[id] = documentId;\n      this.docstore.add({ [documentId]: documents[i] });\n    }\n    return documentIds;\n  }\n\n  /**\n   * Performs a similarity search in the vector store using a query vector\n   * and returns the top k results along with their scores.\n   * @param query A query vector.\n   * @param k The number of top results to return.\n   * @returns A Promise that resolves with an array of tuples, each containing a Document and its corresponding score.\n   */\n  async similaritySearchVectorWithScore(query: number[], k: number) {\n    const d = this.index.getDimension();\n    if (query.length !== d) {\n      throw new Error(\n        `Query vector must have the same length as the number of dimensions (${d})`\n      );\n    }\n    if (k > this.index.ntotal()) {\n      const total = this.index.ntotal();\n      console.warn(\n        `k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`\n      );\n      // eslint-disable-next-line no-param-reassign\n      k = total;\n    }\n    const result = this.index.search(query, k);\n    return result.labels.map((id, index) => {\n      const uuid = this._mapping[id];\n      return [this.docstore.search(uuid), result.distances[index]] as [\n        Document,\n        number,\n      ];\n    });\n  }\n\n  /**\n   * Saves the current state of the FaissStore to a specified directory.\n   * @param directory The directory to save the state to.\n   * @returns A Promise that resolves when the state has been saved.\n   */\n  async save(directory: string) {\n    const fs = await import(\"node:fs/promises\");\n    const path = await import(\"node:path\");\n    await fs.mkdir(directory, { recursive: true });\n    await Promise.all([\n      this.index.write(path.join(directory, \"faiss.index\")),\n      await fs.writeFile(\n        path.join(directory, \"docstore.json\"),\n        JSON.stringify([\n          Array.from(this.docstore._docs.entries()),\n          this._mapping,\n        ])\n      ),\n    ]);\n  }\n\n  /**\n   * Method to delete documents.\n   * @param params Object containing the IDs of the documents to delete.\n   * @returns A promise that resolves when the deletion is complete.\n   */\n  async delete(params: { ids: string[] }) {\n    const documentIds = params.ids;\n    if (documentIds == null) {\n      throw new Error(\"No documentIds provided to delete.\");\n    }\n\n    const mappings = new Map(\n      Object.entries(this._mapping).map(([key, value]) => [\n        parseInt(key, 10),\n        value,\n      ])\n    );\n    const reversedMappings = new Map(\n      Array.from(mappings, (entry) => [entry[1], entry[0]])\n    );\n\n    const missingIds = new Set(\n      documentIds.filter((id) => !reversedMappings.has(id))\n    );\n    if (missingIds.size > 0) {\n      throw new Error(\n        `Some specified documentIds do not exist in the current store. DocumentIds not found: ${Array.from(\n          missingIds\n        ).join(\", \")}`\n      );\n    }\n\n    const indexIdToDelete = documentIds.map((id) => reversedMappings.get(id)!);\n\n    // remove from index\n    this.index.removeIds(indexIdToDelete);\n    // remove from docstore\n    documentIds.forEach((id) => {\n      this.docstore._docs.delete(id);\n    });\n    // remove from mappings\n    indexIdToDelete.forEach((id) => {\n      mappings.delete(id);\n    });\n\n    this._mapping = { ...Array.from(mappings.values()) };\n  }\n\n  /**\n   * Merges the current FaissStore with another FaissStore.\n   * @param targetIndex The FaissStore to merge with.\n   * @returns A Promise that resolves with an array of document IDs when the merge is complete.\n   */\n  async mergeFrom(targetIndex: FaissStore) {\n    const targetIndexDimensions = targetIndex.index.getDimension();\n    if (!this._index) {\n      const { IndexFlatL2 } = await FaissStore.importFaiss();\n      this._index = new IndexFlatL2(targetIndexDimensions);\n    }\n    const d = this.index.getDimension();\n    if (targetIndexDimensions !== d) {\n      throw new Error(\"Cannot merge indexes with different dimensions.\");\n    }\n    const targetMapping = targetIndex.getMapping();\n    const targetDocstore = targetIndex.getDocstore();\n    const targetSize = targetIndex.index.ntotal();\n    const documentIds = [];\n    const currentDocstoreSize = this.index.ntotal();\n    for (let i = 0; i < targetSize; i += 1) {\n      const targetId = targetMapping[i];\n      documentIds.push(targetId);\n      const targetDocument = targetDocstore.search(targetId);\n      const id = currentDocstoreSize + i;\n      this._mapping[id] = targetId;\n      this.docstore.add({ [targetId]: targetDocument });\n    }\n    this.index.mergeFrom(targetIndex.index);\n    return documentIds;\n  }\n\n  /**\n   * Loads a FaissStore from a specified directory.\n   * @param directory The directory to load the FaissStore from.\n   * @param embeddings An Embeddings object.\n   * @returns A Promise that resolves with a new FaissStore instance.\n   */\n  static async load(directory: string, embeddings: EmbeddingsInterface) {\n    const fs = await import(\"node:fs/promises\");\n    const path = await import(\"node:path\");\n    const readStore = (directory: string) =>\n      fs\n        .readFile(path.join(directory, \"docstore.json\"), \"utf8\")\n        .then(JSON.parse) as Promise<\n        [Map<string, Document>, Record<number, string>]\n      >;\n    const readIndex = async (directory: string) => {\n      const { IndexFlatL2 } = await this.importFaiss();\n      return IndexFlatL2.read(path.join(directory, \"faiss.index\"));\n    };\n    const [[docstoreFiles, mapping], index] = await Promise.all([\n      readStore(directory),\n      readIndex(directory),\n    ]);\n    const docstore = new SynchronousInMemoryDocstore(new Map(docstoreFiles));\n    return new this(embeddings, { docstore, index, mapping });\n  }\n\n  static async loadFromPython(\n    directory: string,\n    embeddings: EmbeddingsInterface\n  ) {\n    const fs = await import(\"node:fs/promises\");\n    const path = await import(\"node:path\");\n    const { Parser, NameRegistry } = await this.importPickleparser();\n\n    class PyDocument extends Map {\n      toDocument(): Document {\n        return new Document({\n          pageContent: this.get(\"page_content\"),\n          metadata: this.get(\"metadata\"),\n        });\n      }\n    }\n\n    class PyInMemoryDocstore {\n      _dict: Map<string, PyDocument>;\n\n      toInMemoryDocstore(): SynchronousInMemoryDocstore {\n        const s = new SynchronousInMemoryDocstore();\n        for (const [key, value] of Object.entries(this._dict)) {\n          s._docs.set(key, value.toDocument());\n        }\n        return s;\n      }\n    }\n\n    const readStore = async (directory: string) => {\n      const pkl = await fs.readFile(\n        path.join(directory, \"index.pkl\"),\n        \"binary\"\n      );\n      const buffer = Buffer.from(pkl, \"binary\");\n\n      const registry = new NameRegistry()\n        .register(\n          \"langchain.docstore.in_memory\",\n          \"InMemoryDocstore\",\n          PyInMemoryDocstore\n        )\n        .register(\n          \"langchain_community.docstore.in_memory\",\n          \"InMemoryDocstore\",\n          PyInMemoryDocstore\n        )\n        .register(\"langchain.schema\", \"Document\", PyDocument)\n        .register(\"langchain.docstore.document\", \"Document\", PyDocument)\n        .register(\"langchain.schema.document\", \"Document\", PyDocument)\n        .register(\"langchain_core.documents.base\", \"Document\", PyDocument)\n        .register(\"pathlib\", \"WindowsPath\", (...args) => args.join(\"\\\\\"))\n        .register(\"pathlib\", \"PosixPath\", (...args) => args.join(\"/\"));\n\n      const pickleparser = new Parser({\n        nameResolver: registry,\n      });\n      const [rawStore, mapping] =\n        pickleparser.parse<[PyInMemoryDocstore, Record<number, string>]>(\n          buffer\n        );\n      const store = rawStore.toInMemoryDocstore();\n      return { store, mapping };\n    };\n    const readIndex = async (directory: string) => {\n      const { IndexFlatL2 } = await this.importFaiss();\n      return IndexFlatL2.read(path.join(directory, \"index.faiss\"));\n    };\n    const [store, index] = await Promise.all([\n      readStore(directory),\n      readIndex(directory),\n    ]);\n    return new this(embeddings, {\n      docstore: store.store,\n      index,\n      mapping: store.mapping,\n    });\n  }\n\n  /**\n   * Creates a new FaissStore from an array of texts, their corresponding\n   * metadata, and an Embeddings object.\n   * @param texts An array of texts.\n   * @param metadatas An array of metadata corresponding to the texts, or a single metadata object to be used for all texts.\n   * @param embeddings An Embeddings object.\n   * @param dbConfig An optional configuration object for the document store.\n   * @returns A Promise that resolves with a new FaissStore instance.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig?: {\n      docstore?: SynchronousInMemoryDocstore;\n    }\n  ): Promise<FaissStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return this.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Creates a new FaissStore from an array of Document objects and an\n   * Embeddings object.\n   * @param docs An array of Document objects.\n   * @param embeddings An Embeddings object.\n   * @param dbConfig An optional configuration object for the document store.\n   * @returns A Promise that resolves with a new FaissStore instance.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig?: {\n      docstore?: SynchronousInMemoryDocstore;\n    }\n  ): Promise<FaissStore> {\n    const args: FaissLibArgs = {\n      docstore: dbConfig?.docstore,\n    };\n    const instance = new this(embeddings, args);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n\n  /**\n   * Creates a new FaissStore from an existing FaissStore and an Embeddings\n   * object.\n   * @param targetIndex An existing FaissStore.\n   * @param embeddings An Embeddings object.\n   * @param dbConfig An optional configuration object for the document store.\n   * @returns A Promise that resolves with a new FaissStore instance.\n   */\n  static async fromIndex(\n    targetIndex: FaissStore,\n    embeddings: EmbeddingsInterface,\n    dbConfig?: {\n      docstore?: SynchronousInMemoryDocstore;\n    }\n  ): Promise<FaissStore> {\n    const args: FaissLibArgs = {\n      docstore: dbConfig?.docstore,\n    };\n    const instance = new this(embeddings, args);\n    await instance.mergeFrom(targetIndex);\n    return instance;\n  }\n\n  static async importFaiss(): Promise<{ IndexFlatL2: typeof IndexFlatL2 }> {\n    try {\n      const {\n        default: { IndexFlatL2 },\n      } = await import(\"faiss-node\");\n\n      return { IndexFlatL2 };\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (err: any) {\n      throw new Error(\n        `Could not import faiss-node. Please install faiss-node as a dependency with, e.g. \\`npm install -S faiss-node\\`.\\n\\nError: ${err?.message}`\n      );\n    }\n  }\n\n  static async importPickleparser(): Promise<{\n    Parser: typeof Parser;\n    NameRegistry: typeof NameRegistry;\n  }> {\n    try {\n      const {\n        default: { Parser, NameRegistry },\n      } = await import(\"pickleparser\");\n\n      return { Parser, NameRegistry };\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (err: any) {\n      throw new Error(\n        `Could not import pickleparser. Please install pickleparser as a dependency with, e.g. \\`npm install -S pickleparser\\`.\\n\\nError: ${err?.message}`\n      );\n    }\n  }\n}\n"],"mappings":"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"}