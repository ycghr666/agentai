{"version":3,"file":"vercel_postgres.js","names":[],"sources":["../../src/vectorstores/vercel_postgres.ts"],"sourcesContent":["import {\n  type VercelPool,\n  type VercelPoolClient,\n  type VercelPostgresPoolConfig,\n  createPool,\n} from \"@vercel/postgres\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\n\ntype Metadata = Record<string, string | number | Record<\"in\", string[]>>;\n\n/**\n * Interface that defines the arguments required to create a\n * `VercelPostgres` instance. It includes Postgres connection options,\n * table name, filter, and verbosity level.\n */\nexport interface VercelPostgresFields {\n  pool: VercelPool;\n  client: VercelPoolClient;\n  tableName?: string;\n  columns?: {\n    idColumnName?: string;\n    vectorColumnName?: string;\n    contentColumnName?: string;\n    metadataColumnName?: string;\n  };\n  filter?: Metadata;\n  verbose?: boolean;\n}\n\n/**\n * Class that provides an interface to a Vercel Postgres vector database. It\n * extends the `VectorStore` base class and implements methods for adding\n * documents and vectors and performing similarity searches.\n */\nexport class VercelPostgres extends VectorStore {\n  declare FilterType: Metadata;\n\n  tableName: string;\n\n  idColumnName: string;\n\n  vectorColumnName: string;\n\n  contentColumnName: string;\n\n  metadataColumnName: string;\n\n  filter?: Metadata;\n\n  _verbose?: boolean;\n\n  pool: VercelPool;\n\n  client: VercelPoolClient;\n\n  _vectorstoreType(): string {\n    return \"vercel\";\n  }\n\n  constructor(embeddings: EmbeddingsInterface, config: VercelPostgresFields) {\n    super(embeddings, config);\n    this.tableName = config.tableName ?? \"langchain_vectors\";\n    this.filter = config.filter;\n\n    this.vectorColumnName = config.columns?.vectorColumnName ?? \"embedding\";\n    this.contentColumnName = config.columns?.contentColumnName ?? \"text\";\n    this.idColumnName = config.columns?.idColumnName ?? \"id\";\n    this.metadataColumnName = config.columns?.metadataColumnName ?? \"metadata\";\n\n    this.pool = config.pool;\n    this.client = config.client;\n\n    this._verbose =\n      config.verbose ?? getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\";\n  }\n\n  /**\n   * Static method to create a new `VercelPostgres` instance from a\n   * connection. It creates a table if one does not exist, and calls\n   * `connect` to return a new instance of `VercelPostgres`.\n   *\n   * @param embeddings - Embeddings instance.\n   * @param fields - `VercelPostgres` configuration options.\n   * @returns A new instance of `VercelPostgres`.\n   */\n  static async initialize(\n    embeddings: EmbeddingsInterface,\n    config?: Partial<VercelPostgresFields> & {\n      postgresConnectionOptions?: VercelPostgresPoolConfig;\n    }\n  ): Promise<VercelPostgres> {\n    // Default maxUses to 1 for edge environments:\n    // https://github.com/vercel/storage/tree/main/packages/postgres#a-note-on-edge-environments\n    const pool =\n      config?.pool ??\n      createPool({ maxUses: 1, ...config?.postgresConnectionOptions });\n    const client = config?.client ?? (await pool.connect());\n    const postgresqlVectorStore = new VercelPostgres(embeddings, {\n      ...config,\n      pool,\n      client,\n    });\n\n    await postgresqlVectorStore.ensureTableInDatabase();\n\n    return postgresqlVectorStore;\n  }\n\n  /**\n   * Method to add documents to the vector store. It converts the documents into\n   * vectors, and adds them to the store.\n   *\n   * @param documents - Array of `Document` instances.\n   * @returns Promise that resolves when the documents have been added.\n   */\n  async addDocuments(\n    documents: Document[],\n    options?: { ids?: string[] }\n  ): Promise<string[]> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n      options\n    );\n  }\n\n  /**\n   * Generates the SQL placeholders for a specific row at the provided index.\n   *\n   * @param index - The index of the row for which placeholders need to be generated.\n   * @returns The SQL placeholders for the row values.\n   */\n  protected generatePlaceholderForRowAt(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    row: (string | Record<string, any>)[],\n    index: number\n  ): string {\n    const base = index * row.length;\n    return `(${row.map((_, j) => `$${base + 1 + j}`)})`;\n  }\n\n  /**\n   * Constructs the SQL query for inserting rows into the specified table.\n   *\n   * @param rows - The rows of data to be inserted, consisting of values and records.\n   * @param chunkIndex - The starting index for generating query placeholders based on chunk positioning.\n   * @returns The complete SQL INSERT INTO query string.\n   */\n  protected async runInsertQuery(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    rows: (string | Record<string, any>)[][],\n    useIdColumn: boolean\n  ) {\n    const values = rows.map((row, j) =>\n      this.generatePlaceholderForRowAt(row, j)\n    );\n    const flatValues = rows.flat();\n    return this.client.query(\n      `\n    INSERT INTO ${this.tableName} (\n      ${useIdColumn ? `${this.idColumnName},` : \"\"}\n      ${this.contentColumnName}, \n      ${this.vectorColumnName}, \n      ${this.metadataColumnName}\n    ) VALUES ${values.join(\", \")}\n    ON CONFLICT (${this.idColumnName}) \n    DO UPDATE \n    SET \n    ${this.contentColumnName} = EXCLUDED.${this.contentColumnName},\n    ${this.vectorColumnName} = EXCLUDED.${this.vectorColumnName},\n    ${this.metadataColumnName} = EXCLUDED.${this.metadataColumnName}\n    RETURNING ${this.idColumnName}`,\n      flatValues\n    );\n  }\n\n  /**\n   * Method to add vectors to the vector store. It converts the vectors into\n   * rows and inserts them into the database.\n   *\n   * @param vectors - Array of vectors.\n   * @param documents - Array of `Document` instances.\n   * @returns Promise that resolves when the vectors have been added.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: { ids?: string[] }\n  ): Promise<string[]> {\n    if (options?.ids !== undefined && options?.ids.length !== vectors.length) {\n      throw new Error(\n        `If provided, the length of \"ids\" must be the same as the number of vectors.`\n      );\n    }\n    const rows = vectors.map((embedding, idx) => {\n      const embeddingString = `[${embedding.join(\",\")}]`;\n      const row = [\n        documents[idx].pageContent,\n        embeddingString,\n        documents[idx].metadata,\n      ];\n      if (options?.ids) {\n        return [options.ids[idx], ...row];\n      }\n      return row;\n    });\n\n    const chunkSize = 500;\n\n    const ids = [];\n\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n      try {\n        const result = await this.runInsertQuery(\n          chunk,\n          options?.ids !== undefined\n        );\n        ids.push(...result.rows.map((row) => row[this.idColumnName]));\n      } catch (e) {\n        console.error(e);\n        throw new Error(`Error inserting: ${(e as Error).message}`);\n      }\n    }\n    return ids;\n  }\n\n  /**\n   * Method to perform a similarity search in the vector store. It returns\n   * the `k` most similar documents to the query vector, along with their\n   * similarity scores.\n   *\n   * @param query - Query vector.\n   * @param k - Number of most similar documents to return.\n   * @param filter - Optional filter to apply to the search.\n   * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[Document, number][]> {\n    const embeddingString = `[${query.join(\",\")}]`;\n    const _filter: this[\"FilterType\"] = filter ?? {};\n    const whereClauses = [];\n    const values = [embeddingString, k];\n    let paramCount = values.length;\n\n    for (const [key, value] of Object.entries(_filter)) {\n      if (typeof value === \"object\" && value !== null) {\n        const currentParamCount = paramCount;\n        const placeholders = value.in\n          .map((_, index) => `$${currentParamCount + index + 1}`)\n          .join(\",\");\n        whereClauses.push(\n          `${this.metadataColumnName}->>'${key}' IN (${placeholders})`\n        );\n        values.push(...value.in);\n        paramCount += value.in.length;\n      } else {\n        paramCount += 1;\n        whereClauses.push(\n          `${this.metadataColumnName}->>'${key}' = $${paramCount}`\n        );\n        values.push(value);\n      }\n    }\n\n    const whereClause = whereClauses.length\n      ? `WHERE ${whereClauses.join(\" AND \")}`\n      : \"\";\n\n    const queryString = `\n            SELECT *, ${this.vectorColumnName} <=> $1 as \"_distance\"\n            FROM ${this.tableName}\n            ${whereClause}\n            ORDER BY \"_distance\" ASC\n            LIMIT $2;`;\n\n    const documents = (await this.client.query(queryString, values)).rows;\n    const results = [] as [Document, number][];\n    for (const doc of documents) {\n      if (doc._distance != null && doc[this.contentColumnName] != null) {\n        const document = new Document({\n          pageContent: doc[this.contentColumnName],\n          metadata: doc[this.metadataColumnName],\n        });\n        results.push([document, doc._distance]);\n      }\n    }\n    return results;\n  }\n\n  async delete(params: { ids?: string[]; deleteAll?: boolean }): Promise<void> {\n    if (params.ids !== undefined) {\n      await this.client.query(\n        `DELETE FROM ${this.tableName} WHERE ${\n          this.idColumnName\n        } IN (${params.ids.map((_, idx) => `$${idx + 1}`)})`,\n        params.ids\n      );\n    } else if (params.deleteAll) {\n      await this.client.query(`TRUNCATE TABLE ${this.tableName}`);\n    }\n  }\n\n  /**\n   * Method to ensure the existence of the table in the database. It creates\n   * the table if it does not already exist.\n   *\n   * @returns Promise that resolves when the table has been ensured.\n   */\n  async ensureTableInDatabase(): Promise<void> {\n    await this.client.query(`CREATE EXTENSION IF NOT EXISTS vector;`);\n    await this.client.query(`CREATE TABLE IF NOT EXISTS \"${this.tableName}\" (\n      \"${this.idColumnName}\" uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n      \"${this.contentColumnName}\" text,\n      \"${this.metadataColumnName}\" jsonb,\n      \"${this.vectorColumnName}\" vector\n    );`);\n  }\n\n  /**\n   * Static method to create a new `VercelPostgres` instance from an\n   * array of texts and their metadata. It converts the texts into\n   * `Document` instances and adds them to the store.\n   *\n   * @param texts - Array of texts.\n   * @param metadatas - Array of metadata objects or a single metadata object.\n   * @param embeddings - Embeddings instance.\n   * @param fields - `VercelPostgres` configuration options.\n   * @returns Promise that resolves with a new instance of `VercelPostgres`.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig?: Partial<VercelPostgresFields> & {\n      postgresConnectionOptions?: VercelPostgresPoolConfig;\n    }\n  ): Promise<VercelPostgres> {\n    const docs = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n\n    return this.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create a new `VercelPostgres` instance from an\n   * array of `Document` instances. It adds the documents to the store.\n   *\n   * @param docs - Array of `Document` instances.\n   * @param embeddings - Embeddings instance.\n   * @param fields - `VercelPostgres` configuration options.\n   * @returns Promise that resolves with a new instance of `VercelPostgres`.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig?: Partial<VercelPostgresFields> & {\n      postgresConnectionOptions?: VercelPostgresPoolConfig;\n    }\n  ): Promise<VercelPostgres> {\n    const instance = await this.initialize(embeddings, dbConfig);\n    await instance.addDocuments(docs);\n\n    return instance;\n  }\n\n  /**\n   * Closes all the clients in the pool and terminates the pool.\n   *\n   * @returns Promise that resolves when all clients are closed and the pool is terminated.\n   */\n  async end(): Promise<void> {\n    await this.client?.release();\n    return this.pool.end();\n  }\n}\n"],"mappings":"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"}