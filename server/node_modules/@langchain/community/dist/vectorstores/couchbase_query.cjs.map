{"version":3,"file":"couchbase_query.cjs","names":["VectorStore","Document"],"sources":["../../src/vectorstores/couchbase_query.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable import/no-extraneous-dependencies */\nimport { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Bucket, Cluster, Collection, Scope } from \"couchbase\";\nimport { Document } from \"@langchain/core/documents\";\nimport { v4 as uuid } from \"uuid\";\n\n/**\n * Enum for different distance strategies supported by Couchbase vector search\n */\nexport enum DistanceStrategy {\n  DOT = \"dot\",\n  COSINE = \"cosine\",\n  EUCLIDEAN = \"euclidean\",\n  EUCLIDEAN_SQUARED = \"euclidean_squared\",\n}\n\nexport enum IndexType {\n  COMPOSITE = \"composite\",\n  HYPERSCALE = \"hyperscale\",\n}\n\n/**\n * Interface for create_index method parameters\n */\nexport interface CreateIndexOptions {\n  indexType: IndexType;\n  indexDescription: string;\n  distanceMetric?: DistanceStrategy;\n  indexName?: string;\n  vectorField?: string;\n  vectorDimension?: number;\n  fields?: string[];\n  whereClause?: string;\n  indexScanNprobes?: number;\n  indexTrainlist?: number;\n}\n\n/**\n * This interface define the optional fields for adding vector\n * - `ids` - vector of ids for each document. If undefined, then uuid will be used\n * - `metadata` - vector of metadata object for each document\n */\nexport interface AddVectorOptions {\n  ids?: string[];\n  metadata?: Record<string, any>[];\n}\n\n/**\n * This interface defines the fields required to initialize a query vector store\n * These are the fields part of config:\n * @property {Cluster} cluster - The Couchbase cluster that the store will interact with.\n * @property {string} bucketName - The name of the bucket in the Couchbase cluster.\n * @property {string} scopeName - The name of the scope within the bucket.\n * @property {string} collectionName - The name of the collection within the scope.\n * @property {string} textKey - The key to be used for text in the documents. Defaults to \"text\".\n * @property {string} embeddingKey - The key to be used for embeddings in the documents. Defaults to \"embedding\".\n * @property {DistanceStrategy} distanceStrategy - The distance strategy to use for vector similarity calculations. Defaults to DOT.\n * @property {AddVectorOptions} addVectorOptions - Options for adding vectors with specific id/metadata\n */\nexport interface CouchbaseQueryVectorStoreArgs {\n  cluster: Cluster;\n  bucketName: string;\n  scopeName: string;\n  collectionName: string;\n  textKey?: string;\n  embeddingKey?: string;\n  distanceStrategy?: DistanceStrategy;\n  addVectorOptions?: AddVectorOptions;\n}\n\n/**\n * This type defines the search filters used in couchbase query vector search\n * - `where`: Optional WHERE clause conditions for the SQL++ query\n * - `fields`: Optional list of fields to include in the results\n */\ntype CouchbaseQueryVectorStoreFilter = {\n  where?: string;\n  fields?: string[];\n};\n\n/**\n * Class for interacting with the Couchbase database using Query service for vector search.\n * It extends the VectorStore class and provides methods for adding vectors and\n * documents, and searching for similar vectors using SQL++ queries.\n * Initiate the class using initialize() method.\n */\nexport class CouchbaseQueryVectorStore extends VectorStore {\n  declare FilterType: CouchbaseQueryVectorStoreFilter;\n\n  private metadataKey = \"metadata\";\n\n  private readonly defaultTextKey = \"text\";\n\n  private readonly defaultEmbeddingKey = \"embedding\";\n\n  private readonly defaultDistanceStrategy = DistanceStrategy.DOT;\n\n  private cluster: Cluster;\n\n  private _bucket: Bucket;\n\n  private _scope: Scope;\n\n  private _collection: Collection;\n\n  private bucketName: string;\n\n  private scopeName: string;\n\n  private collectionName: string;\n\n  private textKey = this.defaultTextKey;\n\n  private embeddingKey = this.defaultEmbeddingKey;\n\n  private distanceStrategy = this.defaultDistanceStrategy;\n\n  /**\n   * The private constructor used to provide embedding to parent class.\n   * Initialize the class using static initialize() method\n   * @param embedding - object to generate embedding\n   * @param config -  the fields required to initialize a vector store\n   */\n  private constructor(\n    embedding: EmbeddingsInterface,\n    config: CouchbaseQueryVectorStoreArgs\n  ) {\n    super(embedding, config);\n  }\n\n  _vectorstoreType(): string {\n    return \"couchbase_query\";\n  }\n\n  /**\n   * initialize class for interacting with the Couchbase database using Query service.\n   * It extends the VectorStore class and provides methods\n   * for adding vectors and documents, and searching for similar vectors.\n   * This also verifies the params\n   *\n   * @param embeddings - object to generate embedding\n   * @param config - the fields required to initialize a vector store\n   */\n  static async initialize(\n    embeddings: EmbeddingsInterface,\n    config: CouchbaseQueryVectorStoreArgs\n  ) {\n    const store = new CouchbaseQueryVectorStore(embeddings, config);\n\n    const {\n      cluster,\n      bucketName,\n      scopeName,\n      collectionName,\n      textKey,\n      embeddingKey,\n      distanceStrategy,\n    } = config;\n\n    store.cluster = cluster;\n    store.bucketName = bucketName;\n    store.scopeName = scopeName;\n    store.collectionName = collectionName;\n    if (textKey) {\n      store.textKey = textKey;\n    } else {\n      store.textKey = store.defaultTextKey;\n    }\n\n    if (embeddingKey) {\n      store.embeddingKey = embeddingKey;\n    } else {\n      store.embeddingKey = store.defaultEmbeddingKey;\n    }\n\n    if (distanceStrategy) {\n      store.distanceStrategy = distanceStrategy;\n    } else {\n      store.distanceStrategy = store.defaultDistanceStrategy;\n    }\n\n    try {\n      store._bucket = store.cluster.bucket(store.bucketName);\n      store._scope = store._bucket.scope(store.scopeName);\n      store._collection = store._scope.collection(store.collectionName);\n    } catch (err) {\n      throw new Error(\n        `Error connecting to couchbase, Please check connection and credentials. ${err}`\n      );\n    }\n\n    try {\n      if (\n        !(await store.checkBucketExists()) ||\n        !(await store.checkScopeAndCollectionExists())\n      ) {\n        throw new Error(\"Error while initializing vector store\");\n      }\n    } catch (err) {\n      throw new Error(`Error while initializing vector store: ${err}`);\n    }\n    return store;\n  }\n\n  /**\n   * An asynchronous method to verify the bucket exists.\n   * It retrieves bucket information and checks if the bucket is present.\n   *\n   * @throws - If the specified bucket does not exist in the database.\n   *\n   * @returns - returns promise true if no error is found\n   */\n  private async checkBucketExists(): Promise<boolean> {\n    try {\n      await this.cluster.buckets().getBucket(this.bucketName);\n      return true;\n    } catch (err) {\n      throw new Error(\n        `Bucket with name ${this.bucketName} does not exist. Error: ${err}`\n      );\n    }\n  }\n\n  /**\n   * An asynchronous method to verify the scope and collection exist.\n   * It checks if the specified scope and collection are present.\n   *\n   * @throws - If the specified scope or collection does not exist in the database.\n   *\n   * @returns - returns promise true if no error is found\n   */\n  private async checkScopeAndCollectionExists(): Promise<boolean> {\n    try {\n      const scopes = await this._bucket.collections().getAllScopes();\n      const scope = scopes.find((s: any) => s.name === this.scopeName);\n      if (!scope) {\n        throw new Error(`Scope ${this.scopeName} does not exist`);\n      }\n\n      const collection = scope.collections.find(\n        (c: any) => c.name === this.collectionName\n      );\n      if (!collection) {\n        throw new Error(`Collection ${this.collectionName} does not exist`);\n      }\n\n      return true;\n    } catch (err) {\n      throw new Error(\n        `Scope ${this.scopeName} or Collection ${this.collectionName} does not exist. Error: ${err}`\n      );\n    }\n  }\n\n  /**\n   * Method to add vectors and documents to the vector store.\n   *\n   * @param vectors - Vectors to be added to the vector store.\n   * @param documents - Documents to be added to the vector store.\n   * @param options - Optional parameters for adding vectors.\n   *\n   * @returns - Promise that resolves to an array of document IDs.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: AddVectorOptions\n  ): Promise<string[]> {\n    if (vectors.length === 0) {\n      return [];\n    }\n\n    if (vectors.length !== documents.length) {\n      throw new Error(\"Vectors and documents must have the same length\");\n    }\n\n    const documentIds = options?.ids || documents.map(() => uuid());\n    const documentsToInsert: { [key: string]: any }[] = [];\n\n    for (let index = 0; index < vectors.length; index += 1) {\n      const vector = vectors[index];\n      const document = documents[index];\n      const documentId = documentIds[index];\n\n      const documentToInsert = {\n        [documentId]: {\n          [this.textKey]: document.pageContent,\n          [this.embeddingKey]: vector,\n          [this.metadataKey]: document.metadata,\n        },\n      };\n\n      documentsToInsert.push(documentToInsert);\n    }\n\n    const docIds = await this.upsertDocuments(documentsToInsert);\n    return docIds;\n  }\n\n  /**\n   * Method to add documents to the vector store. It first converts\n   * the documents to vectors using the embeddings and then adds them to the vector store.\n   *\n   * @param documents - Documents to be added to the vector store.\n   * @param options - Optional parameters for adding documents.\n   *\n   * @returns - Promise that resolves to an array of document IDs.\n   */\n  async addDocuments(\n    documents: Document[],\n    options?: AddVectorOptions\n  ): Promise<string[]> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    const vectors = await this.embeddings.embedDocuments(texts);\n    return this.addVectors(vectors, documents, options);\n  }\n\n  /**\n   * Method to delete documents from the vector store.\n   *\n   * @param ids - Array of document IDs to be deleted.\n   *\n   * @returns - Promise that resolves when the deletion is complete.\n   */\n  async delete(options: { ids: string[] }): Promise<void> {\n    const { ids } = options;\n    const deletePromises = ids.map((id) =>\n      this._collection.remove(id).catch((e: any) => {\n        throw new Error(`Delete failed with error: ${e}`);\n      })\n    );\n\n    await Promise.all(deletePromises);\n  }\n\n  /**\n   * Return documents that are most similar to the vector embedding using SQL++ query.\n   *\n   * @param queryEmbeddings - Embedding vector to look up documents similar to.\n   * @param k - Number of documents to return. Defaults to 4.\n   * @param filter - Optional search filter that are passed to Couchbase query. Defaults to empty object.\n   * - `where`: Optional WHERE clause conditions for the SQL++ query\n   * - `fields`: Optional list of fields to include in the results\n   *\n   * @returns - Promise of list of [document, score] that are the most similar to the query vector.\n   *\n   * @throws If the search operation fails.\n   */\n  async similaritySearchVectorWithScore(\n    queryEmbeddings: number[],\n    k = 4,\n    filter: CouchbaseQueryVectorStoreFilter = {}\n  ): Promise<[Document, number][]> {\n    const { where, fields } = filter;\n\n    // Build the SELECT clause\n    let selectClause = `META().id, ${this.textKey}, ${this.metadataKey}`;\n    if (fields && fields.length > 0) {\n      selectClause = fields.join(\", \");\n      if (!fields.includes(this.textKey)) {\n        selectClause += `, ${this.textKey}`;\n      }\n      if (!fields.includes(this.metadataKey)) {\n        selectClause += `, ${this.metadataKey}`;\n      }\n      if (!fields.includes(\"META().id\")) {\n        selectClause += `, META().id`;\n      }\n    }\n\n    // Build the WHERE clause\n    let whereClause = \"\";\n    if (where) {\n      whereClause = `AND ${where}`;\n    }\n\n    // Build the SQL++ query with vector search using APPROX_VECTOR_DISTANCE function\n    // Using the configured distance metric for similarity scoring\n\n    const distanceMetric = this.distanceStrategy;\n    const query = `\n      SELECT ${selectClause},\n             APPROX_VECTOR_DISTANCE(${this.embeddingKey}, [${queryEmbeddings}], \"${distanceMetric}\") as distance\n      FROM \\`${this.bucketName}\\`.\\`${this.scopeName}\\`.\\`${this.collectionName}\\`\n      WHERE ${this.embeddingKey} IS NOT NULL ${whereClause}\n      ORDER BY APPROX_VECTOR_DISTANCE(${this.embeddingKey}, [${queryEmbeddings}], \"${distanceMetric}\")\n      LIMIT ${k}\n    `;\n\n    const docsWithScore: [Document, number][] = [];\n    try {\n      const result = await this.cluster.query(query, {\n        parameters: {\n          queryVector: queryEmbeddings,\n          k,\n        },\n      });\n\n      for (const row of result.rows) {\n        const text = row[this.textKey];\n        const metadata = row[this.metadataKey] || {};\n        // Convert distance to similarity score (lower distance = higher similarity)\n        const distance = row.distance || 0;\n        const doc = new Document({\n          pageContent: text,\n          metadata,\n        });\n        docsWithScore.push([doc, distance]);\n      }\n    } catch (err) {\n      throw new Error(`Query failed with error: ${err}`);\n    }\n    return docsWithScore;\n  }\n\n  /**\n   * Return documents that are most similar to the vector embedding.\n   *\n   * @param queryEmbeddings - Embedding to look up documents similar to.\n   * @param k - The number of similar documents to return. Defaults to 4.\n   * @param filter - Optional search filter that are passed to Couchbase query. Defaults to empty object.\n   * - `where`: Optional WHERE clause conditions for the SQL++ query\n   * - `fields`: Optional list of fields to include in the results\n   *\n   * @returns - A promise that resolves to an array of documents that match the similarity search.\n   */\n  async similaritySearchByVector(\n    queryEmbeddings: number[],\n    k = 4,\n    filter: CouchbaseQueryVectorStoreFilter = {}\n  ): Promise<Document[]> {\n    const docsWithScore = await this.similaritySearchVectorWithScore(\n      queryEmbeddings,\n      k,\n      filter\n    );\n    const docs = [];\n    for (const doc of docsWithScore) {\n      docs.push(doc[0]);\n    }\n    return docs;\n  }\n\n  /**\n   * Return documents that are most similar to the query.\n   *\n   * @param query - Query to look up for similar documents\n   * @param k - The number of similar documents to return. Defaults to 4.\n   * @param filter - Optional search filter that are passed to Couchbase query. Defaults to empty object.\n   * - `where`: Optional WHERE clause conditions for the SQL++ query\n   * - `fields`: Optional list of fields to include in the results\n   *\n   * @returns - Promise of list of documents that are most similar to the query.\n   */\n  async similaritySearch(\n    query: string,\n    k = 4,\n    filter: CouchbaseQueryVectorStoreFilter = {}\n  ): Promise<Document[]> {\n    const queryEmbeddings = await this.embeddings.embedQuery(query);\n    const docsWithScore = await this.similaritySearchVectorWithScore(\n      queryEmbeddings,\n      k,\n      filter\n    );\n    const docs = [];\n    for (const doc of docsWithScore) {\n      docs.push(doc[0]);\n    }\n    return docs;\n  }\n\n  /**\n   * Return documents that are most similar to the query with their scores.\n   *\n   * @param query - Query to look up for similar documents\n   * @param k - The number of similar documents to return. Defaults to 4.\n   * @param filter - Optional search filter that are passed to Couchbase query. Defaults to empty object.\n   * - `where`: Optional WHERE clause conditions for the SQL++ query\n   * - `fields`: Optional list of fields to include in the results\n   *\n   * @returns - Promise of list of documents that are most similar to the query.\n   */\n  async similaritySearchWithScore(\n    query: string,\n    k = 4,\n    filter: CouchbaseQueryVectorStoreFilter = {}\n  ): Promise<[Document, number][]> {\n    const queryEmbeddings = await this.embeddings.embedQuery(query);\n    const docsWithScore = await this.similaritySearchVectorWithScore(\n      queryEmbeddings,\n      k,\n      filter\n    );\n    return docsWithScore;\n  }\n\n  /**\n   * upsert documents asynchronously into a couchbase collection\n   * @param documentsToInsert Documents to be inserted into couchbase collection with embeddings, original text and metadata\n   * @returns DocIds of the inserted documents\n   */\n  private async upsertDocuments(\n    documentsToInsert: {\n      [x: string]: any;\n    }[]\n  ) {\n    // Create promises for each document to be upserted\n    const upsertDocumentsPromises = documentsToInsert.map((document) => {\n      const currentDocumentKey = Object.keys(document)[0];\n      return this._collection\n        .upsert(currentDocumentKey, document[currentDocumentKey])\n        .then(() => currentDocumentKey)\n        .catch((e: any) => {\n          throw new Error(`Upsert failed with error: ${e}`);\n        });\n    });\n\n    // Upsert all documents asynchronously\n    const docIds = await Promise.all(upsertDocumentsPromises);\n    const successfulDocIds: string[] = [];\n    for (const id of docIds) {\n      if (id) {\n        successfulDocIds.push(id);\n      }\n    }\n    return successfulDocIds;\n  }\n\n  /**\n   * Create a new vector index for the Query vector store.\n   *\n   * @param options - Configuration options for creating the index\n   * @param options.indexType - Type of the index (HYPERSCALE or COMPOSITE) to create\n   * @param options.indexDescription - Description of the index like \"IVF,SQ8\"\n   * @param options.distanceMetric - Distance metric to use for the index. Defaults to the distance metric in the constructor\n   * @param options.indexName - Name of the index to create. Defaults to \"langchain_{indexType}_query_index\"\n   * @param options.vectorField - Name of the vector field to use for the index. Defaults to the embedding key in the constructor\n   * @param options.vectorDimension - Dimension of the vector field. If not provided, it will be determined from the embedding object\n   * @param options.fields - List of fields to include in the index. Defaults to the text field in the constructor\n   * @param options.whereClause - Optional where clause to filter the documents to index\n   * @param options.indexScanNprobes - Number of probes to use for the index\n   * @param options.indexTrainlist - Number of training samples to use for the index\n   *\n   * @throws {Error} If index creation fails or invalid parameters are provided\n   */\n  async createIndex(options: CreateIndexOptions): Promise<void> {\n    const {\n      indexType,\n      indexDescription,\n      distanceMetric,\n      indexName,\n      vectorField,\n      vectorDimension,\n      fields,\n      whereClause,\n      indexScanNprobes,\n      indexTrainlist,\n    } = options;\n\n    if (!Object.values(IndexType).includes(indexType)) {\n      throw new Error(\n        `Invalid index type. Got ${indexType}. Expected one of: ${Object.values(\n          IndexType\n        ).join(\", \")}`\n      );\n    }\n\n    if (!indexDescription) {\n      throw new Error(\n        \"Index description is required for creating Vector Query index.\"\n      );\n    }\n\n    const similarityMetric = distanceMetric || this.distanceStrategy;\n    const vectorFieldName = vectorField || this.embeddingKey;\n\n    // Get the vector dimension for the index\n    let vectorDim = vectorDimension;\n    if (!vectorDim) {\n      try {\n        const testEmbedding = await this.embeddings.embedQuery(\n          \"check the size of the vector embeddings\"\n        );\n        vectorDim = testEmbedding.length;\n      } catch (e) {\n        throw new Error(\n          \"Vector dimension is required for creating Query index. \" +\n            \"Unable to determine the dimension from the embedding object. \" +\n            `Error: ${e}`\n        );\n      }\n    }\n\n    // Create the index parameters for the index creation query\n    const indexParams: Record<string, any> = {\n      dimension: vectorDim,\n      similarity: similarityMetric,\n      description: indexDescription,\n    };\n\n    if (indexScanNprobes) {\n      indexParams.scan_nprobes = indexScanNprobes;\n    }\n    if (indexTrainlist) {\n      indexParams.train_list = indexTrainlist;\n    }\n\n    // Add the text field to the fields if empty or if it is not present\n    const includeFields = fields || [this.textKey];\n    if (!includeFields.includes(this.textKey)) {\n      includeFields.push(this.textKey);\n    }\n\n    // Build where clause if provided\n    const whereClauseStr = whereClause ? `WHERE ${whereClause}` : \"\";\n\n    // Convert index params to WITH clause format\n    const withClause = `WITH ${JSON.stringify(indexParams).replace(/\"/g, \"'\")}`;\n\n    let indexQuery: string;\n    let finalIndexName: string;\n\n    if (indexType === IndexType.HYPERSCALE) {\n      finalIndexName = indexName || \"langchain_hyperscale_query_index\";\n      // HYPERSCALE: Specialized vector index with INCLUDE clause for additional fields\n      indexQuery =\n        `CREATE VECTOR INDEX \\`${finalIndexName}\\` ON \\`${this.bucketName}\\`.\\`${this.scopeName}\\`.\\`${this.collectionName}\\` ` +\n        `(\\`${vectorFieldName}\\` VECTOR) INCLUDE (${includeFields\n          .map((f) => `\\`${f}\\``)\n          .join(\", \")}) ` +\n        `${whereClauseStr} USING GSI ${withClause}`;\n    } else if (indexType === IndexType.COMPOSITE) {\n      finalIndexName = indexName || \"langchain_composite_query_index\";\n      // COMPOSITE: General GSI index that includes vector field alongside other fields with VECTOR keyword\n      indexQuery =\n        `CREATE INDEX \\`${finalIndexName}\\` ON \\`${this.bucketName}\\`.\\`${this.scopeName}\\`.\\`${this.collectionName}\\` ` +\n        `(${includeFields\n          .map((f) => `\\`${f}\\``)\n          .join(\", \")}, \\`${vectorFieldName}\\` VECTOR) ` +\n        `${whereClauseStr} USING GSI ${withClause}`;\n    } else {\n      throw new Error(`Unsupported index type: ${indexType}`);\n    }\n\n    try {\n      await this.cluster.query(indexQuery);\n    } catch (e) {\n      if (\n        e &&\n        typeof e === \"object\" &&\n        \"cause\" in e &&\n        e.cause &&\n        typeof e.cause === \"object\" &&\n        \"first_error_message\" in e.cause\n      ) {\n        throw new Error(\n          `Index creation failed with error: ${e.cause.first_error_message}`\n        );\n      }\n      throw new Error(`Index creation failed with error: ${e}`);\n    }\n  }\n\n  /**\n   * Static method to create a new CouchbaseQueryVectorStore from an array of texts.\n   * It first converts the texts to vectors using the embeddings and then creates a new vector store.\n   *\n   * @param texts - Array of texts to be converted to vectors.\n   * @param metadatas - Array of metadata objects corresponding to the texts.\n   * @param embeddings - Embeddings to be used for converting texts to vectors.\n   * @param config - Configuration for the vector store.\n   *\n   * @returns - Promise that resolves to a new CouchbaseQueryVectorStore instance.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    config: CouchbaseQueryVectorStoreArgs\n  ): Promise<CouchbaseQueryVectorStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return CouchbaseQueryVectorStore.fromDocuments(docs, embeddings, config);\n  }\n\n  /**\n   * Static method to create a new CouchbaseQueryVectorStore from an array of documents.\n   * It first converts the documents to vectors using the embeddings and then creates a new vector store.\n   *\n   * @param docs - Array of documents to be converted to vectors.\n   * @param embeddings - Embeddings to be used for converting documents to vectors.\n   * @param config - Configuration for the vector store.\n   *\n   * @returns - Promise that resolves to a new CouchbaseQueryVectorStore instance.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    config: CouchbaseQueryVectorStoreArgs\n  ): Promise<CouchbaseQueryVectorStore> {\n    const instance = await CouchbaseQueryVectorStore.initialize(\n      embeddings,\n      config\n    );\n    await instance.addDocuments(docs);\n    return instance;\n  }\n}\n"],"mappings":"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"}