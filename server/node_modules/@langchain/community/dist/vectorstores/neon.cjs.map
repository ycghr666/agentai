{"version":3,"file":"neon.cjs","names":["VectorStore","Document"],"sources":["../../src/vectorstores/neon.ts"],"sourcesContent":["import { neon } from \"@neondatabase/serverless\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\n\ntype Metadata = Record<string, string | number | Record<\"in\", string[]>>;\n\n/**\n * Interface that defines the arguments required to create a\n * `NeonPostgres` instance. It includes Postgres connection options,\n * table name, filter, and verbosity level.\n */\nexport interface NeonPostgresArgs {\n  connectionString: string;\n  tableName?: string;\n  schemaName?: string;\n  columns?: {\n    idColumnName?: string;\n    vectorColumnName?: string;\n    contentColumnName?: string;\n    metadataColumnName?: string;\n  };\n  filter?: Metadata;\n  verbose?: boolean;\n}\n\n/**\n * Class that provides an interface to a Neon Postgres database. It\n * extends the `VectorStore` base class and implements methods for adding\n * documents and vectors, performing similarity searches, and ensuring the\n * existence of a table in the database.\n */\nexport class NeonPostgres extends VectorStore {\n  declare FilterType: Metadata;\n\n  tableName: string;\n\n  schemaName?: string;\n\n  idColumnName: string;\n\n  vectorColumnName: string;\n\n  contentColumnName: string;\n\n  metadataColumnName: string;\n\n  filter?: Metadata;\n\n  _verbose?: boolean;\n\n  neonConnectionString: string;\n\n  _vectorstoreType(): string {\n    return \"neon-postgres\";\n  }\n\n  constructor(embeddings: EmbeddingsInterface, config: NeonPostgresArgs) {\n    super(embeddings, config);\n    this._verbose =\n      config.verbose ?? getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\";\n\n    this.neonConnectionString = config.connectionString;\n    this.tableName = config.tableName ?? \"vectorstore_documents\";\n    this.schemaName = config.schemaName;\n    this.filter = config.filter;\n\n    this.vectorColumnName = config.columns?.vectorColumnName ?? \"embedding\";\n    this.contentColumnName = config.columns?.contentColumnName ?? \"text\";\n    this.idColumnName = config.columns?.idColumnName ?? \"id\";\n    this.metadataColumnName = config.columns?.metadataColumnName ?? \"metadata\";\n  }\n\n  get computedTableName() {\n    return typeof this.schemaName !== \"string\"\n      ? `${this.tableName}`\n      : `\"${this.schemaName}\".\"${this.tableName}\"`;\n  }\n\n  /**\n   * Static method to create a new `NeonPostgres` instance from a\n   * connection. It creates a table if one does not exist.\n   *\n   * @param embeddings - Embeddings instance.\n   * @param fields - `NeonPostgresArgs` instance.\n   * @returns A new instance of `NeonPostgres`.\n   */\n  static async initialize(\n    embeddings: EmbeddingsInterface,\n    config: NeonPostgresArgs\n  ): Promise<NeonPostgres> {\n    const neonVectorStore = new NeonPostgres(embeddings, config);\n    await neonVectorStore.ensureTableInDatabase();\n    return neonVectorStore;\n  }\n\n  /**\n   * Constructs the SQL query for inserting rows into the specified table.\n   *\n   * @param rows - The rows of data to be inserted, consisting of values and records.\n   * @param chunkIndex - The starting index for generating query placeholders based on chunk positioning.\n   * @returns The complete SQL INSERT INTO query string.\n   */\n  protected async runInsertQuery(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    rows: (string | Record<string, any>)[][],\n    useIdColumn: boolean\n  ) {\n    const placeholders = rows.map((row, index) => {\n      const base = index * row.length;\n      return `(${row.map((_, j) => `$${base + 1 + j}`)})`;\n    });\n    const queryString = `\n    INSERT INTO ${this.computedTableName} (\n        ${useIdColumn ? `${this.idColumnName},` : \"\"}\n        ${this.contentColumnName}, \n        ${this.vectorColumnName}, \n        ${this.metadataColumnName}\n    ) VALUES ${placeholders.join(\", \")}\n    ON CONFLICT (${this.idColumnName}) \n    DO UPDATE \n    SET \n        ${this.contentColumnName} = EXCLUDED.${this.contentColumnName},\n        ${this.vectorColumnName} = EXCLUDED.${this.vectorColumnName},\n        ${this.metadataColumnName} = EXCLUDED.${this.metadataColumnName}\n    RETURNING ${this.idColumnName}\n    `;\n\n    const flatValues = rows.flat();\n    const sql = neon(this.neonConnectionString);\n    return await sql.query(queryString, flatValues);\n  }\n\n  /**\n   * Method to add vectors to the vector store. It converts the vectors into\n   * rows and inserts them into the database.\n   *\n   * @param vectors - Array of vectors.\n   * @param documents - Array of `Document` instances.\n   * @param options - Optional arguments for adding documents\n   * @returns Promise that resolves when the vectors have been added.\n   */\n  async addVectors(\n    vectors: number[][],\n    documents: Document[],\n    options?: { ids?: string[] }\n  ): Promise<string[]> {\n    if (options?.ids !== undefined && options?.ids.length !== vectors.length) {\n      throw new Error(\n        `If provided, the length of \"ids\" must be the same as the number of vectors.`\n      );\n    }\n\n    const rows = vectors.map((embedding, idx) => {\n      const embeddingString = `[${embedding.join(\",\")}]`;\n      const row = [\n        documents[idx].pageContent,\n        embeddingString,\n        documents[idx].metadata,\n      ];\n      if (options?.ids) {\n        return [options.ids[idx], ...row];\n      }\n      return row;\n    });\n\n    const chunkSize = 500;\n    const ids = [];\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n      try {\n        const result = await this.runInsertQuery(\n          chunk,\n          options?.ids !== undefined\n        );\n        ids.push(...result.map((row) => row[this.idColumnName]));\n      } catch (e) {\n        console.error(e);\n        throw new Error(`Error inserting: ${(e as Error).message}`);\n      }\n    }\n    return ids;\n  }\n\n  /**\n   * Method to perform a similarity search in the vector store. It returns\n   * the `k` most similar documents to the query vector, along with their\n   * similarity scores.\n   *\n   * @param query - Query vector.\n   * @param k - Number of most similar documents to return.\n   * @param filter - Optional filter to apply to the search.\n   * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[Document, number][]> {\n    const embeddingString = `[${query.join(\",\")}]`;\n    const _filter: this[\"FilterType\"] = filter ?? {};\n\n    const whereClauses = [];\n    const parameters = [embeddingString, k];\n    let paramCount = parameters.length;\n\n    // The vector to query with, and the num of results are the first\n    // two parameters. The rest of the parameters are the filter values\n    for (const [key, value] of Object.entries(_filter)) {\n      if (typeof value === \"object\" && value !== null) {\n        const currentParamCount = paramCount;\n        const placeholders = value.in\n          .map((_, index) => `$${currentParamCount + index + 1}`)\n          .join(\",\");\n        whereClauses.push(\n          `${this.metadataColumnName}->>'${key}' IN (${placeholders})`\n        );\n        parameters.push(...value.in);\n        paramCount += value.in.length;\n      } else {\n        paramCount += 1;\n        whereClauses.push(\n          `${this.metadataColumnName}->>'${key}' = $${paramCount}`\n        );\n        parameters.push(value);\n      }\n    }\n\n    const whereClause = whereClauses.length\n      ? `WHERE ${whereClauses.join(\" AND \")}`\n      : \"\";\n    const queryString = `\n      SELECT *, ${this.vectorColumnName} <=> $1 as \"_distance\"\n      FROM ${this.computedTableName}\n      ${whereClause}\n      ORDER BY \"_distance\" ASC\n      LIMIT $2;`;\n\n    const sql = neon(this.neonConnectionString);\n    const documents = await sql.query(queryString, parameters);\n\n    const results = [] as [Document, number][];\n    for (const doc of documents) {\n      if (doc._distance != null && doc[this.contentColumnName] != null) {\n        const document = new Document({\n          pageContent: doc[this.contentColumnName],\n          metadata: doc[this.metadataColumnName],\n        });\n        results.push([document, doc._distance]);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Method to add documents to the vector store. It converts the documents into\n   * vectors, and adds them to the store.\n   *\n   * @param documents - Array of `Document` instances.\n   * @param options - Optional arguments for adding documents\n   * @returns Promise that resolves when the documents have been added.\n   */\n  async addDocuments(\n    documents: Document[],\n    options?: { ids?: string[] }\n  ): Promise<string[]> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n      options\n    );\n  }\n\n  /**\n   * Method to delete documents from the vector store. It deletes the\n   * documents that match the provided ids.\n   *\n   * @param ids - Array of document ids.\n   * @param deleteAll - Boolean to delete all documents.\n   * @returns Promise that resolves when the documents have been deleted.\n   */\n  async delete(params: { ids?: string[]; deleteAll?: boolean }): Promise<void> {\n    const sql = neon(this.neonConnectionString);\n\n    if (params.ids !== undefined) {\n      await sql.query(\n        `DELETE FROM ${this.computedTableName} \n        WHERE ${this.idColumnName} \n        IN (${params.ids.map((_, idx) => `$${idx + 1}`)})`,\n        params.ids\n      );\n    } else if (params.deleteAll) {\n      await sql.query(`TRUNCATE TABLE ${this.tableName}`);\n    }\n  }\n\n  /**\n   * Method to ensure the existence of the table to store vectors in\n   * the database. It creates the table if it does not already exist.\n   *\n   * @returns Promise that resolves when the table has been ensured.\n   */\n  async ensureTableInDatabase(): Promise<void> {\n    const sql = neon(this.neonConnectionString);\n\n    await sql`CREATE EXTENSION IF NOT EXISTS vector;`;\n    await sql`CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";`;\n\n    await sql.query(`\n      CREATE TABLE IF NOT EXISTS ${this.computedTableName} (\n        ${this.idColumnName} uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,\n        ${this.contentColumnName} text,\n        ${this.metadataColumnName} jsonb,\n        ${this.vectorColumnName} vector\n      );\n    `);\n  }\n\n  /**\n   * Static method to create a new `NeonPostgres` instance from an\n   * array of texts and their metadata. It converts the texts into\n   * `Document` instances and adds them to the store.\n   *\n   * @param texts - Array of texts.\n   * @param metadatas - Array of metadata objects or a single metadata object.\n   * @param embeddings - Embeddings instance.\n   * @param dbConfig - `NeonPostgresArgs` instance.\n   * @returns Promise that resolves with a new instance of `NeonPostgresArgs`.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig: NeonPostgresArgs\n  ): Promise<NeonPostgres> {\n    const docs = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return this.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create a new `NeonPostgres` instance from an\n   * array of `Document` instances. It adds the documents to the store.\n   *\n   * @param docs - Array of `Document` instances.\n   * @param embeddings - Embeddings instance.\n   * @param dbConfig - `NeonPostgreseArgs` instance.\n   * @returns Promise that resolves with a new instance of `NeonPostgres`.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig: NeonPostgresArgs\n  ): Promise<NeonPostgres> {\n    const instance = await this.initialize(embeddings, dbConfig);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n}\n"],"mappings":"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"}