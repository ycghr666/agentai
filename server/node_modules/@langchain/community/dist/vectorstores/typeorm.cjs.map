{"version":3,"file":"typeorm.cjs","names":["Document","VectorStore","EntitySchema","DataSource"],"sources":["../../src/vectorstores/typeorm.ts"],"sourcesContent":["import { Metadata } from \"@opensearch-project/opensearch/api/types.js\";\nimport { DataSource, DataSourceOptions, EntitySchema } from \"typeorm\";\nimport type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\n\n/**\n * Interface that defines the arguments required to create a\n * `TypeORMVectorStore` instance. It includes Postgres connection options,\n * table name, filter, and verbosity level.\n */\nexport interface TypeORMVectorStoreArgs {\n  postgresConnectionOptions: DataSourceOptions;\n  tableName?: string;\n  schemaName?: string;\n  filter?: Metadata;\n  verbose?: boolean;\n}\n\n/**\n * Class that extends the `Document` base class and adds an `embedding`\n * property. It represents a document in the vector store.\n */\nexport class TypeORMVectorStoreDocument extends Document {\n  embedding: string;\n}\n\nconst defaultDocumentTableName = \"documents\";\n\n/**\n * Class that provides an interface to a Postgres vector database. It\n * extends the `VectorStore` base class and implements methods for adding\n * documents and vectors, performing similarity searches, and ensuring the\n * existence of a table in the database.\n */\nexport class TypeORMVectorStore extends VectorStore {\n  declare FilterType: Metadata;\n\n  tableName: string;\n\n  schemaName?: string;\n\n  documentEntity: EntitySchema;\n\n  filter?: Metadata;\n\n  appDataSource: DataSource;\n\n  _verbose?: boolean;\n\n  _vectorstoreType(): string {\n    return \"typeorm\";\n  }\n\n  private constructor(\n    embeddings: EmbeddingsInterface,\n    fields: TypeORMVectorStoreArgs\n  ) {\n    super(embeddings, fields);\n    this.tableName = fields.tableName || defaultDocumentTableName;\n    this.schemaName = fields.schemaName;\n    this.filter = fields.filter;\n\n    const TypeORMDocumentEntity = new EntitySchema<TypeORMVectorStoreDocument>({\n      name: fields.tableName ?? defaultDocumentTableName,\n      columns: {\n        id: {\n          generated: \"uuid\",\n          type: \"uuid\",\n          primary: true,\n        },\n        pageContent: {\n          type: String,\n        },\n        metadata: {\n          type: \"jsonb\",\n        },\n        embedding: {\n          type: String,\n        },\n      },\n    });\n    const appDataSource = new DataSource({\n      entities: [TypeORMDocumentEntity],\n      ...fields.postgresConnectionOptions,\n    });\n    this.appDataSource = appDataSource;\n    this.documentEntity = TypeORMDocumentEntity;\n\n    this._verbose =\n      fields.verbose ?? getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\";\n  }\n\n  /**\n   * Static method to create a new `TypeORMVectorStore` instance from a\n   * `DataSource`. It initializes the `DataSource` if it is not already\n   * initialized.\n   * @param embeddings Embeddings instance.\n   * @param fields `TypeORMVectorStoreArgs` instance.\n   * @returns A new instance of `TypeORMVectorStore`.\n   */\n  static async fromDataSource(\n    embeddings: EmbeddingsInterface,\n    fields: TypeORMVectorStoreArgs\n  ): Promise<TypeORMVectorStore> {\n    const postgresqlVectorStore = new TypeORMVectorStore(embeddings, fields);\n\n    if (!postgresqlVectorStore.appDataSource.isInitialized) {\n      await postgresqlVectorStore.appDataSource.initialize();\n    }\n\n    return postgresqlVectorStore;\n  }\n\n  /**\n   * Method to add documents to the vector store. It ensures the existence\n   * of the table in the database, converts the documents into vectors, and\n   * adds them to the store.\n   * @param documents Array of `Document` instances.\n   * @returns Promise that resolves when the documents have been added.\n   */\n  async addDocuments(documents: Document[]): Promise<void> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    // This will create the table if it does not exist. We can call it every time as it doesn't\n    // do anything if the table already exists, and it is not expensive in terms of performance\n    await this.ensureTableInDatabase();\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents\n    );\n  }\n\n  /**\n   * Method to add vectors to the vector store. It converts the vectors into\n   * rows and inserts them into the database.\n   * @param vectors Array of vectors.\n   * @param documents Array of `Document` instances.\n   * @returns Promise that resolves when the vectors have been added.\n   */\n  async addVectors(vectors: number[][], documents: Document[]): Promise<void> {\n    const rows = vectors.map((embedding, idx) => {\n      const embeddingString = `[${embedding.join(\",\")}]`;\n      const documentRow = {\n        pageContent: documents[idx].pageContent,\n        embedding: embeddingString,\n        metadata: documents[idx].metadata,\n      };\n\n      return documentRow;\n    });\n\n    const documentRepository = this.appDataSource.getRepository(\n      this.documentEntity\n    );\n\n    const chunkSize = 500;\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n\n      try {\n        await documentRepository.save(chunk);\n      } catch (e) {\n        console.error(e);\n        throw new Error(`Error inserting: ${chunk[0].pageContent}`);\n      }\n    }\n  }\n\n  /**\n   * Method to perform a similarity search in the vector store. It returns\n   * the `k` most similar documents to the query vector, along with their\n   * similarity scores.\n   * @param query Query vector.\n   * @param k Number of most similar documents to return.\n   * @param filter Optional filter to apply to the search.\n   * @returns Promise that resolves with an array of tuples, each containing a `TypeORMVectorStoreDocument` and its similarity score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[TypeORMVectorStoreDocument, number][]> {\n    const embeddingString = `[${query.join(\",\")}]`;\n    const _filter = filter ?? \"{}\";\n\n    const queryString = `\n      SELECT *, embedding <=> $1 as \"_distance\"\n      FROM ${this.tableName}\n      WHERE metadata @> $2\n      ORDER BY \"_distance\" ASC\n      LIMIT $3;`;\n\n    const documents = await this.appDataSource.query(queryString, [\n      embeddingString,\n      _filter,\n      k,\n    ]);\n\n    const results = [] as [TypeORMVectorStoreDocument, number][];\n    for (const doc of documents) {\n      if (doc._distance != null && doc.pageContent != null) {\n        const document = new Document(doc) as TypeORMVectorStoreDocument;\n        document.id = doc.id;\n        results.push([document, doc._distance]);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Method to ensure the existence of the table in the database. It creates\n   * the table if it does not already exist.\n   * @returns Promise that resolves when the table has been ensured.\n   */\n  async ensureTableInDatabase(): Promise<void> {\n    await this.appDataSource.query(\"CREATE EXTENSION IF NOT EXISTS vector;\");\n    await this.appDataSource.query(`\n      CREATE TABLE IF NOT EXISTS ${this.getTablePath()} (\n        \"id\" uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,\n        \"pageContent\" text,\n        metadata jsonb,\n        embedding vector\n      );\n    `);\n  }\n\n  private getTablePath() {\n    if (!this.schemaName) return this.tableName;\n\n    return `\"${this.schemaName}\".\"${this.tableName}\"`;\n  }\n\n  /**\n   * Static method to create a new `TypeORMVectorStore` instance from an\n   * array of texts and their metadata. It converts the texts into\n   * `Document` instances and adds them to the store.\n   * @param texts Array of texts.\n   * @param metadatas Array of metadata objects or a single metadata object.\n   * @param embeddings Embeddings instance.\n   * @param dbConfig `TypeORMVectorStoreArgs` instance.\n   * @returns Promise that resolves with a new instance of `TypeORMVectorStore`.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig: TypeORMVectorStoreArgs\n  ): Promise<TypeORMVectorStore> {\n    const docs = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n\n    return TypeORMVectorStore.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create a new `TypeORMVectorStore` instance from an\n   * array of `Document` instances. It adds the documents to the store.\n   * @param docs Array of `Document` instances.\n   * @param embeddings Embeddings instance.\n   * @param dbConfig `TypeORMVectorStoreArgs` instance.\n   * @returns Promise that resolves with a new instance of `TypeORMVectorStore`.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig: TypeORMVectorStoreArgs\n  ): Promise<TypeORMVectorStore> {\n    const instance = await TypeORMVectorStore.fromDataSource(\n      embeddings,\n      dbConfig\n    );\n    await instance.addDocuments(docs);\n\n    return instance;\n  }\n\n  /**\n   * Static method to create a new `TypeORMVectorStore` instance from an\n   * existing index.\n   * @param embeddings Embeddings instance.\n   * @param dbConfig `TypeORMVectorStoreArgs` instance.\n   * @returns Promise that resolves with a new instance of `TypeORMVectorStore`.\n   */\n  static async fromExistingIndex(\n    embeddings: EmbeddingsInterface,\n    dbConfig: TypeORMVectorStoreArgs\n  ): Promise<TypeORMVectorStore> {\n    const instance = await TypeORMVectorStore.fromDataSource(\n      embeddings,\n      dbConfig\n    );\n    return instance;\n  }\n}\n"],"mappings":"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"}