{"version":3,"file":"chroma.cjs","names":["BaseTranslator","Operators","Comparators"],"sources":["../../src/structured_query/chroma.ts"],"sourcesContent":["import {\n  BaseTranslator,\n  Comparator,\n  Comparators,\n  Comparison,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n  Visitor,\n  isFilterEmpty,\n  castValue,\n} from \"@langchain/core/structured_query\";\nimport { Chroma } from \"../vectorstores/chroma.js\";\n\n/**\n * Specialized translator for the Chroma vector database. It extends the\n * BasicTranslator class and translates internal query language elements\n * to valid filters. The class defines a subset of allowed logical\n * operators and comparators that can be used in the translation process.\n * @example\n * ```typescript\n * const chromaTranslator = new ChromaTranslator();\n * const selfQueryRetriever = new SelfQueryRetriever({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   vectorStore: new Chroma(),\n *   documentContents: \"Brief summary of a movie\",\n *   attributeInfo: [],\n *   structuredQueryTranslator: chromaTranslator,\n * });\n *\n * const relevantDocuments = await selfQueryRetriever.getRelevantDocuments(\n *   \"Which movies are directed by Greta Gerwig?\",\n * );\n * ```\n */\nexport class ChromaTranslator<T extends Chroma> extends BaseTranslator<T> {\n  declare VisitOperationOutput: T[\"FilterType\"];\n\n  declare VisitComparisonOutput: T[\"FilterType\"];\n\n  allowedOperators: Operator[] = [Operators.and, Operators.or];\n\n  allowedComparators: Comparator[] = [\n    Comparators.eq,\n    Comparators.ne,\n    Comparators.gt,\n    Comparators.gte,\n    Comparators.lt,\n    Comparators.lte,\n  ];\n\n  formatFunction(func: Operator | Comparator): string {\n    if (func in Comparators) {\n      if (\n        this.allowedComparators.length > 0 &&\n        this.allowedComparators.indexOf(func as Comparator) === -1\n      ) {\n        throw new Error(\n          `Comparator ${func} not allowed. Allowed comparators: ${this.allowedComparators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else if (func in Operators) {\n      if (\n        this.allowedOperators.length > 0 &&\n        this.allowedOperators.indexOf(func as Operator) === -1\n      ) {\n        throw new Error(\n          `Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else {\n      throw new Error(\"Unknown comparator or operator\");\n    }\n    return `$${func}`;\n  }\n\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const args = operation.args?.map((arg) => arg.accept(this as Visitor));\n    return {\n      [this.formatFunction(operation.operator)]: args,\n    } as this[\"VisitOperationOutput\"];\n  }\n\n  visitComparison(comparison: Comparison): this[\"VisitComparisonOutput\"] {\n    return {\n      [comparison.attribute]: {\n        [this.formatFunction(comparison.comparator)]: castValue(\n          comparison.value\n        ),\n      },\n    } as this[\"VisitComparisonOutput\"];\n  }\n\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    let nextArg = {} as this[\"VisitStructuredQueryOutput\"];\n    if (query.filter) {\n      nextArg = {\n        filter: query.filter.accept(this as Visitor),\n      } as this[\"VisitStructuredQueryOutput\"];\n    }\n    return nextArg;\n  }\n\n  mergeFilters(\n    defaultFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    generatedFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    mergeType: \"and\" | \"or\" | \"replace\" = \"and\",\n    forceDefaultFilter = false\n  ): this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (forceDefaultFilter) {\n        return defaultFilter;\n      }\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n    if (mergeType === \"and\") {\n      return {\n        $and: [defaultFilter, generatedFilter],\n      } as this[\"VisitStructuredQueryOutput\"][\"filter\"];\n    } else if (mergeType === \"or\") {\n      return {\n        $or: [defaultFilter, generatedFilter],\n      } as this[\"VisitStructuredQueryOutput\"][\"filter\"];\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,IAAa,mBAAb,cAAwDA,gDAAkB;CAKxE,mBAA+B,CAACC,2CAAU,KAAKA,2CAAU,GAAG;CAE5D,qBAAmC;EACjCC,6CAAY;EACZA,6CAAY;EACZA,6CAAY;EACZA,6CAAY;EACZA,6CAAY;EACZA,6CAAY;EACb;CAED,eAAe,MAAqC;AAClD,MAAI,QAAQA,8CACV;OACE,KAAK,mBAAmB,SAAS,KACjC,KAAK,mBAAmB,QAAQ,KAAmB,KAAK,GAExD,OAAM,IAAI,MACR,cAAc,KAAK,qCAAqC,KAAK,mBAAmB,KAC9E,KACD,GACF;aAEM,QAAQD,4CACjB;OACE,KAAK,iBAAiB,SAAS,KAC/B,KAAK,iBAAiB,QAAQ,KAAiB,KAAK,GAEpD,OAAM,IAAI,MACR,YAAY,KAAK,mCAAmC,KAAK,iBAAiB,KACxE,KACD,GACF;QAGH,OAAM,IAAI,MAAM,iCAAiC;AAEnD,SAAO,IAAI;;CAGb,eAAe,WAAoD;EACjE,MAAM,OAAO,UAAU,MAAM,KAAK,QAAQ,IAAI,OAAO,KAAgB,CAAC;AACtE,SAAO,GACJ,KAAK,eAAe,UAAU,SAAS,GAAG,MAC5C;;CAGH,gBAAgB,YAAuD;AACrE,SAAO,GACJ,WAAW,YAAY,GACrB,KAAK,eAAe,WAAW,WAAW,mDACzC,WAAW,MACZ,EACF,EACF;;CAGH,qBACE,OACoC;EACpC,IAAI,UAAU,EAAE;AAChB,MAAI,MAAM,OACR,WAAU,EACR,QAAQ,MAAM,OAAO,OAAO,KAAgB,EAC7C;AAEH,SAAO;;CAGT,aACE,eACA,iBACA,YAAsC,OACtC,qBAAqB,OACqC;AAC1D,0DAAkB,cAAc,wDAAkB,gBAAgB,CAChE;AAEF,0DAAkB,cAAc,IAAI,cAAc,WAAW;AAC3D,2DAAkB,gBAAgB,CAChC;AAEF,UAAO;;AAET,0DAAkB,gBAAgB,EAAE;AAClC,OAAI,mBACF,QAAO;AAET,OAAI,cAAc,MAChB;AAEF,UAAO;;AAET,MAAI,cAAc,MAChB,QAAO,EACL,MAAM,CAAC,eAAe,gBAAgB,EACvC;WACQ,cAAc,KACvB,QAAO,EACL,KAAK,CAAC,eAAe,gBAAgB,EACtC;MAED,OAAM,IAAI,MAAM,qBAAqB"}