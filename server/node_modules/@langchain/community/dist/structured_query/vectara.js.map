{"version":3,"file":"vectara.js","names":[],"sources":["../../src/structured_query/vectara.ts"],"sourcesContent":["import {\n  BaseTranslator,\n  isFilterEmpty,\n  Comparator,\n  Comparators,\n  Comparison,\n  NOT,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n  Visitor,\n} from \"@langchain/core/structured_query\";\nimport { VectaraFilter, VectaraStore } from \"../vectorstores/vectara.js\";\n\ntype AllowedOperator = Exclude<Operator, NOT>;\n\nexport type VectaraVisitorResult =\n  | VectaraOperationResult\n  | VectaraComparisonResult\n  | VectaraVisitorStructuredQueryResult;\nexport type VectaraOperationResult = String;\nexport type VectaraComparisonResult = String;\nexport type VectaraVisitorStructuredQueryResult = {\n  filter?: { filter?: VectaraOperationResult | VectaraComparisonResult };\n};\n\ntype Value = number | string;\nfunction processValue(value: Value): string {\n  /** Convert a value to a string and add single quotes if it is a string. */\n  if (typeof value === \"string\") {\n    return `'${value}'`;\n  } else {\n    return String(value);\n  }\n}\n\nexport class VectaraTranslator<\n  T extends VectaraStore,\n> extends BaseTranslator<T> {\n  declare VisitOperationOutput: VectaraOperationResult;\n\n  declare VisitComparisonOutput: VectaraComparisonResult;\n\n  allowedOperators: Operator[] = [Operators.and, Operators.or];\n\n  allowedComparators: Comparator[] = [\n    Comparators.eq,\n    Comparators.ne,\n    Comparators.lt,\n    Comparators.lte,\n    Comparators.gt,\n    Comparators.gte,\n  ];\n\n  formatFunction(func: Operator | Comparator): string {\n    if (func in Comparators) {\n      if (\n        this.allowedComparators.length > 0 &&\n        this.allowedComparators.indexOf(func as Comparator) === -1\n      ) {\n        throw new Error(\n          `Comparator ${func} not allowed. Allowed operators: ${this.allowedComparators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else if (func in Operators) {\n      if (\n        this.allowedOperators.length > 0 &&\n        this.allowedOperators.indexOf(func as Operator) === -1\n      ) {\n        throw new Error(\n          `Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else {\n      throw new Error(\"Unknown comparator or operator\");\n    }\n\n    const mapDict = {\n      and: \" and \",\n      or: \" or \",\n      eq: \"=\",\n      ne: \"!=\",\n      lt: \"<\",\n      lte: \"<=\",\n      gt: \">\",\n      gte: \">=\",\n    };\n    return mapDict[func as Comparator | AllowedOperator];\n  }\n\n  /**\n   * Visits an operation and returns a VectaraOperationResult. The\n   * operation's arguments are visited and the operator is formatted.\n   * @param operation The operation to visit.\n   * @returns A VectaraOperationResult.\n   */\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const args = operation.args?.map((arg) =>\n      arg.accept(this as Visitor)\n    ) as VectaraVisitorResult[];\n    const operator = this.formatFunction(operation.operator);\n    return `( ${args.join(operator)} )`;\n  }\n\n  /**\n   * Visits a comparison and returns a VectaraComparisonResult. The\n   * comparison's value is checked for type and the comparator is formatted.\n   * Throws an error if the value type is not supported.\n   * @param comparison The comparison to visit.\n   * @returns A VectaraComparisonResult.\n   */\n  visitComparison(comparison: Comparison): this[\"VisitComparisonOutput\"] {\n    const comparator = this.formatFunction(comparison.comparator);\n    return `( doc.${comparison.attribute} ${comparator} ${processValue(\n      comparison.value\n    )} )`;\n  }\n\n  /**\n   * Visits a structured query and returns a VectaraStructuredQueryResult.\n   * If the query has a filter, it is visited.\n   * @param query The structured query to visit.\n   * @returns A VectaraStructuredQueryResult.\n   */\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    let nextArg = {};\n    if (query.filter) {\n      nextArg = {\n        filter: { filter: query.filter.accept(this as Visitor) },\n      };\n    }\n    return nextArg;\n  }\n\n  mergeFilters(\n    defaultFilter: VectaraFilter | undefined,\n    generatedFilter: VectaraFilter | undefined,\n    mergeType = \"and\",\n    forceDefaultFilter = false\n  ): VectaraFilter | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (forceDefaultFilter) {\n        return defaultFilter;\n      }\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n\n    if (mergeType === \"and\") {\n      return {\n        filter: `${defaultFilter} and ${generatedFilter}`,\n      } as VectaraFilter;\n    } else if (mergeType === \"or\") {\n      return {\n        filter: `${defaultFilter} or ${generatedFilter}`,\n      };\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n"],"mappings":";;;;;AA4BA,SAAS,aAAa,OAAsB;;AAE1C,KAAI,OAAO,UAAU,SACnB,QAAO,IAAI,MAAM;KAEjB,QAAO,OAAO,MAAM;;AAIxB,IAAa,oBAAb,cAEU,eAAkB;CAK1B,mBAA+B,CAAC,UAAU,KAAK,UAAU,GAAG;CAE5D,qBAAmC;EACjC,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,YAAY;EACZ,YAAY;EACb;CAED,eAAe,MAAqC;AAClD,MAAI,QAAQ,aACV;OACE,KAAK,mBAAmB,SAAS,KACjC,KAAK,mBAAmB,QAAQ,KAAmB,KAAK,GAExD,OAAM,IAAI,MACR,cAAc,KAAK,mCAAmC,KAAK,mBAAmB,KAC5E,KACD,GACF;aAEM,QAAQ,WACjB;OACE,KAAK,iBAAiB,SAAS,KAC/B,KAAK,iBAAiB,QAAQ,KAAiB,KAAK,GAEpD,OAAM,IAAI,MACR,YAAY,KAAK,mCAAmC,KAAK,iBAAiB,KACxE,KACD,GACF;QAGH,OAAM,IAAI,MAAM,iCAAiC;AAanD,SAVgB;GACd,KAAK;GACL,IAAI;GACJ,IAAI;GACJ,IAAI;GACJ,IAAI;GACJ,KAAK;GACL,IAAI;GACJ,KAAK;GACN,CACc;;;;;;;;CASjB,eAAe,WAAoD;EACjE,MAAM,OAAO,UAAU,MAAM,KAAK,QAChC,IAAI,OAAO,KAAgB,CAC5B;EACD,MAAM,WAAW,KAAK,eAAe,UAAU,SAAS;AACxD,SAAO,KAAK,KAAK,KAAK,SAAS,CAAC;;;;;;;;;CAUlC,gBAAgB,YAAuD;EACrE,MAAM,aAAa,KAAK,eAAe,WAAW,WAAW;AAC7D,SAAO,SAAS,WAAW,UAAU,GAAG,WAAW,GAAG,aACpD,WAAW,MACZ,CAAC;;;;;;;;CASJ,qBACE,OACoC;EACpC,IAAI,UAAU,EAAE;AAChB,MAAI,MAAM,OACR,WAAU,EACR,QAAQ,EAAE,QAAQ,MAAM,OAAO,OAAO,KAAgB,EAAE,EACzD;AAEH,SAAO;;CAGT,aACE,eACA,iBACA,YAAY,OACZ,qBAAqB,OACM;AAC3B,MAAI,cAAc,cAAc,IAAI,cAAc,gBAAgB,CAChE;AAEF,MAAI,cAAc,cAAc,IAAI,cAAc,WAAW;AAC3D,OAAI,cAAc,gBAAgB,CAChC;AAEF,UAAO;;AAET,MAAI,cAAc,gBAAgB,EAAE;AAClC,OAAI,mBACF,QAAO;AAET,OAAI,cAAc,MAChB;AAEF,UAAO;;AAGT,MAAI,cAAc,MAChB,QAAO,EACL,QAAQ,GAAG,cAAc,OAAO,mBACjC;WACQ,cAAc,KACvB,QAAO,EACL,QAAQ,GAAG,cAAc,MAAM,mBAChC;MAED,OAAM,IAAI,MAAM,qBAAqB"}