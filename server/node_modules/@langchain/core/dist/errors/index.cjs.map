{"version":3,"file":"index.cjs","names":["baseNs"],"sources":["../../src/errors/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { AIMessageChunk } from \"../messages/ai.js\";\nimport { ns as baseNs } from \"../utils/namespace.js\";\n\nexport type LangChainErrorCodes =\n  | \"CONTEXT_OVERFLOW\"\n  | \"INVALID_PROMPT_INPUT\"\n  | \"INVALID_TOOL_RESULTS\"\n  | \"MESSAGE_COERCION_FAILURE\"\n  | \"MODEL_AUTHENTICATION\"\n  | \"MODEL_NOT_FOUND\"\n  | \"MODEL_RATE_LIMIT\"\n  | \"OUTPUT_PARSING_FAILURE\"\n  | \"MODEL_ABORTED\";\n\n/** @deprecated Subclass LangChainError instead */\nexport function addLangChainErrorFields(\n  error: any,\n  lc_error_code: LangChainErrorCodes\n) {\n  (error as any).lc_error_code = lc_error_code;\n  error.message = `${error.message}\\n\\nTroubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${lc_error_code}/\\n`;\n  return error;\n}\n\n/** The error namespace for all LangChain errors */\nexport const ns = baseNs.sub(\"error\");\n\n/**\n * Base error class for all LangChain errors.\n *\n * All LangChain error classes should extend this class (directly or\n * indirectly). Use `LangChainError.isInstance(obj)` to check if an\n * object is any LangChain error.\n *\n * @example\n * ```typescript\n * try {\n *   await model.invoke(\"hello\");\n * } catch (error) {\n *   if (LangChainError.isInstance(error)) {\n *     console.log(\"Got a LangChain error:\", error.message);\n *   }\n * }\n * ```\n */\nexport class LangChainError extends ns.brand(Error) {\n  readonly name: string = \"LangChainError\";\n\n  constructor(message?: string) {\n    super(message);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\n/**\n * Error class representing an aborted model operation in LangChain.\n *\n * This error is thrown when a model operation (such as invocation, streaming, or batching)\n * is cancelled before it completes, commonly due to a user-initiated abort signal\n * (e.g., via an AbortController) or an upstream cancellation event.\n *\n * The ModelAbortError provides access to any partial output the model may have produced\n * before the operation was interrupted, which can be useful for resuming work, debugging,\n * or presenting incomplete results to users.\n *\n * @remarks\n * - The `partialOutput` field includes message content that was generated prior to the abort,\n *   such as a partial AIMessageChunk.\n * - This error extends the {@link LangChainError} base class with the marker `\"model-abort\"`.\n *\n * @example\n * ```typescript\n * try {\n *   await model.invoke(input, { signal: abortController.signal });\n * } catch (err) {\n *   if (ModelAbortError.isInstance(err)) {\n *     // Handle user cancellation, check err.partialOutput if needed\n *   } else {\n *     throw err;\n *   }\n * }\n * ```\n */\nexport class ModelAbortError extends ns.brand(LangChainError, \"model-abort\") {\n  readonly name = \"ModelAbortError\";\n\n  /**\n   * The partial message output that was produced before the operation was aborted.\n   * This is typically an AIMessageChunk, or could be undefined if no output was available.\n   */\n  readonly partialOutput?: AIMessageChunk;\n\n  /**\n   * Constructs a new ModelAbortError instance.\n   *\n   * @param message - A human-readable message describing the abort event.\n   * @param partialOutput - Any partial model output generated before the abort (optional).\n   */\n  constructor(message: string, partialOutput?: AIMessageChunk) {\n    super(message);\n    this.partialOutput = partialOutput;\n  }\n}\n\n/**\n * Error class representing a context window overflow in a language model operation.\n *\n * This error is thrown when the combined input to a language model (such as prompt tokens,\n * historical messages, and/or instructions) exceeds the maximum context window or token limit\n * that the model can process in a single request. Most models have defined upper limits for the number of\n * tokens or characters allowed in a context, and exceeding this limit will prevent\n * the operation from proceeding.\n *\n * The {@link ContextOverflowError} extends the {@link LangChainError} base class with\n * the marker `\"context-overflow\"`.\n *\n * @remarks\n * - Use this error to programmatically identify cases where a user request, prompt, or input\n *   sequence is too long to be handled by the target model.\n * - Model providers and framework integrations should throw this error if they detect\n *   a request cannot be processed due to its size.\n *\n * @example\n * ```typescript\n * try {\n *   await model.invoke(veryLongInput);\n * } catch (err) {\n *   if (ContextOverflowError.isInstance(err)) {\n *     // Handle overflow, e.g., prompt user to shorten input or truncate text\n *     console.warn(\"Model context overflow:\", err.message);\n *   } else {\n *     throw err;\n *   }\n * }\n * ```\n */\nexport class ContextOverflowError extends ns.brand(\n  LangChainError,\n  \"context-overflow\"\n) {\n  readonly name = \"ContextOverflowError\";\n\n  /**\n   * The underlying error that caused this {@link ContextOverflowError}, if any.\n   *\n   * This property is optionally set when wrapping a lower-level error using {@link ContextOverflowError.fromError}.\n   * It allows error handlers to access or inspect the original error that led to the context overflow.\n   */\n  cause?: Error;\n\n  constructor(message?: string) {\n    super(message ?? \"Input exceeded the model's context window.\");\n  }\n\n  /**\n   * Creates a new {@link ContextOverflowError} instance from an existing error.\n   *\n   * This static utility copies the message from the provided error and\n   * attaches the original error as the {@link ContextOverflowError.cause} property,\n   * enabling error handlers to inspect or propagate the original failure.\n   *\n   * @param obj - The original error object causing the context overflow.\n   * @returns A new {@link ContextOverflowError} instance with the original error set as its cause.\n   *\n   * @example\n   * ```typescript\n   * try {\n   *   await model.invoke(input);\n   * } catch (err) {\n   *   throw ContextOverflowError.fromError(err);\n   * }\n   * ```\n   */\n  static fromError(obj: Error): ContextOverflowError {\n    const error = new ContextOverflowError(obj.message);\n    error.cause = obj;\n    return error;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;AAiBA,SAAgB,wBACd,OACA,eACA;AACA,CAAC,MAAc,gBAAgB;AAC/B,OAAM,UAAU,GAAG,MAAM,QAAQ,sFAAsF,cAAc;AACrI,QAAO;;;AAIT,MAAa,KAAKA,qBAAO,IAAI,QAAQ;;;;;;;;;;;;;;;;;;;AAoBrC,IAAa,iBAAb,cAAoC,GAAG,MAAM,MAAM,CAAC;CAClD,AAAS,OAAe;CAExB,YAAY,SAAkB;AAC5B,QAAM,QAAQ;AACd,MAAI,MAAM,kBACR,OAAM,kBAAkB,MAAM,KAAK,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCrD,IAAa,kBAAb,cAAqC,GAAG,MAAM,gBAAgB,cAAc,CAAC;CAC3E,AAAS,OAAO;;;;;CAMhB,AAAS;;;;;;;CAQT,YAAY,SAAiB,eAAgC;AAC3D,QAAM,QAAQ;AACd,OAAK,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCzB,IAAa,uBAAb,MAAa,6BAA6B,GAAG,MAC3C,gBACA,mBACD,CAAC;CACA,AAAS,OAAO;;;;;;;CAQhB;CAEA,YAAY,SAAkB;AAC5B,QAAM,WAAW,6CAA6C;;;;;;;;;;;;;;;;;;;;;CAsBhE,OAAO,UAAU,KAAkC;EACjD,MAAM,QAAQ,IAAI,qBAAqB,IAAI,QAAQ;AACnD,QAAM,QAAQ;AACd,SAAO"}