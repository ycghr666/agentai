{"version":3,"file":"base.cjs","names":["RunTree","getRuntimeEnvironment","BaseCallbackHandler"],"sources":["../../src/tracers/base.ts"],"sourcesContent":["import { KVMap, BaseRun } from \"langsmith/schemas\";\nimport { RunTree, convertToDottedOrderFormat } from \"langsmith/run_trees\";\n\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { LLMResult } from \"../outputs.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  HandleLLMNewTokenCallbackFields,\n  NewTokenIndices,\n} from \"../callbacks/base.js\";\nimport type { Document } from \"../documents/document.js\";\nimport { getRuntimeEnvironment } from \"../utils/env.js\";\n\nexport type RunType = string;\n\n// TODO: Remove this type and just use the base LangSmith Run type.\nexport interface Run extends BaseRun {\n  // some optional fields are always present here\n  id: string;\n  start_time: number;\n  end_time?: number;\n  execution_order: number;\n  // some additional fields that don't exist in sdk runs\n  child_runs: this[];\n  child_execution_order: number;\n  events: Array<{\n    name: string;\n    time: string;\n    kwargs?: Record<string, unknown>;\n  }>;\n  trace_id?: string;\n  dotted_order?: string;\n  /** @internal */\n  _serialized_start_time?: string;\n}\n\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree?: RunTree): Run | undefined => {\n  if (!runTree) {\n    return undefined;\n  }\n  // Important that we return the raw run tree object since the reference\n  // is mutated in other places.\n  // TODO: Remove places where this is being done.\n\n  runTree.events = runTree.events ?? [];\n  runTree.child_runs = runTree.child_runs ?? [];\n  // TODO: Remove this cast and just use the LangSmith RunTree type.\n  return runTree as unknown as Run;\n};\n\nfunction convertRunToRunTree(run?: Run, parentRun?: Run): RunTree | undefined {\n  if (!run) {\n    return undefined;\n  }\n  return new RunTree({\n    ...run,\n    start_time: run._serialized_start_time ?? run.start_time,\n    parent_run: convertRunToRunTree(parentRun),\n    child_runs: run.child_runs\n      .map((r) => convertRunToRunTree(r))\n      .filter((r): r is RunTree => r !== undefined),\n    extra: {\n      ...run.extra,\n      runtime: getRuntimeEnvironment(),\n    },\n    tracingEnabled: false,\n  });\n}\n\nexport interface AgentRun extends Run {\n  actions: AgentAction[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value: any, defaultKey: string) {\n  return value && !Array.isArray(value) && typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport function isBaseTracer(x: BaseCallbackHandler): x is BaseTracer {\n  return typeof (x as BaseTracer)._addRunToRunMap === \"function\";\n}\n\nexport abstract class BaseTracer extends BaseCallbackHandler {\n  /** @deprecated Use `runTreeMap` instead. */\n  protected runMap: Map<string, Run> = new Map();\n\n  protected runTreeMap: Map<string, RunTree> = new Map();\n\n  protected usesRunTreeMap = false;\n\n  constructor(_fields?: BaseCallbackHandlerInput) {\n    super(...arguments);\n  }\n\n  copy(): this {\n    return this;\n  }\n\n  protected getRunById(runId?: string): Run | undefined {\n    if (runId === undefined) {\n      return undefined;\n    }\n    return this.usesRunTreeMap\n      ? convertRunTreeToRun(this.runTreeMap.get(runId))\n      : this.runMap.get(runId);\n  }\n\n  protected stringifyError(error: unknown) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (error instanceof Error) {\n      return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n    }\n\n    if (typeof error === \"string\") {\n      return error;\n    }\n\n    return `${error}`;\n  }\n\n  protected abstract persistRun(run: Run): Promise<void>;\n\n  protected _addChildRun(parentRun: Run, childRun: Run) {\n    parentRun.child_runs.push(childRun);\n  }\n\n  _addRunToRunMap(run: Run) {\n    const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } =\n      convertToDottedOrderFormat(\n        new Date(run.start_time).getTime(),\n        run.id,\n        run.execution_order\n      );\n    const storedRun = { ...run };\n    const parentRun = this.getRunById(storedRun.parent_run_id);\n    if (storedRun.parent_run_id !== undefined) {\n      if (parentRun) {\n        this._addChildRun(parentRun, storedRun);\n        parentRun.child_execution_order = Math.max(\n          parentRun.child_execution_order,\n          storedRun.child_execution_order\n        );\n        storedRun.trace_id = parentRun.trace_id;\n        if (parentRun.dotted_order !== undefined) {\n          storedRun.dotted_order = [\n            parentRun.dotted_order,\n            currentDottedOrder,\n          ].join(\".\");\n          storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        } else {\n          // This can happen naturally for callbacks added within a run\n          // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n        }\n      } else {\n        // This can happen naturally for callbacks added within a run\n        // console.debug(\n        //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n        // );\n\n        // Child run with no trace_id and dotted_order causes 400 error on LangSmith.\n        // So we set the parent_run_id to undefined as a workaround.\n        // This run will be shown as isolated run on LangSmith.\n        storedRun.parent_run_id = undefined;\n      }\n    } else {\n      storedRun.trace_id = storedRun.id;\n      storedRun.dotted_order = currentDottedOrder;\n      storedRun._serialized_start_time = microsecondPrecisionDatestring;\n    }\n    if (this.usesRunTreeMap) {\n      const runTree = convertRunToRunTree(storedRun, parentRun);\n      if (runTree !== undefined) {\n        this.runTreeMap.set(storedRun.id, runTree);\n      }\n    } else {\n      this.runMap.set(storedRun.id, storedRun);\n    }\n    return storedRun;\n  }\n\n  protected async _endTrace(run: Run): Promise<void> {\n    const parentRun =\n      run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n    if (parentRun) {\n      parentRun.child_execution_order = Math.max(\n        parentRun.child_execution_order,\n        run.child_execution_order\n      );\n    } else {\n      await this.persistRun(run);\n    }\n    await this.onRunUpdate?.(run);\n    if (this.usesRunTreeMap) {\n      this.runTreeMap.delete(run.id);\n    } else {\n      this.runMap.delete(run.id);\n    }\n  }\n\n  protected _getExecutionOrder(parentRunId: string | undefined): number {\n    const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n    // If a run has no parent then execution order is 1\n    if (!parentRun) {\n      return 1;\n    }\n\n    return parentRun.child_execution_order + 1;\n  }\n\n  /**\n   * Create and add a run to the run map for LLM start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { prompts },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForLLMStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chat model start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { messages },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChatModelStart(\n        llm,\n        messages,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = output;\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleLLMError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chain start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string,\n    extra?: Record<string, unknown>\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? chain.id[chain.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: chain,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs,\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: runType ?? \"chain\",\n      child_runs: [],\n      extra: metadata ? { ...extra, metadata } : { ...extra },\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChainStart(\n        chain,\n        inputs,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        runType,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onChainStart?.(run);\n    return run;\n  }\n\n  async handleChainEnd(\n    outputs: ChainValues,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = _coerceToDict(outputs, \"output\");\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleChainError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for tool start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? tool.id[tool.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: tool,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { input },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"tool\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForToolStart(\n        tool,\n        input,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onToolStart?.(run);\n    return run;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { output };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleToolError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleAgentAction(action: AgentAction, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    const agentRun = run as AgentRun;\n    agentRun.actions = agentRun.actions || [];\n    agentRun.actions.push(action);\n    agentRun.events.push({\n      name: \"agent_action\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentAction?.(run as AgentRun);\n  }\n\n  async handleAgentEnd(action: AgentFinish, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"agent_end\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentEnd?.(run);\n  }\n\n  /**\n   * Create and add a run to the run map for retriever start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? retriever.id[retriever.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: retriever,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { query },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"retriever\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForRetrieverStart(\n        retriever,\n        query,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onRetrieverStart?.(run);\n    return run;\n  }\n\n  async handleRetrieverEnd(\n    documents: Document<Record<string, unknown>>[],\n    runId: string\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { documents };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleRetrieverError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleText(text: string, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"text\",\n      time: new Date().toISOString(),\n      kwargs: { text },\n    });\n    await this.onText?.(run);\n  }\n\n  async handleLLMNewToken(\n    token: string,\n    idx: NewTokenIndices,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\n        `Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`\n      );\n    }\n    run.events.push({\n      name: \"new_token\",\n      time: new Date().toISOString(),\n      kwargs: { token, idx, chunk: fields?.chunk },\n    });\n    await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n    return run;\n  }\n\n  // custom event handlers\n\n  onRunCreate?(run: Run): void | Promise<void>;\n\n  onRunUpdate?(run: Run): void | Promise<void>;\n\n  onLLMStart?(run: Run): void | Promise<void>;\n\n  onLLMEnd?(run: Run): void | Promise<void>;\n\n  onLLMError?(run: Run): void | Promise<void>;\n\n  onChainStart?(run: Run): void | Promise<void>;\n\n  onChainEnd?(run: Run): void | Promise<void>;\n\n  onChainError?(run: Run): void | Promise<void>;\n\n  onToolStart?(run: Run): void | Promise<void>;\n\n  onToolEnd?(run: Run): void | Promise<void>;\n\n  onToolError?(run: Run): void | Promise<void>;\n\n  onAgentAction?(run: Run): void | Promise<void>;\n\n  onAgentEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverStart?(run: Run): void | Promise<void>;\n\n  onRetrieverEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverError?(run: Run): void | Promise<void>;\n\n  onText?(run: Run): void | Promise<void>;\n\n  onLLMNewToken?(\n    run: Run,\n    token: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs?: { chunk: any }\n  ): void | Promise<void>;\n}\n"],"mappings":"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"}