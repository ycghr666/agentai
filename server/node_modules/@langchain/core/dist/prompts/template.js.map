{"version":3,"file":"template.js","names":[],"sources":["../../src/prompts/template.ts"],"sourcesContent":["import mustache from \"mustache\";\nimport { MessageContent } from \"../messages/index.js\";\nimport type { InputValues } from \"../utils/types/index.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\nfunction configureMustache() {\n  // Use unescaped HTML\n  // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n  mustache.escape = (text) => text;\n}\n\n/**\n * Type that specifies the format of a template.\n */\nexport type TemplateFormat = \"f-string\" | \"mustache\";\n\n/**\n * Type that represents a node in a parsed format string. It can be either\n * a literal text or a variable name.\n */\nexport type ParsedTemplateNode =\n  | { type: \"literal\"; text: string }\n  | { type: \"variable\"; name: string };\n\n/**\n * Alias for `ParsedTemplateNode` since it is the same for\n * both f-string and mustache templates.\n */\nexport type ParsedFStringNode = ParsedTemplateNode;\n\nexport const parseFString = (template: string): ParsedTemplateNode[] => {\n  // Core logic replicated from internals of pythons built in Formatter class.\n  // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n  const chars = template.split(\"\");\n  const nodes: ParsedTemplateNode[] = [];\n\n  const nextBracket = (bracket: \"}\" | \"{\" | \"{}\", start: number) => {\n    for (let i = start; i < chars.length; i += 1) {\n      if (bracket.includes(chars[i])) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  let i = 0;\n  while (i < chars.length) {\n    if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n      nodes.push({ type: \"literal\", text: \"{\" });\n      i += 2;\n    } else if (\n      chars[i] === \"}\" &&\n      i + 1 < chars.length &&\n      chars[i + 1] === \"}\"\n    ) {\n      nodes.push({ type: \"literal\", text: \"}\" });\n      i += 2;\n    } else if (chars[i] === \"{\") {\n      const j = nextBracket(\"}\", i);\n      if (j < 0) {\n        throw new Error(\"Unclosed '{' in template.\");\n      }\n\n      nodes.push({\n        type: \"variable\",\n        name: chars.slice(i + 1, j).join(\"\"),\n      });\n      i = j + 1;\n    } else if (chars[i] === \"}\") {\n      throw new Error(\"Single '}' in template.\");\n    } else {\n      const next = nextBracket(\"{}\", i);\n      const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n      nodes.push({ type: \"literal\", text });\n      i = next < 0 ? chars.length : next;\n    }\n  }\n  return nodes;\n};\n\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @param {string[]} context Array of section variable names for nested context\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = (\n  template: mustache.TemplateSpans,\n  context: string[] = []\n): ParsedTemplateNode[] => {\n  const nodes: ParsedTemplateNode[] = [];\n\n  for (const temp of template) {\n    if (temp[0] === \"name\") {\n      const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n      nodes.push({ type: \"variable\", name });\n    } else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n      // # represents a section, \"&\" represents an unescaped variable.\n      // These should both be considered variables.\n      nodes.push({ type: \"variable\", name: temp[1] });\n\n      // If this is a section with nested content, recursively process it\n      if (temp[0] === \"#\" && temp.length > 4 && Array.isArray(temp[4])) {\n        const newContext = [...context, temp[1]];\n        const nestedNodes = mustacheTemplateToNodes(temp[4], newContext);\n        nodes.push(...nestedNodes);\n      }\n    } else {\n      nodes.push({ type: \"literal\", text: temp[1] });\n    }\n  }\n\n  return nodes;\n};\n\nexport const parseMustache = (template: string) => {\n  configureMustache();\n  const parsed = mustache.parse(template);\n  return mustacheTemplateToNodes(parsed);\n};\n\nexport const interpolateFString = (template: string, values: InputValues) => {\n  return parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n      if (node.name in values) {\n        const stringValue =\n          typeof values[node.name] === \"string\"\n            ? values[node.name]\n            : JSON.stringify(values[node.name]);\n        return res + stringValue;\n      }\n      throw new Error(`(f-string) Missing value for input ${node.name}`);\n    }\n\n    return res + node.text;\n  }, \"\");\n};\n\nexport const interpolateMustache = (template: string, values: InputValues) => {\n  configureMustache();\n  return mustache.render(template, values);\n};\n\n/**\n * Type that represents a function that takes a template string and a set\n * of input values, and returns a string where all variables in the\n * template have been replaced with their corresponding values.\n */\ntype Interpolator = (template: string, values: InputValues) => string;\n\n/**\n * Type that represents a function that takes a template string and\n * returns an array of `ParsedTemplateNode`.\n */\ntype Parser = (template: string) => ParsedTemplateNode[];\n\nexport const DEFAULT_FORMATTER_MAPPING: Record<TemplateFormat, Interpolator> = {\n  \"f-string\": interpolateFString,\n  mustache: interpolateMustache,\n};\n\nexport const DEFAULT_PARSER_MAPPING: Record<TemplateFormat, Parser> = {\n  \"f-string\": parseFString,\n  mustache: parseMustache,\n};\n\nexport const renderTemplate = (\n  template: string,\n  templateFormat: TemplateFormat,\n  inputValues: InputValues\n) => {\n  try {\n    return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n  } catch (e) {\n    const error = addLangChainErrorFields(e, \"INVALID_PROMPT_INPUT\");\n    throw error;\n  }\n};\n\nexport const parseTemplate = (\n  template: string,\n  templateFormat: TemplateFormat\n) => DEFAULT_PARSER_MAPPING[templateFormat](template);\n\nexport const checkValidTemplate = (\n  template: MessageContent,\n  templateFormat: TemplateFormat,\n  inputVariables: string[]\n) => {\n  if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n    const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n    throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n  }\n  try {\n    // Build dummy inputs using Object.fromEntries to avoid prototype pollution\n    // from dynamic property assignment with user-provided keys\n    const dummyInputs: InputValues = Object.fromEntries(\n      inputVariables.map((v) => [v, \"foo\"])\n    );\n    if (Array.isArray(template)) {\n      template.forEach((message) => {\n        if (\n          message.type === \"text\" &&\n          \"text\" in message &&\n          typeof message.text === \"string\"\n        ) {\n          renderTemplate(message.text, templateFormat, dummyInputs);\n        } else if (message.type === \"image_url\") {\n          if (typeof message.image_url === \"string\") {\n            renderTemplate(message.image_url, templateFormat, dummyInputs);\n          } else if (\n            typeof message.image_url === \"object\" &&\n            message.image_url !== null &&\n            \"url\" in message.image_url &&\n            typeof message.image_url.url === \"string\"\n          ) {\n            const imageUrl = message.image_url.url;\n            renderTemplate(imageUrl, templateFormat, dummyInputs);\n          }\n        } else {\n          throw new Error(\n            `Invalid message template received. ${JSON.stringify(\n              message,\n              null,\n              2\n            )}`\n          );\n        }\n      });\n    } else {\n      renderTemplate(template, templateFormat, dummyInputs);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e: any) {\n    throw new Error(`Invalid prompt schema: ${e.message}`);\n  }\n};\n"],"mappings":"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"}