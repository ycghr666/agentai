{"version":3,"file":"transform.js","names":[],"sources":["../../src/output_parsers/transform.ts"],"sourcesContent":["import { deepCompareStrict } from \"@cfworker/json-schema\";\nimport { BaseOutputParser } from \"./base.js\";\nimport {\n  type BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n} from \"../messages/base.js\";\nimport { convertToChunk } from \"../messages/utils.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  type Generation,\n  type ChatGeneration,\n  GenerationChunk,\n  ChatGenerationChunk,\n} from \"../outputs.js\";\n\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport abstract class BaseTransformOutputParser<\n  T = unknown,\n> extends BaseOutputParser<T> {\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{ text: chunk }]);\n      } else {\n        yield this.parseResult([\n          {\n            message: chunk,\n            text: this._baseMessageToString(chunk),\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>,\n    options: BaseCallbackConfig\n  ): AsyncGenerator<T> {\n    yield* this._transformStreamWithConfig(\n      inputGenerator,\n      this._transform.bind(this),\n      {\n        ...options,\n        runType: \"parser\",\n      }\n    );\n  }\n}\n\nexport type BaseCumulativeTransformOutputParserInput = { diff?: boolean };\n\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport abstract class BaseCumulativeTransformOutputParser<\n  T = unknown,\n> extends BaseTransformOutputParser<T> {\n  protected diff = false;\n\n  constructor(fields?: BaseCumulativeTransformOutputParserInput) {\n    super(fields);\n    this.diff = fields?.diff ?? this.diff;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected abstract _diff(prev: any | undefined, next: any): any;\n\n  abstract parsePartialResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<T | undefined>;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    let prevParsed: T | undefined;\n    let accGen: GenerationChunk | undefined;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen: GenerationChunk;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content,\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: convertToChunk(chunk),\n          text: chunk.content,\n        });\n      } else {\n        chunkGen = new GenerationChunk({ text: chunk });\n      }\n\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n\n      const parsed = await this.parsePartialResult([accGen]);\n      if (\n        parsed !== undefined &&\n        parsed !== null &&\n        !deepCompareStrict(parsed, prevParsed)\n      ) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n"],"mappings":";;;;;;;;;;AAmBA,IAAsB,4BAAtB,cAEU,iBAAoB;CAC5B,OAAO,WACL,gBACmB;AACnB,aAAW,MAAM,SAAS,eACxB,KAAI,OAAO,UAAU,SACnB,OAAM,KAAK,YAAY,CAAC,EAAE,MAAM,OAAO,CAAC,CAAC;MAEzC,OAAM,KAAK,YAAY,CACrB;GACE,SAAS;GACT,MAAM,KAAK,qBAAqB,MAAM;GACvC,CACF,CAAC;;;;;;;;;CAYR,OAAO,UACL,gBACA,SACmB;AACnB,SAAO,KAAK,2BACV,gBACA,KAAK,WAAW,KAAK,KAAK,EAC1B;GACE,GAAG;GACH,SAAS;GACV,CACF;;;;;;;;AAWL,IAAsB,sCAAtB,cAEU,0BAA6B;CACrC,AAAU,OAAO;CAEjB,YAAY,QAAmD;AAC7D,QAAM,OAAO;AACb,OAAK,OAAO,QAAQ,QAAQ,KAAK;;CAUnC,OAAO,WACL,gBACmB;EACnB,IAAI;EACJ,IAAI;AACJ,aAAW,MAAM,SAAS,gBAAgB;AACxC,OAAI,OAAO,UAAU,YAAY,OAAO,MAAM,YAAY,SACxD,OAAM,IAAI,MAAM,mCAAmC;GAErD,IAAI;AACJ,OAAI,mBAAmB,MAAM,EAAE;AAC7B,QAAI,OAAO,MAAM,YAAY,SAC3B,OAAM,IAAI,MAAM,2CAA2C;AAE7D,eAAW,IAAI,oBAAoB;KACjC,SAAS;KACT,MAAM,MAAM;KACb,CAAC;cACO,cAAc,MAAM,EAAE;AAC/B,QAAI,OAAO,MAAM,YAAY,SAC3B,OAAM,IAAI,MAAM,2CAA2C;AAE7D,eAAW,IAAI,oBAAoB;KACjC,SAAS,eAAe,MAAM;KAC9B,MAAM,MAAM;KACb,CAAC;SAEF,YAAW,IAAI,gBAAgB,EAAE,MAAM,OAAO,CAAC;AAGjD,OAAI,WAAW,OACb,UAAS;OAET,UAAS,OAAO,OAAO,SAAS;GAGlC,MAAM,SAAS,MAAM,KAAK,mBAAmB,CAAC,OAAO,CAAC;AACtD,OACE,WAAW,UACX,WAAW,QACX,CAAC,kBAAkB,QAAQ,WAAW,EACtC;AACA,QAAI,KAAK,KACP,OAAM,KAAK,MAAM,YAAY,OAAO;QAEpC,OAAM;AAER,iBAAa;;;;CAKnB,wBAAgC;AAC9B,SAAO"}