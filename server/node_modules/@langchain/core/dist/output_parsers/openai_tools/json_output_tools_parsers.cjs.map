{"version":3,"file":"json_output_tools_parsers.cjs","names":["parsePartialJson","OutputParserException","BaseCumulativeTransformOutputParser","isAIMessage","interopSafeParseAsync"],"sources":["../../../src/output_parsers/openai_tools/json_output_tools_parsers.ts"],"sourcesContent":["import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport { ChatGeneration, ChatGenerationChunk } from \"../../outputs.js\";\nimport { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { InvalidToolCall, ToolCall } from \"../../messages/tool.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nimport {\n  type InteropZodType,\n  interopSafeParseAsync,\n} from \"../../utils/types/zod.js\";\n\nexport type ParsedToolCall = {\n  id?: string;\n\n  type: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: Record<string, any>;\n};\n\nexport type JsonOutputToolsParserParams = {\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n} & BaseCumulativeTransformOutputParserInput;\n\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options: { returnId?: boolean; partial: true }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: false }\n): ToolCall;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined {\n  if (rawToolCall.function === undefined) {\n    return undefined;\n  }\n  let functionArgs;\n  if (options?.partial) {\n    try {\n      functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n    } catch {\n      return undefined;\n    }\n  } else {\n    try {\n      functionArgs = JSON.parse(rawToolCall.function.arguments);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new OutputParserException(\n        [\n          `Function \"${rawToolCall.function.name}\" arguments:`,\n          ``,\n          rawToolCall.function.arguments,\n          ``,\n          `are not valid JSON.`,\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n\n  const parsedToolCall: ToolCall = {\n    name: rawToolCall.function.name,\n    args: functionArgs,\n    type: \"tool_call\",\n  };\n\n  if (options?.returnId) {\n    parsedToolCall.id = rawToolCall.id;\n  }\n\n  return parsedToolCall;\n}\n\nexport function convertLangChainToolCallToOpenAI(toolCall: ToolCall) {\n  if (toolCall.id === undefined) {\n    throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n  }\n  return {\n    id: toolCall.id,\n    type: \"function\",\n    function: {\n      name: toolCall.name,\n      arguments: JSON.stringify(toolCall.args),\n    },\n  };\n}\n\nexport function makeInvalidToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  errorMsg?: string\n): InvalidToolCall {\n  return {\n    name: rawToolCall.function?.name,\n    args: rawToolCall.function?.arguments,\n    id: rawToolCall.id,\n    error: errorMsg,\n    type: \"invalid_tool_call\",\n  };\n}\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser<\n  T,\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n\n  returnId = false;\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  constructor(fields?: JsonOutputToolsParserParams) {\n    super(fields);\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n\n  protected _diff() {\n    throw new Error(\"Not supported.\");\n  }\n\n  async parse(): Promise<T> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const result = await this.parsePartialResult(generations, false);\n    return result;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parsePartialResult(\n    generations: ChatGenerationChunk[] | ChatGeneration[],\n    partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const message = generations[0].message;\n    let toolCalls;\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      toolCalls = message.tool_calls.map((toolCall) => {\n        const { id, ...rest } = toolCall;\n        if (!this.returnId) {\n          return rest;\n        }\n        return {\n          id,\n          ...rest,\n        };\n      });\n    } else if (message.additional_kwargs.tool_calls !== undefined) {\n      const rawToolCalls = JSON.parse(\n        JSON.stringify(message.additional_kwargs.tool_calls)\n      );\n      toolCalls = rawToolCalls.map((rawToolCall: Record<string, unknown>) => {\n        return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n      });\n    }\n    if (!toolCalls) {\n      return [];\n    }\n    const parsedToolCalls = [];\n    for (const toolCall of toolCalls) {\n      if (toolCall !== undefined) {\n        const backwardsCompatibleToolCall: ParsedToolCall = {\n          type: toolCall.name,\n          args: toolCall.args,\n          id: toolCall.id,\n        };\n        parsedToolCalls.push(backwardsCompatibleToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n\ntype JsonOutputKeyToolsParserParamsBase = {\n  keyName: string;\n  returnSingle?: boolean;\n} & JsonOutputToolsParserParams;\n\ntype JsonOutputKeyToolsParserParamsV3<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: z3.ZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\ntype JsonOutputKeyToolsParserParamsV4<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: z4.$ZodType<T, T> } & JsonOutputKeyToolsParserParamsBase;\n\nexport type JsonOutputKeyToolsParserParamsInterop<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: InteropZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\n// Use Zod 3 for backwards compatibility\nexport type JsonOutputKeyToolsParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = JsonOutputKeyToolsParserParamsV3<T>;\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> extends JsonOutputToolsParser<T> {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: JsonOutputKeyToolsParserParamsV3<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsV4<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsInterop<T>);\n\n  constructor(\n    params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>\n  ) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parsePartialResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations, false);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(\n      returnedValues.map((value) => this._validateResult(value))\n    );\n    return toolCallResults;\n  }\n}\n"],"mappings":"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"}