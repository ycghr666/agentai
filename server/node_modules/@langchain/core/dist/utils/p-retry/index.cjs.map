{"version":3,"file":"index.cjs","names":["isNetworkError"],"sources":["../../../src/utils/p-retry/index.js"],"sourcesContent":["/* eslint-disable */\nimport isNetworkError from \"../is-network-error/index.js\";\n\nfunction validateRetries(retries) {\n  if (typeof retries === \"number\") {\n    if (retries < 0) {\n      throw new TypeError(\"Expected `retries` to be a non-negative number.\");\n    }\n\n    if (Number.isNaN(retries)) {\n      throw new TypeError(\n        \"Expected `retries` to be a valid number or Infinity, got NaN.\"\n      );\n    }\n  } else if (retries !== undefined) {\n    throw new TypeError(\"Expected `retries` to be a number or Infinity.\");\n  }\n}\n\nfunction validateNumberOption(\n  name,\n  value,\n  { min = 0, allowInfinity = false } = {}\n) {\n  if (value === undefined) {\n    return;\n  }\n\n  if (typeof value !== \"number\" || Number.isNaN(value)) {\n    throw new TypeError(\n      `Expected \\`${name}\\` to be a number${\n        allowInfinity ? \" or Infinity\" : \"\"\n      }.`\n    );\n  }\n\n  if (!allowInfinity && !Number.isFinite(value)) {\n    throw new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n  }\n\n  if (value < min) {\n    throw new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n  }\n}\n\nexport class AbortError extends Error {\n  constructor(message) {\n    super();\n\n    if (message instanceof Error) {\n      this.originalError = message;\n      ({ message } = message);\n    } else {\n      this.originalError = new Error(message);\n      this.originalError.stack = this.stack;\n    }\n\n    this.name = \"AbortError\";\n    this.message = message;\n  }\n}\n\nfunction calculateDelay(retriesConsumed, options) {\n  const attempt = Math.max(1, retriesConsumed + 1);\n  const random = options.randomize ? Math.random() + 1 : 1;\n\n  let timeout = Math.round(\n    random * options.minTimeout * options.factor ** (attempt - 1)\n  );\n  timeout = Math.min(timeout, options.maxTimeout);\n\n  return timeout;\n}\n\nfunction calculateRemainingTime(start, max) {\n  if (!Number.isFinite(max)) {\n    return max;\n  }\n\n  return max - (performance.now() - start);\n}\n\nasync function onAttemptFailure({\n  error,\n  attemptNumber,\n  retriesConsumed,\n  startTime,\n  options,\n}) {\n  const normalizedError =\n    error instanceof Error\n      ? error\n      : new TypeError(\n          `Non-error was thrown: \"${error}\". You should only throw errors.`\n        );\n\n  if (normalizedError instanceof AbortError) {\n    throw normalizedError.originalError;\n  }\n\n  const retriesLeft = Number.isFinite(options.retries)\n    ? Math.max(0, options.retries - retriesConsumed)\n    : options.retries;\n\n  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n\n  const context = Object.freeze({\n    error: normalizedError,\n    attemptNumber,\n    retriesLeft,\n    retriesConsumed,\n  });\n\n  await options.onFailedAttempt(context);\n\n  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {\n    throw normalizedError;\n  }\n\n  const consumeRetry = await options.shouldConsumeRetry(context);\n\n  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);\n\n  if (remainingTime <= 0 || retriesLeft <= 0) {\n    throw normalizedError;\n  }\n\n  if (\n    normalizedError instanceof TypeError &&\n    !isNetworkError(normalizedError)\n  ) {\n    if (consumeRetry) {\n      throw normalizedError;\n    }\n\n    options.signal?.throwIfAborted();\n    return false;\n  }\n\n  if (!(await options.shouldRetry(context))) {\n    throw normalizedError;\n  }\n\n  if (!consumeRetry) {\n    options.signal?.throwIfAborted();\n    return false;\n  }\n\n  const delayTime = calculateDelay(retriesConsumed, options);\n  const finalDelay = Math.min(delayTime, remainingTime);\n\n  if (finalDelay > 0) {\n    await new Promise((resolve, reject) => {\n      const onAbort = () => {\n        clearTimeout(timeoutToken);\n        options.signal?.removeEventListener(\"abort\", onAbort);\n        reject(options.signal.reason);\n      };\n\n      const timeoutToken = setTimeout(() => {\n        options.signal?.removeEventListener(\"abort\", onAbort);\n        resolve();\n      }, finalDelay);\n\n      if (options.unref) {\n        timeoutToken.unref?.();\n      }\n\n      options.signal?.addEventListener(\"abort\", onAbort, { once: true });\n    });\n  }\n\n  options.signal?.throwIfAborted();\n\n  return true;\n}\n\nexport default async function pRetry(input, options = {}) {\n  options = { ...options };\n\n  validateRetries(options.retries);\n\n  if (Object.hasOwn(options, \"forever\")) {\n    throw new Error(\n      \"The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.\"\n    );\n  }\n\n  options.retries ??= 10;\n  options.factor ??= 2;\n  options.minTimeout ??= 1000;\n  options.maxTimeout ??= Number.POSITIVE_INFINITY;\n  options.maxRetryTime ??= Number.POSITIVE_INFINITY;\n  options.randomize ??= false;\n  options.onFailedAttempt ??= () => {};\n  options.shouldRetry ??= () => true;\n  options.shouldConsumeRetry ??= () => true;\n\n  // Validate numeric options and normalize edge cases\n  validateNumberOption(\"factor\", options.factor, {\n    min: 0,\n    allowInfinity: false,\n  });\n  validateNumberOption(\"minTimeout\", options.minTimeout, {\n    min: 0,\n    allowInfinity: false,\n  });\n  validateNumberOption(\"maxTimeout\", options.maxTimeout, {\n    min: 0,\n    allowInfinity: true,\n  });\n  validateNumberOption(\"maxRetryTime\", options.maxRetryTime, {\n    min: 0,\n    allowInfinity: true,\n  });\n\n  // Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n  if (!(options.factor > 0)) {\n    options.factor = 1;\n  }\n\n  options.signal?.throwIfAborted();\n\n  let attemptNumber = 0;\n  let retriesConsumed = 0;\n  const startTime = performance.now();\n\n  while (\n    Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true\n  ) {\n    attemptNumber++;\n\n    try {\n      options.signal?.throwIfAborted();\n\n      const result = await input(attemptNumber);\n\n      options.signal?.throwIfAborted();\n\n      return result;\n    } catch (error) {\n      if (\n        await onAttemptFailure({\n          error,\n          attemptNumber,\n          retriesConsumed,\n          startTime,\n          options,\n        })\n      ) {\n        retriesConsumed++;\n      }\n    }\n  }\n\n  // Should not reach here, but in case it does, throw an error\n  throw new Error(\"Retry attempts exhausted without throwing an error.\");\n}\n\nexport function makeRetriable(function_, options) {\n  return function (...arguments_) {\n    return pRetry(() => function_.apply(this, arguments_), options);\n  };\n}\n"],"mappings":"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"}