{"version":3,"file":"parseDef.js","names":[],"sources":["../../../src/utils/zod-to-json-schema/parseDef.ts"],"sourcesContent":["import { ZodTypeDef } from \"zod/v3\";\nimport { Refs, Seen } from \"./Refs.js\";\nimport { ignoreOverride } from \"./Options.js\";\nimport { JsonSchema7Type } from \"./parseTypes.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\n\nexport function parseDef(\n  def: ZodTypeDef,\n  refs: Refs,\n  forceResolution = false // Forces a new schema to be instantiated even though its def has been seen. Used for improving refs in definitions. See https://github.com/StefanTerdell/zod-to-json-schema/pull/61.\n): JsonSchema7Type | undefined {\n  const seenItem = refs.seen.get(def);\n\n  if (refs.override) {\n    const overrideResult = refs.override?.(\n      def,\n      refs,\n      seenItem,\n      forceResolution\n    );\n\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n\n  const newItem: Seen = { def, path: refs.currentPath, jsonSchema: undefined };\n\n  refs.seen.set(def, newItem);\n\n  const jsonSchemaOrGetter = selectParser(def, (def as any).typeName, refs);\n\n  // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n  const jsonSchema =\n    typeof jsonSchemaOrGetter === \"function\"\n      ? parseDef(jsonSchemaOrGetter(), refs)\n      : jsonSchemaOrGetter;\n\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n\n    newItem.jsonSchema = jsonSchema;\n\n    return postProcessResult;\n  }\n\n  newItem.jsonSchema = jsonSchema;\n\n  return jsonSchema;\n}\n\nconst get$ref = (\n  item: Seen,\n  refs: Refs\n):\n  | {\n      $ref: string;\n    }\n  | {}\n  | undefined => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return { $ref: item.path.join(\"/\") };\n    case \"relative\":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case \"none\":\n    case \"seen\": {\n      if (\n        item.path.length < refs.currentPath.length &&\n        item.path.every((value, index) => refs.currentPath[index] === value)\n      ) {\n        console.warn(\n          `Recursive reference detected at ${refs.currentPath.join(\n            \"/\"\n          )}! Defaulting to any`\n        );\n\n        return parseAnyDef(refs);\n      }\n\n      return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n    }\n  }\n};\n\nconst addMeta = (\n  def: ZodTypeDef,\n  refs: Refs,\n  jsonSchema: JsonSchema7Type\n): JsonSchema7Type => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n\n    if (refs.markdownDescription) {\n      jsonSchema.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema;\n};\n"],"mappings":";;;;;;AAQA,SAAgB,SACd,KACA,MACA,kBAAkB,OACW;CAC7B,MAAM,WAAW,KAAK,KAAK,IAAI,IAAI;AAEnC,KAAI,KAAK,UAAU;EACjB,MAAM,iBAAiB,KAAK,WAC1B,KACA,MACA,UACA,gBACD;AAED,MAAI,mBAAmB,eACrB,QAAO;;AAIX,KAAI,YAAY,CAAC,iBAAiB;EAChC,MAAM,aAAa,QAAQ,UAAU,KAAK;AAE1C,MAAI,eAAe,OACjB,QAAO;;CAIX,MAAM,UAAgB;EAAE;EAAK,MAAM,KAAK;EAAa,YAAY;EAAW;AAE5E,MAAK,KAAK,IAAI,KAAK,QAAQ;CAE3B,MAAM,qBAAqB,aAAa,KAAM,IAAY,UAAU,KAAK;CAGzE,MAAM,aACJ,OAAO,uBAAuB,aAC1B,SAAS,oBAAoB,EAAE,KAAK,GACpC;AAEN,KAAI,WACF,SAAQ,KAAK,MAAM,WAAW;AAGhC,KAAI,KAAK,aAAa;EACpB,MAAM,oBAAoB,KAAK,YAAY,YAAY,KAAK,KAAK;AAEjE,UAAQ,aAAa;AAErB,SAAO;;AAGT,SAAQ,aAAa;AAErB,QAAO;;AAGT,MAAM,WACJ,MACA,SAMe;AACf,SAAQ,KAAK,cAAb;EACE,KAAK,OACH,QAAO,EAAE,MAAM,KAAK,KAAK,KAAK,IAAI,EAAE;EACtC,KAAK,WACH,QAAO,EAAE,MAAM,gBAAgB,KAAK,aAAa,KAAK,KAAK,EAAE;EAC/D,KAAK;EACL,KAAK;AACH,OACE,KAAK,KAAK,SAAS,KAAK,YAAY,UACpC,KAAK,KAAK,OAAO,OAAO,UAAU,KAAK,YAAY,WAAW,MAAM,EACpE;AACA,YAAQ,KACN,mCAAmC,KAAK,YAAY,KAClD,IACD,CAAC,qBACH;AAED,WAAO,YAAY,KAAK;;AAG1B,UAAO,KAAK,iBAAiB,SAAS,YAAY,KAAK,GAAG;;;AAKhE,MAAM,WACJ,KACA,MACA,eACoB;AACpB,KAAI,IAAI,aAAa;AACnB,aAAW,cAAc,IAAI;AAE7B,MAAI,KAAK,oBACP,YAAW,sBAAsB,IAAI;;AAGzC,QAAO"}