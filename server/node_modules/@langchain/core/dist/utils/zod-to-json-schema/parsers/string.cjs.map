{"version":3,"file":"string.cjs","names":[],"sources":["../../../../src/utils/zod-to-json-schema/parsers/string.ts"],"sourcesContent":["import { ZodStringDef } from \"zod/v3\";\nimport { ErrorMessages, setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { Refs } from \"../Refs.js\";\n\nlet emojiRegex: RegExp | undefined = undefined;\n\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email:\n    /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp(\n        \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n        \"u\"\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr:\n    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr:\n    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url:\n    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n} as const;\n\nexport type JsonSchema7StringType = {\n  type: \"string\";\n  minLength?: number;\n  maxLength?: number;\n  format?:\n    | \"email\"\n    | \"idn-email\"\n    | \"uri\"\n    | \"uuid\"\n    | \"date-time\"\n    | \"ipv4\"\n    | \"ipv6\"\n    | \"date\"\n    | \"time\"\n    | \"duration\";\n  pattern?: string;\n  allOf?: {\n    pattern: string;\n    errorMessage?: ErrorMessages<{ pattern: string }>;\n  }[];\n  anyOf?: {\n    format: string;\n    errorMessage?: ErrorMessages<{ format: string }>;\n  }[];\n  errorMessage?: ErrorMessages<JsonSchema7StringType>;\n  contentEncoding?: string;\n};\n\nexport function parseStringDef(\n  def: ZodStringDef,\n  refs: Refs\n): JsonSchema7StringType {\n  const res: JsonSchema7StringType = {\n    type: \"string\",\n  };\n\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          setResponseValueAndErrors(\n            res,\n            \"minLength\",\n            typeof res.minLength === \"number\"\n              ? Math.max(res.minLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          break;\n        case \"max\":\n          setResponseValueAndErrors(\n            res,\n            \"maxLength\",\n            typeof res.maxLength === \"number\"\n              ? Math.min(res.maxLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs\n          );\n          break;\n        case \"endsWith\":\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs\n          );\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          setResponseValueAndErrors(\n            res,\n            \"minLength\",\n            typeof res.minLength === \"number\"\n              ? Math.max(res.minLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          setResponseValueAndErrors(\n            res,\n            \"maxLength\",\n            typeof res.maxLength === \"number\"\n              ? Math.min(res.maxLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          break;\n        case \"includes\": {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs\n          );\n          break;\n        }\n        case \"ip\": {\n          if (check.version !== \"v6\") {\n            addFormat(res, \"ipv4\", check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addFormat(res, \"ipv6\", check.message, refs);\n          }\n          break;\n        }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\": {\n          if (check.version !== \"v6\") {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\": {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case \"base64\": {\n          switch (refs.base64Strategy) {\n            case \"format:binary\": {\n              addFormat(res, \"binary\" as any, check.message, refs);\n              break;\n            }\n\n            case \"contentEncoding:base64\": {\n              setResponseValueAndErrors(\n                res,\n                \"contentEncoding\",\n                \"base64\",\n                check.message,\n                refs\n              );\n              break;\n            }\n\n            case \"pattern:zod\": {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case \"nanoid\": {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n          break;\n        }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* c8 ignore next */\n          ((_: never) => {})(check);\n      }\n    }\n  }\n\n  return res;\n}\n\nfunction escapeLiteralCheckValue(literal: string, refs: Refs): string {\n  return refs.patternStrategy === \"escape\"\n    ? escapeNonAlphaNumeric(literal)\n    : literal;\n}\n\nconst ALPHA_NUMERIC = new Set(\n  \"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\"\n);\n\nfunction escapeNonAlphaNumeric(source: string) {\n  let result = \"\";\n\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n\n    result += source[i];\n  }\n\n  return result;\n}\n\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(\n  schema: JsonSchema7StringType,\n  value: Required<JsonSchema7StringType>[\"format\"],\n  message: string | undefined,\n  refs: Refs\n) {\n  if (schema.format || schema.anyOf?.some((x) => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n\n    if (schema.format) {\n      schema.anyOf!.push({\n        format: schema.format,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { format: schema.errorMessage.format },\n          }),\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.anyOf!.push({\n      format: value,\n      ...(message &&\n        refs.errorMessages && { errorMessage: { format: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"format\", value, message, refs);\n  }\n}\n\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(\n  schema: JsonSchema7StringType,\n  regex: RegExp,\n  message: string | undefined,\n  refs: Refs\n) {\n  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n\n    if (schema.pattern) {\n      schema.allOf!.push({\n        pattern: schema.pattern,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { pattern: schema.errorMessage.pattern },\n          }),\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.allOf!.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...(message &&\n        refs.errorMessages && { errorMessage: { pattern: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(\n      schema,\n      \"pattern\",\n      stringifyRegExpWithFlags(regex, refs),\n      message,\n      refs\n    );\n  }\n}\n\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex: RegExp, refs: Refs): string {\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes(\"i\"), // Case-insensitive\n    m: regex.flags.includes(\"m\"), // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes(\"s\"), // `.` matches newlines\n  };\n\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n\n  try {\n    new RegExp(pattern);\n  } catch {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        \"/\"\n      )} to a flag-independent form! Falling back to the flag-ignorant source`\n    );\n    return regex.source;\n  }\n\n  return pattern;\n}\n"],"mappings":"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"}