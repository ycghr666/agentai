{"version":3,"file":"intersection.cjs","names":["parseDef"],"sources":["../../../../src/utils/zod-to-json-schema/parsers/intersection.ts"],"sourcesContent":["import { ZodIntersectionDef } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { JsonSchema7StringType } from \"./string.js\";\n\nexport type JsonSchema7AllOfType = {\n  allOf: JsonSchema7Type[];\n  unevaluatedProperties?: boolean;\n};\n\nconst isJsonSchema7AllOfType = (\n  type: JsonSchema7Type | JsonSchema7StringType\n): type is JsonSchema7AllOfType => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\n\nexport function parseIntersectionDef(\n  def: ZodIntersectionDef,\n  refs: Refs\n): JsonSchema7AllOfType | JsonSchema7Type | undefined {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n    }),\n  ].filter((x): x is JsonSchema7Type => !!x);\n\n  let unevaluatedProperties:\n    | Pick<JsonSchema7AllOfType, \"unevaluatedProperties\">\n    | undefined =\n    refs.target === \"jsonSchema2019-09\"\n      ? { unevaluatedProperties: false }\n      : undefined;\n\n  const mergedAllOf: JsonSchema7Type[] = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === undefined) {\n        // If one of the schemas has no unevaluatedProperties set,\n        // the merged schema should also have no unevaluatedProperties set\n        unevaluatedProperties = undefined;\n      }\n    } else {\n      let nestedSchema: JsonSchema7Type = schema;\n      if (\n        \"additionalProperties\" in schema &&\n        schema.additionalProperties === false\n      ) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      } else {\n        // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n        unevaluatedProperties = undefined;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length\n    ? {\n        allOf: mergedAllOf,\n        ...unevaluatedProperties,\n      }\n    : undefined;\n}\n"],"mappings":";;;AAWA,MAAM,0BACJ,SACiC;AACjC,KAAI,UAAU,QAAQ,KAAK,SAAS,SAAU,QAAO;AACrD,QAAO,WAAW;;AAGpB,SAAgB,qBACd,KACA,MACoD;CACpD,MAAM,QAAQ,CACZA,0BAAS,IAAI,KAAK,MAAM;EACtB,GAAG;EACH,aAAa;GAAC,GAAG,KAAK;GAAa;GAAS;GAAI;EACjD,CAAC,EACFA,0BAAS,IAAI,MAAM,MAAM;EACvB,GAAG;EACH,aAAa;GAAC,GAAG,KAAK;GAAa;GAAS;GAAI;EACjD,CAAC,CACH,CAAC,QAAQ,MAA4B,CAAC,CAAC,EAAE;CAE1C,IAAI,wBAGF,KAAK,WAAW,sBACZ,EAAE,uBAAuB,OAAO,GAChC;CAEN,MAAM,cAAiC,EAAE;AAEzC,OAAM,SAAS,WAAW;AACxB,MAAI,uBAAuB,OAAO,EAAE;AAClC,eAAY,KAAK,GAAG,OAAO,MAAM;AACjC,OAAI,OAAO,0BAA0B,OAGnC,yBAAwB;SAErB;GACL,IAAI,eAAgC;AACpC,OACE,0BAA0B,UAC1B,OAAO,yBAAyB,OAChC;IACA,MAAM,EAAE,sBAAsB,GAAG,SAAS;AAC1C,mBAAe;SAGf,yBAAwB;AAE1B,eAAY,KAAK,aAAa;;GAEhC;AACF,QAAO,YAAY,SACf;EACE,OAAO;EACP,GAAG;EACJ,GACD"}