{"version":3,"file":"bigint.js","names":[],"sources":["../../../../src/utils/zod-to-json-schema/parsers/bigint.ts"],"sourcesContent":["import { ZodBigIntDef } from \"zod/v3\";\nimport { Refs } from \"../Refs.js\";\nimport { ErrorMessages, setResponseValueAndErrors } from \"../errorMessages.js\";\n\nexport type JsonSchema7BigintType = {\n  type: \"integer\";\n  format: \"int64\";\n  minimum?: BigInt;\n  exclusiveMinimum?: BigInt;\n  maximum?: BigInt;\n  exclusiveMaximum?: BigInt;\n  multipleOf?: BigInt;\n  errorMessage?: ErrorMessages<JsonSchema7BigintType>;\n};\n\nexport function parseBigintDef(\n  def: ZodBigIntDef,\n  refs: Refs\n): JsonSchema7BigintType {\n  const res: JsonSchema7BigintType = {\n    type: \"integer\",\n    format: \"int64\",\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(\n              res,\n              \"minimum\",\n              check.value,\n              check.message,\n              refs\n            );\n          } else {\n            setResponseValueAndErrors(\n              res,\n              \"exclusiveMinimum\",\n              check.value,\n              check.message,\n              refs\n            );\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMinimum = true as any;\n          }\n          setResponseValueAndErrors(\n            res,\n            \"minimum\",\n            check.value,\n            check.message,\n            refs\n          );\n        }\n        break;\n      case \"max\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(\n              res,\n              \"maximum\",\n              check.value,\n              check.message,\n              refs\n            );\n          } else {\n            setResponseValueAndErrors(\n              res,\n              \"exclusiveMaximum\",\n              check.value,\n              check.message,\n              refs\n            );\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMaximum = true as any;\n          }\n          setResponseValueAndErrors(\n            res,\n            \"maximum\",\n            check.value,\n            check.message,\n            refs\n          );\n        }\n        break;\n      case \"multipleOf\":\n        setResponseValueAndErrors(\n          res,\n          \"multipleOf\",\n          check.value,\n          check.message,\n          refs\n        );\n        break;\n    }\n  }\n  return res;\n}\n"],"mappings":";;;AAeA,SAAgB,eACd,KACA,MACuB;CACvB,MAAM,MAA6B;EACjC,MAAM;EACN,QAAQ;EACT;AAED,KAAI,CAAC,IAAI,OAAQ,QAAO;AAExB,MAAK,MAAM,SAAS,IAAI,OACtB,SAAQ,MAAM,MAAd;EACE,KAAK;AACH,OAAI,KAAK,WAAW,cAClB,KAAI,MAAM,UACR,2BACE,KACA,WACA,MAAM,OACN,MAAM,SACN,KACD;OAED,2BACE,KACA,oBACA,MAAM,OACN,MAAM,SACN,KACD;QAEE;AACL,QAAI,CAAC,MAAM,UACT,KAAI,mBAAmB;AAEzB,8BACE,KACA,WACA,MAAM,OACN,MAAM,SACN,KACD;;AAEH;EACF,KAAK;AACH,OAAI,KAAK,WAAW,cAClB,KAAI,MAAM,UACR,2BACE,KACA,WACA,MAAM,OACN,MAAM,SACN,KACD;OAED,2BACE,KACA,oBACA,MAAM,OACN,MAAM,SACN,KACD;QAEE;AACL,QAAI,CAAC,MAAM,UACT,KAAI,mBAAmB;AAEzB,8BACE,KACA,WACA,MAAM,OACN,MAAM,SACN,KACD;;AAEH;EACF,KAAK;AACH,6BACE,KACA,cACA,MAAM,OACN,MAAM,SACN,KACD;AACD;;AAGN,QAAO"}