{"version":3,"file":"passthrough.js","names":[],"sources":["../../src/runnables/passthrough.ts"],"sourcesContent":["import { concat } from \"../utils/stream.js\";\nimport {\n  Runnable,\n  RunnableAssign,\n  RunnableMap,\n  RunnableMapLike,\n} from \"./base.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RunnablePassthroughFunc<RunInput = any> =\n  | ((input: RunInput) => void)\n  | ((input: RunInput, config?: RunnableConfig) => void)\n  | ((input: RunInput) => Promise<void>)\n  | ((input: RunInput, config?: RunnableConfig) => Promise<void>);\n\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough<RunInput = any> extends Runnable<\n  RunInput,\n  RunInput\n> {\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  func?: RunnablePassthroughFunc<RunInput>;\n\n  constructor(fields?: { func?: RunnablePassthroughFunc<RunInput> }) {\n    super(fields);\n    if (fields) {\n      this.func = fields.func;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunInput> {\n    const config = ensureConfig(options);\n    if (this.func) {\n      await this.func(input, config);\n    }\n\n    return this._callWithConfig(\n      (input: RunInput) => Promise.resolve(input),\n      input,\n      config\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<RunnableConfig>\n  ): AsyncGenerator<RunInput> {\n    const config = ensureConfig(options);\n    let finalOutput: RunInput | undefined;\n    let finalOutputSupported = true;\n\n    for await (const chunk of this._transformStreamWithConfig(\n      generator,\n      (input: AsyncGenerator<RunInput>) => input,\n      config\n    )) {\n      yield chunk;\n      if (finalOutputSupported) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            finalOutput = concat(finalOutput, chunk as any);\n          } catch {\n            finalOutput = undefined;\n            finalOutputSupported = false;\n          }\n        }\n      }\n    }\n\n    if (this.func && finalOutput !== undefined) {\n      await this.func(finalOutput, config);\n    }\n  }\n\n  /**\n   * A runnable that assigns key-value pairs to the input.\n   *\n   * The example below shows how you could use it with an inline function.\n   *\n   * @example\n   * ```typescript\n   * const prompt =\n   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n   * Question: {question}\n   * SQL Query:`);\n   *\n   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n   * // In this case, we're passing the schema.\n   * const sqlQueryGeneratorChain = RunnableSequence.from([\n   *   RunnablePassthrough.assign({\n   *     schema: async () => db.getTableInfo(),\n   *   }),\n   *   prompt,\n   *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n   *   new StringOutputParser(),\n   * ]);\n   * const result = await sqlQueryGeneratorChain.invoke({\n   *   question: \"How many employees are there?\",\n   * });\n   * ```\n   */\n  static assign<\n    RunInput extends Record<string, unknown> = Record<string, unknown>,\n    RunOutput extends Record<string, unknown> = Record<string, unknown>,\n  >(\n    mapping: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableAssign<RunInput, RunInput & RunOutput> {\n    return new RunnableAssign(new RunnableMap({ steps: mapping }));\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,IAAa,sBAAb,cAAyD,SAGvD;CACA,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe,CAAC,kBAAkB,YAAY;CAE9C,kBAAkB;CAElB;CAEA,YAAY,QAAuD;AACjE,QAAM,OAAO;AACb,MAAI,OACF,MAAK,OAAO,OAAO;;CAIvB,MAAM,OACJ,OACA,SACmB;EACnB,MAAM,SAAS,aAAa,QAAQ;AACpC,MAAI,KAAK,KACP,OAAM,KAAK,KAAK,OAAO,OAAO;AAGhC,SAAO,KAAK,iBACT,UAAoB,QAAQ,QAAQ,MAAM,EAC3C,OACA,OACD;;CAGH,OAAO,UACL,WACA,SAC0B;EAC1B,MAAM,SAAS,aAAa,QAAQ;EACpC,IAAI;EACJ,IAAI,uBAAuB;AAE3B,aAAW,MAAM,SAAS,KAAK,2BAC7B,YACC,UAAoC,OACrC,OACD,EAAE;AACD,SAAM;AACN,OAAI,qBACF,KAAI,gBAAgB,OAClB,eAAc;OAEd,KAAI;AAEF,kBAAc,OAAO,aAAa,MAAa;WACzC;AACN,kBAAc;AACd,2BAAuB;;;AAM/B,MAAI,KAAK,QAAQ,gBAAgB,OAC/B,OAAM,KAAK,KAAK,aAAa,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCxC,OAAO,OAIL,SACgD;AAChD,SAAO,IAAI,eAAe,IAAI,YAAY,EAAE,OAAO,SAAS,CAAC,CAAC"}