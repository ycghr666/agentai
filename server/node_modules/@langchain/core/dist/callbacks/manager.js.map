{"version":3,"file":"manager.js","names":["uuidv7"],"sources":["../../src/callbacks/manager.ts"],"sourcesContent":["import { v7 as uuidv7 } from \"uuid\";\nimport { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport { LLMResult } from \"../outputs.js\";\nimport {\n  BaseCallbackHandler,\n  CallbackHandlerMethods,\n  HandleLLMNewTokenCallbackFields,\n  isBaseCallbackHandler,\n  NewTokenIndices,\n} from \"./base.js\";\nimport { ConsoleCallbackHandler } from \"../tracers/console.js\";\nimport { type BaseMessage } from \"../messages/base.js\";\nimport { getBufferString } from \"../messages/utils.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { LangChainTracer } from \"../tracers/tracer_langchain.js\";\nimport { consumeCallback } from \"./promises.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { isTracingEnabled } from \"../utils/callbacks.js\";\nimport { isBaseTracer } from \"../tracers/base.js\";\nimport {\n  getContextVariable,\n  _getConfigureHooks,\n} from \"../singletons/async_local_storage/context.js\";\n\ntype BaseCallbackManagerMethods = {\n  [K in keyof CallbackHandlerMethods]?: (\n    ...args: Parameters<Required<CallbackHandlerMethods>[K]>\n  ) => Promise<unknown>;\n};\n\nexport interface CallbackManagerOptions {\n  verbose?: boolean;\n  tracing?: boolean;\n}\n\nexport type Callbacks =\n  | CallbackManager\n  | (BaseCallbackHandler | CallbackHandlerMethods)[];\n\nexport interface BaseCallbackConfig {\n  /**\n   * Name for the tracer run for this call. Defaults to the name of the class.\n   */\n  runName?: string;\n\n  /**\n   * Tags for this call and any sub-calls (eg. a Chain calling an LLM).\n   * You can use these to filter calls.\n   */\n  tags?: string[];\n\n  /**\n   * Metadata for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Keys should be strings, values should be JSON-serializable.\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * Callbacks for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Tags are passed to all callbacks, metadata is passed to handle*Start callbacks.\n   */\n  callbacks?: Callbacks;\n\n  /**\n   * Unique identifier for the tracer run for this call. If not provided, a new UUID\n   * will be generated.\n   */\n  runId?: string;\n}\n\nexport function parseCallbackConfigArg(\n  arg: Callbacks | BaseCallbackConfig | undefined\n): BaseCallbackConfig {\n  if (!arg) {\n    return {};\n  } else if (Array.isArray(arg) || \"name\" in arg) {\n    return { callbacks: arg };\n  } else {\n    return arg;\n  }\n}\n\n/**\n * Manage callbacks from different components of LangChain.\n */\nexport abstract class BaseCallbackManager {\n  abstract addHandler(handler: BaseCallbackHandler): void;\n\n  abstract removeHandler(handler: BaseCallbackHandler): void;\n\n  abstract setHandlers(handlers: BaseCallbackHandler[]): void;\n\n  setHandler(handler: BaseCallbackHandler): void {\n    return this.setHandlers([handler]);\n  }\n}\n\n/**\n * Base class for run manager in LangChain.\n */\nexport class BaseRunManager {\n  constructor(\n    public readonly runId: string,\n    public readonly handlers: BaseCallbackHandler[],\n    protected readonly inheritableHandlers: BaseCallbackHandler[],\n    protected readonly tags: string[],\n    protected readonly inheritableTags: string[],\n    protected readonly metadata: Record<string, unknown>,\n    protected readonly inheritableMetadata: Record<string, unknown>,\n    protected readonly _parentRunId?: string\n  ) {}\n\n  get parentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleText(text: string): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleText?.(\n              text,\n              this.runId,\n              this._parentRunId,\n              this.tags\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleText: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleCustomEvent(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    _runId?: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleCustomEvent?.(\n              eventName,\n              data,\n              this.runId,\n              this.tags,\n              this.metadata\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * Manages callbacks for retriever runs.\n */\nexport class CallbackManagerForRetrieverRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleRetrieverEnd(documents: DocumentInterface[]): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverEnd?.(\n                documents,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetriever`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleRetrieverError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (error) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForLLMRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  async handleLLMNewToken(\n    token: string,\n    idx?: NewTokenIndices,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMNewToken?.(\n                token,\n                idx ?? { prompt: 0, completion: 0 },\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                fields\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForChainRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleChainError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleChainEnd(\n    output: ChainValues,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentAction(action: AgentAction): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentAction?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentEnd(action: AgentFinish): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentEnd?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForToolRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleToolError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nexport class CallbackManager\n  extends BaseCallbackManager\n  implements BaseCallbackManagerMethods\n{\n  handlers: BaseCallbackHandler[] = [];\n\n  inheritableHandlers: BaseCallbackHandler[] = [];\n\n  tags: string[] = [];\n\n  inheritableTags: string[] = [];\n\n  metadata: Record<string, unknown> = {};\n\n  inheritableMetadata: Record<string, unknown> = {};\n\n  name = \"callback_manager\";\n\n  public _parentRunId?: string;\n\n  constructor(\n    parentRunId?: string,\n    options?: {\n      handlers?: BaseCallbackHandler[];\n      inheritableHandlers?: BaseCallbackHandler[];\n      tags?: string[];\n      inheritableTags?: string[];\n      metadata?: Record<string, unknown>;\n      inheritableMetadata?: Record<string, unknown>;\n    }\n  ) {\n    super();\n    this.handlers = options?.handlers ?? this.handlers;\n    this.inheritableHandlers =\n      options?.inheritableHandlers ?? this.inheritableHandlers;\n    this.tags = options?.tags ?? this.tags;\n    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n    this.metadata = options?.metadata ?? this.metadata;\n    this.inheritableMetadata =\n      options?.inheritableMetadata ?? this.inheritableMetadata;\n    this._parentRunId = parentRunId;\n  }\n\n  /**\n   * Gets the parent run ID, if any.\n   *\n   * @returns The parent run ID.\n   */\n  getParentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      prompts.map(async (prompt, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv7();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForLLMStart(\n                llm,\n                [prompt],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                await handler.handleLLMStart?.(\n                  llm,\n                  [prompt],\n                  runId_,\n                  this._parentRunId,\n                  extraParams,\n                  this.tags,\n                  this.metadata,\n                  runName\n                );\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      messages.map(async (messageGroup, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv7();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForChatModelStart(\n                llm,\n                [messageGroup],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                if (handler.handleChatModelStart) {\n                  await handler.handleChatModelStart?.(\n                    llm,\n                    [messageGroup],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                } else if (handler.handleLLMStart) {\n                  const messageString = getBufferString(messageGroup);\n                  await handler.handleLLMStart?.(\n                    llm,\n                    [messageString],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                }\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId = uuidv7(),\n    runType: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extra: Record<string, unknown> | undefined = undefined\n  ): Promise<CallbackManagerForChainRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreChain) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForChainStart(\n            chain,\n            inputs,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runType,\n            runName,\n            extra\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleChainStart?.(\n              chain,\n              inputs,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runType,\n              runName,\n              extra\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleChainStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForChainRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId = uuidv7(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForToolRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreAgent) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForToolStart(\n            tool,\n            input,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleToolStart?.(\n              tool,\n              input,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleToolStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForToolRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string = uuidv7(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForRetrieverRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreRetriever) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForRetrieverStart(\n            retriever,\n            query,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleRetrieverStart?.(\n              retriever,\n              query,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForRetrieverRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreCustomEvent) {\n            try {\n              await handler.handleCustomEvent?.(\n                eventName,\n                data,\n                runId,\n                this.tags,\n                this.metadata\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  addHandler(handler: BaseCallbackHandler, inherit = true): void {\n    this.handlers.push(handler);\n    if (inherit) {\n      this.inheritableHandlers.push(handler);\n    }\n  }\n\n  removeHandler(handler: BaseCallbackHandler): void {\n    this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n    this.inheritableHandlers = this.inheritableHandlers.filter(\n      (_handler) => _handler !== handler\n    );\n  }\n\n  setHandlers(handlers: BaseCallbackHandler[], inherit = true): void {\n    this.handlers = [];\n    this.inheritableHandlers = [];\n    for (const handler of handlers) {\n      this.addHandler(handler, inherit);\n    }\n  }\n\n  addTags(tags: string[], inherit = true): void {\n    this.removeTags(tags); // Remove duplicates\n    this.tags.push(...tags);\n    if (inherit) {\n      this.inheritableTags.push(...tags);\n    }\n  }\n\n  removeTags(tags: string[]): void {\n    this.tags = this.tags.filter((tag) => !tags.includes(tag));\n    this.inheritableTags = this.inheritableTags.filter(\n      (tag) => !tags.includes(tag)\n    );\n  }\n\n  addMetadata(metadata: Record<string, unknown>, inherit = true): void {\n    this.metadata = { ...this.metadata, ...metadata };\n    if (inherit) {\n      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n    }\n  }\n\n  removeMetadata(metadata: Record<string, unknown>): void {\n    for (const key of Object.keys(metadata)) {\n      delete this.metadata[key];\n      delete this.inheritableMetadata[key];\n    }\n  }\n\n  copy(\n    additionalHandlers: BaseCallbackHandler[] = [],\n    inherit = true\n  ): CallbackManager {\n    const manager = new CallbackManager(this._parentRunId);\n    for (const handler of this.handlers) {\n      const inheritable = this.inheritableHandlers.includes(handler);\n      manager.addHandler(handler, inheritable);\n    }\n    for (const tag of this.tags) {\n      const inheritable = this.inheritableTags.includes(tag);\n      manager.addTags([tag], inheritable);\n    }\n    for (const key of Object.keys(this.metadata)) {\n      const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n    }\n    for (const handler of additionalHandlers) {\n      if (\n        // Prevent multiple copies of console_callback_handler\n        manager.handlers\n          .filter((h) => h.name === \"console_callback_handler\")\n          .some((h) => h.name === handler.name)\n      ) {\n        continue;\n      }\n      manager.addHandler(handler, inherit);\n    }\n    return manager;\n  }\n\n  static fromHandlers(handlers: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuidv7();\n\n      constructor() {\n        super();\n        Object.assign(this, handlers);\n      }\n    }\n\n    const manager = new this();\n    manager.addHandler(new Handler());\n    return manager;\n  }\n\n  static configure(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ): CallbackManager | undefined {\n    return this._configureSync(\n      inheritableHandlers,\n      localHandlers,\n      inheritableTags,\n      localTags,\n      inheritableMetadata,\n      localMetadata,\n      options\n    );\n  }\n\n  // TODO: Deprecate async method in favor of this one.\n  static _configureSync(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ) {\n    let callbackManager: CallbackManager | undefined;\n    if (inheritableHandlers || localHandlers) {\n      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n        callbackManager = new CallbackManager();\n        callbackManager.setHandlers(\n          inheritableHandlers?.map(ensureHandler) ?? [],\n          true\n        );\n      } else {\n        callbackManager = inheritableHandlers;\n      }\n\n      callbackManager = callbackManager.copy(\n        Array.isArray(localHandlers)\n          ? localHandlers.map(ensureHandler)\n          : localHandlers?.handlers,\n        false\n      );\n    }\n\n    const verboseEnabled =\n      getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n      options?.verbose;\n\n    const tracingV2Enabled =\n      LangChainTracer.getTraceableRunTree()?.tracingEnabled ??\n      isTracingEnabled();\n\n    const tracingEnabled =\n      tracingV2Enabled ||\n      (getEnvironmentVariable(\"LANGCHAIN_TRACING\") ?? false);\n    if (verboseEnabled || tracingEnabled) {\n      if (!callbackManager) {\n        callbackManager = new CallbackManager();\n      }\n      if (\n        verboseEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === ConsoleCallbackHandler.prototype.name\n        )\n      ) {\n        const consoleHandler = new ConsoleCallbackHandler();\n        callbackManager.addHandler(consoleHandler, true);\n      }\n      if (\n        tracingEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === \"langchain_tracer\"\n        )\n      ) {\n        if (tracingV2Enabled) {\n          const tracerV2 = new LangChainTracer();\n          callbackManager.addHandler(tracerV2, true);\n        }\n      }\n      if (tracingV2Enabled) {\n        // handoff between langchain and langsmith/traceable\n        // override the parent run ID\n        const implicitRunTree = LangChainTracer.getTraceableRunTree();\n        if (implicitRunTree && callbackManager._parentRunId === undefined) {\n          callbackManager._parentRunId = implicitRunTree.id;\n          const tracerV2 = callbackManager.handlers.find(\n            (handler) => handler.name === \"langchain_tracer\"\n          ) as LangChainTracer | undefined;\n          tracerV2?.updateFromRunTree(implicitRunTree);\n        }\n      }\n    }\n\n    for (const {\n      contextVar,\n      inheritable = true,\n      handlerClass,\n      envVar,\n    } of _getConfigureHooks()) {\n      const createIfNotInContext =\n        envVar && getEnvironmentVariable(envVar) === \"true\" && handlerClass;\n      let handler: BaseCallbackHandler | undefined;\n      const contextVarValue =\n        contextVar !== undefined ? getContextVariable(contextVar) : undefined;\n      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {\n        handler = contextVarValue;\n      } else if (createIfNotInContext) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        handler = new (handlerClass as any)({});\n      }\n      if (handler !== undefined) {\n        if (!callbackManager) {\n          callbackManager = new CallbackManager();\n        }\n\n        if (!callbackManager.handlers.some((h) => h.name === handler!.name)) {\n          callbackManager.addHandler(handler, inheritable);\n        }\n      }\n    }\n\n    if (inheritableTags || localTags) {\n      if (callbackManager) {\n        callbackManager.addTags(inheritableTags ?? []);\n        callbackManager.addTags(localTags ?? [], false);\n      }\n    }\n    if (inheritableMetadata || localMetadata) {\n      if (callbackManager) {\n        callbackManager.addMetadata(inheritableMetadata ?? {});\n        callbackManager.addMetadata(localMetadata ?? {}, false);\n      }\n    }\n\n    return callbackManager;\n  }\n}\n\nexport function ensureHandler(\n  handler: BaseCallbackHandler | CallbackHandlerMethods\n): BaseCallbackHandler {\n  if (\"name\" in handler) {\n    return handler;\n  }\n\n  return BaseCallbackHandler.fromMethods(handler);\n}\n"],"mappings":"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"}