{"version":3,"file":"base.js","names":[],"sources":["../../src/messages/base.ts"],"sourcesContent":["import { Serializable, SerializedConstructor } from \"../load/serializable.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport { isDataContentBlock } from \"./content/data.js\";\nimport { convertToV1FromAnthropicInput } from \"./block_translators/anthropic.js\";\nimport { convertToV1FromDataContent } from \"./block_translators/data.js\";\nimport { convertToV1FromChatCompletionsInput } from \"./block_translators/openai.js\";\nimport {\n  $InferMessageContent,\n  $InferResponseMetadata,\n  MessageStructure,\n  MessageType,\n  isMessage,\n  Message,\n} from \"./message.js\";\nimport {\n  convertToFormattedString,\n  type MessageStringFormat,\n} from \"./format.js\";\n\n/** @internal */\nconst MESSAGE_SYMBOL = Symbol.for(\"langchain.message\");\n\nexport interface StoredMessageData {\n  content: string;\n  role: string | undefined;\n  name: string | undefined;\n  tool_call_id: string | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  additional_kwargs?: Record<string, any>;\n  /** Response metadata. For example: response headers, logprobs, token counts, model name. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response_metadata?: Record<string, any>;\n  id?: string;\n}\n\nexport interface StoredMessage {\n  type: string;\n  data: StoredMessageData;\n}\n\nexport interface StoredGeneration {\n  text: string;\n  message?: StoredMessage;\n}\n\nexport interface StoredMessageV1 {\n  type: string;\n  role: string | undefined;\n  text: string;\n}\n\nexport type MessageContent = string | Array<ContentBlock>;\n\nexport interface FunctionCall {\n  /**\n   * The arguments to call the function with, as generated by the model in JSON\n   * format. Note that the model does not always generate valid JSON, and may\n   * hallucinate parameters not defined by your function schema. Validate the\n   * arguments in your code before calling your function.\n   */\n  arguments: string;\n\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n}\n\nexport type BaseMessageFields<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType,\n> = Pick<Message, \"id\" | \"name\"> & {\n  content?: $InferMessageContent<TStructure, TRole>;\n  contentBlocks?: Array<ContentBlock.Standard>;\n  /** @deprecated */\n  additional_kwargs?: {\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    function_call?: FunctionCall;\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    tool_calls?: OpenAIToolCall[];\n    [key: string]: unknown;\n  };\n  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n};\n\nexport function mergeContent(\n  firstContent: MessageContent,\n  secondContent: MessageContent\n): MessageContent {\n  // If first content is a string\n  if (typeof firstContent === \"string\") {\n    if (firstContent === \"\") {\n      return secondContent;\n    }\n    if (typeof secondContent === \"string\") {\n      return firstContent + secondContent;\n    } else if (Array.isArray(secondContent) && secondContent.length === 0) {\n      return firstContent;\n    } else if (\n      Array.isArray(secondContent) &&\n      secondContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        {\n          type: \"text\",\n          source_type: \"text\",\n          text: firstContent,\n        },\n        ...secondContent,\n      ];\n    } else {\n      return [{ type: \"text\", text: firstContent }, ...secondContent];\n    }\n    // If both are arrays\n  } else if (Array.isArray(secondContent)) {\n    return (\n      _mergeLists(firstContent, secondContent) ?? [\n        ...firstContent,\n        ...secondContent,\n      ]\n    );\n  } else {\n    if (secondContent === \"\") {\n      return firstContent;\n    } else if (\n      Array.isArray(firstContent) &&\n      firstContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        ...firstContent,\n        {\n          type: \"file\",\n          source_type: \"text\",\n          text: secondContent,\n        },\n      ];\n    } else {\n      return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n  }\n}\n\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nexport function _mergeStatus(\n  left?: \"success\" | \"error\",\n  right?: \"success\" | \"error\"\n): \"success\" | \"error\" | undefined {\n  if (left === \"error\" || right === \"error\") {\n    return \"error\";\n  }\n  return \"success\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj: any, depthLimit: number): string {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function helper(obj: any, currentDepth: number): any {\n    if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n      return obj;\n    }\n    if (currentDepth >= depthLimit) {\n      if (Array.isArray(obj)) {\n        return \"[Array]\";\n      }\n      return \"[Object]\";\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map((item) => helper(item, currentDepth + 1));\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const key of Object.keys(obj)) {\n      result[key] = helper(obj[key], currentDepth + 1);\n    }\n    return result;\n  }\n\n  return JSON.stringify(helper(obj, 0), null, 2);\n}\n\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport abstract class BaseMessage<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType,\n>\n  extends Serializable\n  implements Message<TStructure, TRole>\n{\n  lc_namespace = [\"langchain_core\", \"messages\"];\n\n  lc_serializable = true;\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      additional_kwargs: \"additional_kwargs\",\n      response_metadata: \"response_metadata\",\n    };\n  }\n\n  readonly [MESSAGE_SYMBOL] = true as const;\n\n  abstract readonly type: TRole;\n\n  id?: string;\n\n  /** @inheritdoc */\n  name?: string;\n\n  content: $InferMessageContent<TStructure, TRole>;\n\n  additional_kwargs: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"additional_kwargs\"]\n  >;\n\n  response_metadata: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"response_metadata\"]\n  >;\n\n  /**\n   * @deprecated Use .getType() instead or import the proper typeguard.\n   * For example:\n   *\n   * ```ts\n   * import { isAIMessage } from \"@langchain/core/messages\";\n   *\n   * const message = new AIMessage(\"Hello!\");\n   * isAIMessage(message); // true\n   * ```\n   */\n  _getType(): MessageType {\n    return this.type;\n  }\n\n  /**\n   * @deprecated Use .type instead\n   * The type of the message.\n   */\n  getType(): MessageType {\n    return this._getType();\n  }\n\n  constructor(\n    arg:\n      | $InferMessageContent<TStructure, TRole>\n      | BaseMessageFields<TStructure, TRole>\n  ) {\n    const fields: BaseMessageFields<TStructure, TRole> =\n      typeof arg === \"string\" || Array.isArray(arg)\n        ? ({ content: arg } as BaseMessageFields<TStructure, TRole>)\n        : arg;\n    if (!fields.additional_kwargs) {\n      fields.additional_kwargs = {};\n    }\n    if (!fields.response_metadata) {\n      fields.response_metadata = {};\n    }\n    super(fields);\n    this.name = fields.name;\n    if (fields.content === undefined && fields.contentBlocks !== undefined) {\n      this.content = fields.contentBlocks as $InferMessageContent<\n        TStructure,\n        TRole\n      >;\n      this.response_metadata = {\n        output_version: \"v1\",\n        ...fields.response_metadata,\n      };\n    } else if (fields.content !== undefined) {\n      this.content = fields.content ?? [];\n      this.response_metadata = fields.response_metadata;\n    } else {\n      this.content = [] as $InferMessageContent<TStructure, TRole>;\n      this.response_metadata = fields.response_metadata;\n    }\n    this.additional_kwargs = fields.additional_kwargs;\n    this.id = fields.id;\n  }\n\n  /** Get text content of the message. */\n  get text(): string {\n    if (typeof this.content === \"string\") {\n      return this.content;\n    }\n    if (!Array.isArray(this.content)) return \"\";\n    return this.content\n      .map((c) => {\n        if (typeof c === \"string\") return c;\n        if (c.type === \"text\") return c.text;\n        return \"\";\n      })\n      .join(\"\");\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    const blocks: Array<ContentBlock> =\n      typeof this.content === \"string\"\n        ? [{ type: \"text\", text: this.content }]\n        : this.content;\n    const parsingSteps = [\n      convertToV1FromDataContent,\n      convertToV1FromChatCompletionsInput,\n      convertToV1FromAnthropicInput,\n    ];\n    const parsedBlocks = parsingSteps.reduce(\n      (blocks, step) => step(blocks),\n      blocks\n    );\n    return parsedBlocks as Array<ContentBlock.Standard>;\n  }\n\n  toDict(): StoredMessage {\n    return {\n      type: this.getType(),\n      data: (this.toJSON() as SerializedConstructor)\n        .kwargs as StoredMessageData,\n    };\n  }\n\n  static lc_name() {\n    return \"BaseMessage\";\n  }\n\n  // Can't be protected for silly reasons\n  get _printableFields(): Record<string, unknown> {\n    return {\n      id: this.id,\n      content: this.content,\n      name: this.name,\n      additional_kwargs: this.additional_kwargs,\n      response_metadata: this.response_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is BaseMessage {\n    return (\n      typeof obj === \"object\" &&\n      obj !== null &&\n      MESSAGE_SYMBOL in obj &&\n      obj[MESSAGE_SYMBOL] === true &&\n      isMessage(obj)\n    );\n  }\n\n  // this private method is used to update the ID for the runtime\n  // value as well as in lc_kwargs for serialisation\n  _updateId(value: string | undefined) {\n    this.id = value;\n\n    // lc_attributes wouldn't work here, because jest compares the\n    // whole object\n    this.lc_kwargs.id = value;\n  }\n\n  get [Symbol.toStringTag]() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this.constructor as any).lc_name();\n  }\n\n  // Override the default behavior of console.log\n  [Symbol.for(\"nodejs.util.inspect.custom\")](depth: number | null) {\n    if (depth === null) {\n      return this;\n    }\n    const printable = stringifyWithDepthLimit(\n      this._printableFields,\n      Math.max(4, depth)\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return `${(this.constructor as any).lc_name()} ${printable}`;\n  }\n\n  toFormattedString(format: MessageStringFormat = \"pretty\"): string {\n    return convertToFormattedString(this, format);\n  }\n}\n\n/**\n * @deprecated Use \"tool_calls\" field on AIMessages instead\n */\nexport type OpenAIToolCall = {\n  /**\n   * The ID of the tool call.\n   */\n  id: string;\n\n  /**\n   * The function that the model called.\n   */\n  function: FunctionCall;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: \"function\";\n\n  index?: number;\n};\n\nexport function isOpenAIToolCallArray(\n  value?: unknown\n): value is OpenAIToolCall[] {\n  return (\n    Array.isArray(value) &&\n    value.every((v) => typeof (v as OpenAIToolCall).index === \"number\")\n  );\n}\n\n/**\n * Default keys that should be preserved (not merged) when concatenating message chunks.\n * These are identification and timestamp fields that shouldn't be summed or concatenated.\n */\nexport const DEFAULT_MERGE_IGNORE_KEYS: readonly string[] = [\n  \"index\", // Used for identification in tool calls, not accumulation\n  \"created\", // Timestamp field\n  \"timestamp\", // Timestamp field\n] as const;\n\n/**\n * Options for controlling merge behavior in `_mergeDicts`.\n */\nexport interface MergeDictsOptions {\n  /**\n   * Keys to ignore during merging. When a key is in this list:\n   * - For numeric values: the original value is preserved (not summed)\n   * - For string values: the original value is preserved (not concatenated)\n   *\n   * Defaults to `DEFAULT_MERGE_IGNORE_KEYS` which includes 'index', 'created', 'timestamp'.\n   *\n   * @example\n   * // Extend defaults with custom keys\n   * { ignoreKeys: [...DEFAULT_MERGE_IGNORE_KEYS, 'role', 'customField'] }\n   */\n  ignoreKeys?: readonly string[];\n}\n\nexport function _mergeDicts(\n  /**\n   * The left dictionary to merge.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  left: Record<string, any> | undefined,\n  /**\n   * The right dictionary to merge.\n   * @type {Record<string, any>}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  right: Record<string, any> | undefined,\n  /**\n   * The options for the merge.\n   */\n  options?: MergeDictsOptions\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> | undefined {\n  /**\n   * The keys to ignore during merging.\n   */\n  const ignoreKeys = options?.ignoreKeys ?? DEFAULT_MERGE_IGNORE_KEYS;\n  if (left == null && right == null) {\n    return undefined;\n  }\n  if (left == null || right == null) {\n    return left ?? right;\n  }\n  const merged = { ...left };\n  for (const [key, value] of Object.entries(right)) {\n    if (merged[key] == null) {\n      merged[key] = value;\n    } else if (value == null) {\n      continue;\n    } else if (\n      typeof merged[key] !== typeof value ||\n      Array.isArray(merged[key]) !== Array.isArray(value)\n    ) {\n      throw new Error(\n        `field[${key}] already exists in the message chunk, but with a different type.`\n      );\n    } else if (typeof merged[key] === \"string\") {\n      if (key === \"type\") {\n        // Do not merge 'type' fields\n        continue;\n      } else if (\n        [\"id\", \"name\", \"output_version\", \"model_provider\"].includes(key)\n      ) {\n        // Keep the incoming value for these fields if its defined\n        if (value) {\n          merged[key] = value;\n        }\n      } else if (ignoreKeys.includes(key)) {\n        // Preserve the original value for ignored keys\n        continue;\n      } else {\n        merged[key] += value;\n      }\n    } else if (typeof merged[key] === \"number\") {\n      if (ignoreKeys.includes(key)) {\n        // Preserve the original value for ignored keys\n        continue;\n      }\n      merged[key] = merged[key] + value;\n    } else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n      merged[key] = _mergeDicts(merged[key], value, options);\n    } else if (Array.isArray(merged[key])) {\n      merged[key] = _mergeLists(merged[key], value, options);\n    } else if (merged[key] === value) {\n      continue;\n    } else {\n      console.warn(\n        `field[${key}] already exists in this message chunk and value has unsupported type.`\n      );\n    }\n  }\n  return merged;\n}\n\nexport function _mergeLists<Content extends ContentBlock>(\n  left?: Content[],\n  right?: Content[],\n  options?: MergeDictsOptions\n): Content[] | undefined {\n  if (left == null && right == null) {\n    return undefined;\n  } else if (left == null || right == null) {\n    return left || right;\n  } else {\n    const merged = [...left];\n    for (const item of right) {\n      if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"index\" in item &&\n        typeof item.index === \"number\"\n      ) {\n        const toMerge = merged.findIndex((leftItem) => {\n          const isObject = typeof leftItem === \"object\";\n          const indiciesMatch =\n            \"index\" in leftItem && leftItem.index === item.index;\n          const idsMatch =\n            \"id\" in leftItem && \"id\" in item && leftItem?.id === item?.id;\n          const eitherItemMissingID =\n            !(\"id\" in leftItem) ||\n            !leftItem?.id ||\n            !(\"id\" in item) ||\n            !item?.id;\n          return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);\n        });\n        if (\n          toMerge !== -1 &&\n          typeof merged[toMerge] === \"object\" &&\n          merged[toMerge] !== null\n        ) {\n          merged[toMerge] = _mergeDicts(\n            merged[toMerge] as Record<string, unknown>,\n            item as Record<string, unknown>,\n            options\n          ) as Content;\n        } else {\n          merged.push(item);\n        }\n      } else if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"text\" in item &&\n        item.text === \"\"\n      ) {\n        // No-op - skip empty text blocks\n        continue;\n      } else {\n        merged.push(item);\n      }\n    }\n    return merged;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _mergeObj<T = any>(\n  left: T | undefined,\n  right: T | undefined,\n  options?: MergeDictsOptions\n): T | undefined {\n  if (left == null && right == null) {\n    return undefined;\n  }\n  if (left == null || right == null) {\n    return left ?? right;\n  } else if (typeof left !== typeof right) {\n    throw new Error(\n      `Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`\n    );\n  } else if (typeof left === \"string\" && typeof right === \"string\") {\n    return (left + right) as T;\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    return _mergeLists(left, right, options) as T;\n  } else if (typeof left === \"object\" && typeof right === \"object\") {\n    return _mergeDicts(\n      left as Record<string, unknown>,\n      right as Record<string, unknown>,\n      options\n    ) as T;\n  } else if (left === right) {\n    return left;\n  } else {\n    throw new Error(\n      `Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`\n    );\n  }\n}\n\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport abstract class BaseMessageChunk<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType,\n> extends BaseMessage<TStructure, TRole> {\n  abstract concat(chunk: BaseMessageChunk): BaseMessageChunk<TStructure, TRole>;\n\n  static isInstance(obj: unknown): obj is BaseMessageChunk {\n    if (!super.isInstance(obj)) {\n      return false;\n    }\n    // Check if obj is an instance of BaseMessageChunk by traversing the prototype chain\n    let proto = Object.getPrototypeOf(obj);\n    while (proto !== null) {\n      if (proto === BaseMessageChunk.prototype) {\n        return true;\n      }\n      proto = Object.getPrototypeOf(proto);\n    }\n    return false;\n  }\n}\n\nexport type MessageFieldWithRole = {\n  role: MessageType;\n  content: MessageContent;\n  name?: string;\n} & Record<string, unknown>;\n\nexport function _isMessageFieldWithRole(\n  x: BaseMessageLike\n): x is MessageFieldWithRole {\n  return typeof (x as MessageFieldWithRole).role === \"string\";\n}\n\nexport type BaseMessageLike =\n  | BaseMessage\n  | MessageFieldWithRole\n  | [MessageType, MessageContent]\n  | string\n  /**\n   * @deprecated Specifying \"type\" is deprecated and will be removed in 0.4.0.\n   */\n  | ({\n      type: MessageType | \"user\" | \"assistant\" | \"placeholder\";\n    } & BaseMessageFields &\n      Record<string, unknown>)\n  | SerializedConstructor;\n\n/**\n * @deprecated Use {@link BaseMessage.isInstance} instead\n */\nexport function isBaseMessage(\n  messageLike?: unknown\n): messageLike is BaseMessage {\n  return typeof (messageLike as BaseMessage)?._getType === \"function\";\n}\n\n/**\n * @deprecated Use {@link BaseMessageChunk.isInstance} instead\n */\nexport function isBaseMessageChunk(\n  messageLike?: unknown\n): messageLike is BaseMessageChunk {\n  return BaseMessageChunk.isInstance(messageLike);\n}\n"],"mappings":";;;;;;;;;;AAoBA,MAAM,iBAAiB,OAAO,IAAI,oBAAoB;AAqEtD,SAAgB,aACd,cACA,eACgB;AAEhB,KAAI,OAAO,iBAAiB,UAAU;AACpC,MAAI,iBAAiB,GACnB,QAAO;AAET,MAAI,OAAO,kBAAkB,SAC3B,QAAO,eAAe;WACb,MAAM,QAAQ,cAAc,IAAI,cAAc,WAAW,EAClE,QAAO;WAEP,MAAM,QAAQ,cAAc,IAC5B,cAAc,MAAM,MAAM,mBAAmB,EAAE,CAAC,CAEhD,QAAO,CACL;GACE,MAAM;GACN,aAAa;GACb,MAAM;GACP,EACD,GAAG,cACJ;MAED,QAAO,CAAC;GAAE,MAAM;GAAQ,MAAM;GAAc,EAAE,GAAG,cAAc;YAGxD,MAAM,QAAQ,cAAc,CACrC,QACE,YAAY,cAAc,cAAc,IAAI,CAC1C,GAAG,cACH,GAAG,cACJ;UAGC,kBAAkB,GACpB,QAAO;UAEP,MAAM,QAAQ,aAAa,IAC3B,aAAa,MAAM,MAAM,mBAAmB,EAAE,CAAC,CAE/C,QAAO,CACL,GAAG,cACH;EACE,MAAM;EACN,aAAa;EACb,MAAM;EACP,CACF;KAED,QAAO,CAAC,GAAG,cAAc;EAAE,MAAM;EAAQ,MAAM;EAAe,CAAC;;;;;;;;;;AAarE,SAAgB,aACd,MACA,OACiC;AACjC,KAAI,SAAS,WAAW,UAAU,QAChC,QAAO;AAET,QAAO;;AAIT,SAAS,wBAAwB,KAAU,YAA4B;CAErE,SAAS,OAAO,KAAU,cAA2B;AACnD,MAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ,QAAQ,OACrD,QAAO;AAET,MAAI,gBAAgB,YAAY;AAC9B,OAAI,MAAM,QAAQ,IAAI,CACpB,QAAO;AAET,UAAO;;AAGT,MAAI,MAAM,QAAQ,IAAI,CACpB,QAAO,IAAI,KAAK,SAAS,OAAO,MAAM,eAAe,EAAE,CAAC;EAG1D,MAAM,SAAkC,EAAE;AAC1C,OAAK,MAAM,OAAO,OAAO,KAAK,IAAI,CAChC,QAAO,OAAO,OAAO,IAAI,MAAM,eAAe,EAAE;AAElD,SAAO;;AAGT,QAAO,KAAK,UAAU,OAAO,KAAK,EAAE,EAAE,MAAM,EAAE;;;;;;;AAQhD,IAAsB,cAAtB,cAIU,aAEV;CACE,eAAe,CAAC,kBAAkB,WAAW;CAE7C,kBAAkB;CAElB,IAAI,aAAqC;AAEvC,SAAO;GACL,mBAAmB;GACnB,mBAAmB;GACpB;;CAGH,CAAU,kBAAkB;CAI5B;;CAGA;CAEA;CAEA;CAIA;;;;;;;;;;;;CAeA,WAAwB;AACtB,SAAO,KAAK;;;;;;CAOd,UAAuB;AACrB,SAAO,KAAK,UAAU;;CAGxB,YACE,KAGA;EACA,MAAM,SACJ,OAAO,QAAQ,YAAY,MAAM,QAAQ,IAAI,GACxC,EAAE,SAAS,KAAK,GACjB;AACN,MAAI,CAAC,OAAO,kBACV,QAAO,oBAAoB,EAAE;AAE/B,MAAI,CAAC,OAAO,kBACV,QAAO,oBAAoB,EAAE;AAE/B,QAAM,OAAO;AACb,OAAK,OAAO,OAAO;AACnB,MAAI,OAAO,YAAY,UAAa,OAAO,kBAAkB,QAAW;AACtE,QAAK,UAAU,OAAO;AAItB,QAAK,oBAAoB;IACvB,gBAAgB;IAChB,GAAG,OAAO;IACX;aACQ,OAAO,YAAY,QAAW;AACvC,QAAK,UAAU,OAAO,WAAW,EAAE;AACnC,QAAK,oBAAoB,OAAO;SAC3B;AACL,QAAK,UAAU,EAAE;AACjB,QAAK,oBAAoB,OAAO;;AAElC,OAAK,oBAAoB,OAAO;AAChC,OAAK,KAAK,OAAO;;;CAInB,IAAI,OAAe;AACjB,MAAI,OAAO,KAAK,YAAY,SAC1B,QAAO,KAAK;AAEd,MAAI,CAAC,MAAM,QAAQ,KAAK,QAAQ,CAAE,QAAO;AACzC,SAAO,KAAK,QACT,KAAK,MAAM;AACV,OAAI,OAAO,MAAM,SAAU,QAAO;AAClC,OAAI,EAAE,SAAS,OAAQ,QAAO,EAAE;AAChC,UAAO;IACP,CACD,KAAK,GAAG;;CAGb,IAAI,gBAA8C;EAChD,MAAM,SACJ,OAAO,KAAK,YAAY,WACpB,CAAC;GAAE,MAAM;GAAQ,MAAM,KAAK;GAAS,CAAC,GACtC,KAAK;AAUX,SATqB;GACnB;GACA;GACA;GACD,CACiC,QAC/B,QAAQ,SAAS,KAAK,OAAO,EAC9B,OACD;;CAIH,SAAwB;AACtB,SAAO;GACL,MAAM,KAAK,SAAS;GACpB,MAAO,KAAK,QAAQ,CACjB;GACJ;;CAGH,OAAO,UAAU;AACf,SAAO;;CAIT,IAAI,mBAA4C;AAC9C,SAAO;GACL,IAAI,KAAK;GACT,SAAS,KAAK;GACd,MAAM,KAAK;GACX,mBAAmB,KAAK;GACxB,mBAAmB,KAAK;GACzB;;CAGH,OAAO,WAAW,KAAkC;AAClD,SACE,OAAO,QAAQ,YACf,QAAQ,QACR,kBAAkB,OAClB,IAAI,oBAAoB,QACxB,UAAU,IAAI;;CAMlB,UAAU,OAA2B;AACnC,OAAK,KAAK;AAIV,OAAK,UAAU,KAAK;;CAGtB,KAAK,OAAO,eAAe;AAEzB,SAAQ,KAAK,YAAoB,SAAS;;CAI5C,CAAC,OAAO,IAAI,6BAA6B,EAAE,OAAsB;AAC/D,MAAI,UAAU,KACZ,QAAO;EAET,MAAM,YAAY,wBAChB,KAAK,kBACL,KAAK,IAAI,GAAG,MAAM,CACnB;AAED,SAAO,GAAI,KAAK,YAAoB,SAAS,CAAC,GAAG;;CAGnD,kBAAkB,SAA8B,UAAkB;AAChE,SAAO,yBAAyB,MAAM,OAAO;;;AA0BjD,SAAgB,sBACd,OAC2B;AAC3B,QACE,MAAM,QAAQ,MAAM,IACpB,MAAM,OAAO,MAAM,OAAQ,EAAqB,UAAU,SAAS;;;;;;AAQvE,MAAa,4BAA+C;CAC1D;CACA;CACA;CACD;AAoBD,SAAgB,YAKd,MAMA,OAIA,SAEiC;;;;CAIjC,MAAM,aAAa,SAAS,cAAc;AAC1C,KAAI,QAAQ,QAAQ,SAAS,KAC3B;AAEF,KAAI,QAAQ,QAAQ,SAAS,KAC3B,QAAO,QAAQ;CAEjB,MAAM,SAAS,EAAE,GAAG,MAAM;AAC1B,MAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,MAAM,CAC9C,KAAI,OAAO,QAAQ,KACjB,QAAO,OAAO;UACL,SAAS,KAClB;UAEA,OAAO,OAAO,SAAS,OAAO,SAC9B,MAAM,QAAQ,OAAO,KAAK,KAAK,MAAM,QAAQ,MAAM,CAEnD,OAAM,IAAI,MACR,SAAS,IAAI,mEACd;UACQ,OAAO,OAAO,SAAS,SAChC,KAAI,QAAQ,OAEV;UAEA;EAAC;EAAM;EAAQ;EAAkB;EAAiB,CAAC,SAAS,IAAI,EAGhE;MAAI,MACF,QAAO,OAAO;YAEP,WAAW,SAAS,IAAI,CAEjC;KAEA,QAAO,QAAQ;UAER,OAAO,OAAO,SAAS,UAAU;AAC1C,MAAI,WAAW,SAAS,IAAI,CAE1B;AAEF,SAAO,OAAO,OAAO,OAAO;YACnB,OAAO,OAAO,SAAS,YAAY,CAAC,MAAM,QAAQ,OAAO,KAAK,CACvE,QAAO,OAAO,YAAY,OAAO,MAAM,OAAO,QAAQ;UAC7C,MAAM,QAAQ,OAAO,KAAK,CACnC,QAAO,OAAO,YAAY,OAAO,MAAM,OAAO,QAAQ;UAC7C,OAAO,SAAS,MACzB;KAEA,SAAQ,KACN,SAAS,IAAI,wEACd;AAGL,QAAO;;AAGT,SAAgB,YACd,MACA,OACA,SACuB;AACvB,KAAI,QAAQ,QAAQ,SAAS,KAC3B;UACS,QAAQ,QAAQ,SAAS,KAClC,QAAO,QAAQ;MACV;EACL,MAAM,SAAS,CAAC,GAAG,KAAK;AACxB,OAAK,MAAM,QAAQ,MACjB,KACE,OAAO,SAAS,YAChB,SAAS,QACT,WAAW,QACX,OAAO,KAAK,UAAU,UACtB;GACA,MAAM,UAAU,OAAO,WAAW,aAAa;IAC7C,MAAM,WAAW,OAAO,aAAa;IACrC,MAAM,gBACJ,WAAW,YAAY,SAAS,UAAU,KAAK;IACjD,MAAM,WACJ,QAAQ,YAAY,QAAQ,QAAQ,UAAU,OAAO,MAAM;IAC7D,MAAM,sBACJ,EAAE,QAAQ,aACV,CAAC,UAAU,MACX,EAAE,QAAQ,SACV,CAAC,MAAM;AACT,WAAO,YAAY,kBAAkB,YAAY;KACjD;AACF,OACE,YAAY,MACZ,OAAO,OAAO,aAAa,YAC3B,OAAO,aAAa,KAEpB,QAAO,WAAW,YAChB,OAAO,UACP,MACA,QACD;OAED,QAAO,KAAK,KAAK;aAGnB,OAAO,SAAS,YAChB,SAAS,QACT,UAAU,QACV,KAAK,SAAS,GAGd;MAEA,QAAO,KAAK,KAAK;AAGrB,SAAO;;;AAKX,SAAgB,UACd,MACA,OACA,SACe;AACf,KAAI,QAAQ,QAAQ,SAAS,KAC3B;AAEF,KAAI,QAAQ,QAAQ,SAAS,KAC3B,QAAO,QAAQ;UACN,OAAO,SAAS,OAAO,MAChC,OAAM,IAAI,MACR,kDAAkD,OAAO,KAAK,UAAU,OAAO,QAChF;UACQ,OAAO,SAAS,YAAY,OAAO,UAAU,SACtD,QAAQ,OAAO;UACN,MAAM,QAAQ,KAAK,IAAI,MAAM,QAAQ,MAAM,CACpD,QAAO,YAAY,MAAM,OAAO,QAAQ;UAC/B,OAAO,SAAS,YAAY,OAAO,UAAU,SACtD,QAAO,YACL,MACA,OACA,QACD;UACQ,SAAS,MAClB,QAAO;KAEP,OAAM,IAAI,MACR,mDAAmD,KAAK,UAAU,QACnE;;;;;;;;;AAWL,IAAsB,mBAAtB,MAAsB,yBAGZ,YAA+B;CAGvC,OAAO,WAAW,KAAuC;AACvD,MAAI,CAAC,MAAM,WAAW,IAAI,CACxB,QAAO;EAGT,IAAI,QAAQ,OAAO,eAAe,IAAI;AACtC,SAAO,UAAU,MAAM;AACrB,OAAI,UAAU,iBAAiB,UAC7B,QAAO;AAET,WAAQ,OAAO,eAAe,MAAM;;AAEtC,SAAO;;;AAUX,SAAgB,wBACd,GAC2B;AAC3B,QAAO,OAAQ,EAA2B,SAAS;;;;;AAoBrD,SAAgB,cACd,aAC4B;AAC5B,QAAO,OAAQ,aAA6B,aAAa;;;;;AAM3D,SAAgB,mBACd,aACiC;AACjC,QAAO,iBAAiB,WAAW,YAAY"}