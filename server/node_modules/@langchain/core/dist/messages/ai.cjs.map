{"version":3,"file":"ai.cjs","names":["BaseMessage","defaultToolCallParser","getTranslator","BaseMessageChunk","collapseToolCallChunks","mergeContent","_mergeDicts","mergeResponseMetadata","_mergeLists","mergeUsageMetadata"],"sources":["../../src/messages/ai.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  _mergeLists,\n  BaseMessageFields,\n} from \"./base.js\";\nimport { getTranslator } from \"./block_translators/index.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport {\n  $InferMessageContent,\n  $InferMessageProperty,\n  $InferToolCalls,\n  MessageStructure,\n} from \"./message.js\";\nimport { mergeResponseMetadata, mergeUsageMetadata } from \"./metadata.js\";\nimport {\n  InvalidToolCall,\n  ToolCallChunk,\n  defaultToolCallParser,\n} from \"./tool.js\";\nimport { collapseToolCallChunks, Constructor } from \"./utils.js\";\n\nexport interface AIMessageFields<\n  TStructure extends MessageStructure = MessageStructure,\n> extends BaseMessageFields<TStructure, \"ai\"> {\n  tool_calls?: $InferToolCalls<TStructure>[];\n  invalid_tool_calls?: InvalidToolCall[];\n  usage_metadata?: $InferMessageProperty<TStructure, \"ai\", \"usage_metadata\">;\n}\n\nexport class AIMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"ai\">\n  implements AIMessageFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: $InferToolCalls<TStructure>[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  usage_metadata?: AIMessageFields<TStructure>[\"usage_metadata\"];\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n    };\n  }\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>\n  ) {\n    let initParams: AIMessageFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        additional_kwargs: {},\n      };\n    } else {\n      initParams = fields;\n      const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n      const toolCalls = initParams.tool_calls;\n      if (\n        !(rawToolCalls == null) &&\n        rawToolCalls.length > 0 &&\n        (toolCalls === undefined || toolCalls.length === 0)\n      ) {\n        console.warn(\n          [\n            \"New LangChain packages are available that more efficiently handle\",\n            \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n            \"message tool calls. e.g., `pnpm install @langchain/anthropic`,\",\n            \"pnpm install @langchain/openai`, etc.\",\n          ].join(\" \")\n        );\n      }\n      try {\n        if (!(rawToolCalls == null) && toolCalls === undefined) {\n          const [parsedToolCalls, invalidToolCalls] =\n            defaultToolCallParser(rawToolCalls);\n          initParams.tool_calls =\n            (parsedToolCalls as $InferToolCalls<TStructure>[]) ?? [];\n          initParams.invalid_tool_calls = invalidToolCalls ?? [];\n        } else {\n          initParams.tool_calls = initParams.tool_calls ?? [];\n          initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n        }\n      } catch {\n        // Do nothing if parsing fails\n        initParams.tool_calls = [] as $InferToolCalls<TStructure>[];\n        initParams.invalid_tool_calls = [];\n      }\n\n      // Convert content to content blocks if output version is v1\n      if (\n        initParams.response_metadata !== undefined &&\n        \"output_version\" in initParams.response_metadata &&\n        initParams.response_metadata.output_version === \"v1\"\n      ) {\n        initParams.contentBlocks =\n          initParams.content as Array<ContentBlock.Standard>;\n        initParams.content = undefined;\n      }\n\n      if (initParams.contentBlocks !== undefined) {\n        // Add constructor tool calls as content blocks\n        if (initParams.tool_calls) {\n          initParams.contentBlocks.push(\n            ...initParams.tool_calls.map((toolCall) => ({\n              type: \"tool_call\" as const,\n              id: toolCall.id,\n              name: toolCall.name,\n              args: toolCall.args,\n            }))\n          );\n        }\n        // Add content block tool calls that aren't in the constructor tool calls\n        const missingToolCalls = initParams.contentBlocks\n          .filter<ContentBlock.Tools.ToolCall>(\n            (block): block is ContentBlock.Tools.ToolCall =>\n              block.type === \"tool_call\"\n          )\n          .filter(\n            (block) =>\n              !initParams.tool_calls?.some(\n                (toolCall) =>\n                  toolCall.id === block.id && toolCall.name === block.name\n              )\n          );\n        if (missingToolCalls.length > 0) {\n          initParams.tool_calls = missingToolCalls.map((block) => ({\n            type: \"tool_call\" as const,\n            id: block.id!,\n            name: block.name,\n            args: block.args as Record<string, unknown>,\n          })) as $InferToolCalls<TStructure>[];\n        }\n      }\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    if (typeof initParams !== \"string\") {\n      this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n      this.invalid_tool_calls =\n        initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    }\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  static lc_name() {\n    return \"AIMessage\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this as AIMessage);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      const missingToolCalls = this.tool_calls.filter(\n        (block) =>\n          !blocks.some((b) => b.id === block.id && b.name === block.name)\n      );\n      blocks.push(\n        ...(missingToolCalls.map((block) => ({\n          type: \"tool_call\" as const,\n          id: block.id,\n          name: block.name,\n          args: block.args,\n        })) as ContentBlock.Tools.ToolCall[])\n      );\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  /**\n   * Type guard to check if an object is an AIMessage.\n   * Preserves the MessageStructure type parameter when called with a typed BaseMessage.\n   * @overload When called with a typed BaseMessage, preserves the TStructure type\n   */\n  static isInstance<T extends MessageStructure>(\n    obj: BaseMessage<T>\n  ): obj is BaseMessage<T> & AIMessage<T>;\n  /**\n   * Type guard to check if an object is an AIMessage.\n   * @overload When called with unknown, returns base AIMessage type\n   */\n  static isInstance(obj: unknown): obj is AIMessage;\n  static isInstance<T extends MessageStructure = MessageStructure>(\n    obj: BaseMessage<T> | unknown\n  ): obj is AIMessage<T> {\n    return super.isInstance(obj) && (obj as { type: string }).type === \"ai\";\n  }\n}\n\n/**\n * @deprecated Use {@link AIMessage.isInstance} instead\n */\nexport function isAIMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is AIMessage<TStructure> {\n  return x._getType() === \"ai\";\n}\n\n/**\n * @deprecated Use {@link AIMessageChunk.isInstance} instead\n */\nexport function isAIMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is AIMessageChunk<TStructure> {\n  return x._getType() === \"ai\";\n}\n\nexport type AIMessageChunkFields<\n  TStructure extends MessageStructure = MessageStructure,\n> = AIMessageFields<TStructure> & {\n  tool_call_chunks?: ToolCallChunk[];\n};\n\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk<\n  TStructure extends MessageStructure = MessageStructure,\n>\n  extends BaseMessageChunk<TStructure, \"ai\">\n  implements AIMessage<TStructure>, AIMessageChunkFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: $InferToolCalls<TStructure>[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  tool_call_chunks?: ToolCallChunk[] = [];\n\n  usage_metadata?: AIMessageChunkFields<TStructure>[\"usage_metadata\"];\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>\n  ) {\n    let initParams: AIMessageChunkFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n      };\n    } else if (\n      fields.tool_call_chunks === undefined ||\n      fields.tool_call_chunks.length === 0\n    ) {\n      initParams = {\n        ...fields,\n        tool_calls: fields.tool_calls ?? [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    } else {\n      const collapsed = collapseToolCallChunks(fields.tool_call_chunks ?? []);\n      initParams = {\n        ...fields,\n        tool_call_chunks: collapsed.tool_call_chunks,\n        tool_calls: collapsed.tool_calls as $InferToolCalls<TStructure>[],\n        invalid_tool_calls: collapsed.invalid_tool_calls,\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    this.tool_call_chunks =\n      initParams.tool_call_chunks ?? this.tool_call_chunks;\n    this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n    this.invalid_tool_calls =\n      initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n      tool_call_chunks: \"tool_call_chunks\",\n    };\n  }\n\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this as AIMessage);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      if (typeof this.content !== \"string\") {\n        const contentToolCalls = this.content\n          .filter((block) => block.type === \"tool_call\")\n          .map((block) => block.id);\n        for (const toolCall of this.tool_calls) {\n          if (toolCall.id && !contentToolCalls.includes(toolCall.id)) {\n            blocks.push({\n              ...toolCall,\n              type: \"tool_call\",\n              id: toolCall.id,\n              name: toolCall.name,\n              args: toolCall.args,\n            });\n          }\n        }\n      }\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      tool_call_chunks: this.tool_call_chunks,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  concat(chunk: AIMessageChunk<TStructure>) {\n    const combinedFields: AIMessageChunkFields = {\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: mergeResponseMetadata(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      tool_call_chunks: [],\n      tool_calls: [],\n      id: this.id ?? chunk.id,\n    };\n    if (\n      this.tool_call_chunks !== undefined ||\n      chunk.tool_call_chunks !== undefined\n    ) {\n      const rawToolCalls = _mergeLists(\n        this.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[],\n        chunk.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[]\n      );\n      if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n        combinedFields.tool_call_chunks = rawToolCalls;\n      }\n    }\n    if (this.tool_calls !== undefined || chunk.tool_calls !== undefined) {\n      const rawToolCalls = _mergeLists(\n        this.tool_calls as ContentBlock.Tools.ToolCall[],\n        chunk.tool_calls as ContentBlock.Tools.ToolCall[]\n      );\n      if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n        combinedFields.tool_calls =\n          rawToolCalls as $InferToolCalls<TStructure>[];\n      }\n    }\n    if (\n      this.usage_metadata !== undefined ||\n      chunk.usage_metadata !== undefined\n    ) {\n      combinedFields.usage_metadata = mergeUsageMetadata(\n        this.usage_metadata,\n        chunk.usage_metadata\n      );\n    }\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls(combinedFields);\n  }\n\n  /**\n   * Type guard to check if an object is an AIMessageChunk.\n   * Preserves the MessageStructure type parameter when called with a typed BaseMessage.\n   * @overload When called with a typed BaseMessage, preserves the TStructure type\n   */\n  static isInstance<T extends MessageStructure>(\n    obj: BaseMessage<T>\n  ): obj is BaseMessage<T> & AIMessageChunk<T>;\n  /**\n   * Type guard to check if an object is an AIMessageChunk.\n   * @overload When called with unknown, returns base AIMessageChunk type\n   */\n  static isInstance(obj: unknown): obj is AIMessageChunk;\n  static isInstance<T extends MessageStructure = MessageStructure>(\n    obj: BaseMessage<T> | unknown\n  ): obj is AIMessageChunk<T> {\n    return super.isInstance(obj) && (obj as { type: string }).type === \"ai\";\n  }\n}\n"],"mappings":"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"}