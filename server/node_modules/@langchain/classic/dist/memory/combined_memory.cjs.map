{"version":3,"file":"combined_memory.cjs","names":["BaseChatMemory"],"sources":["../../src/memory/combined_memory.ts"],"sourcesContent":["import {\n  InputValues,\n  MemoryVariables,\n  BaseMemory,\n  OutputValues,\n} from \"@langchain/core/memory\";\nimport { BaseChatMemory, BaseChatMemoryInput } from \"./chat_memory.js\";\n\n/**\n * Interface that defines the shape of the input object that the\n * CombinedMemory constructor accepts. It extends the BaseChatMemoryInput\n * interface and adds additional properties.\n */\nexport interface CombinedMemoryInput extends BaseChatMemoryInput {\n  memories: BaseMemory[];\n  humanPrefix?: string;\n  aiPrefix?: string;\n  memoryKey?: string;\n}\n\n/**\n * Class that manages and manipulates previous chat messages. It extends\n * from the BaseChatMemory class and implements the CombinedMemoryInput\n * interface.\n */\nexport class CombinedMemory\n  extends BaseChatMemory\n  implements CombinedMemoryInput\n{\n  humanPrefix = \"Human\";\n\n  aiPrefix = \"AI\";\n\n  memoryKey = \"history\";\n\n  memories: BaseMemory[] = [];\n\n  constructor(fields?: CombinedMemoryInput) {\n    super({\n      chatHistory: fields?.chatHistory,\n      returnMessages: fields?.returnMessages ?? false,\n      inputKey: fields?.inputKey,\n      outputKey: fields?.outputKey,\n    });\n\n    this.memories = fields?.memories ?? this.memories;\n    this.humanPrefix = fields?.humanPrefix ?? this.humanPrefix;\n    this.aiPrefix = fields?.aiPrefix ?? this.aiPrefix;\n    this.memoryKey = fields?.memoryKey ?? this.memoryKey;\n    this.checkRepeatedMemoryVariable();\n    this.checkInputKey();\n  }\n\n  /**\n   * Checks for repeated memory variables across all memory objects. Throws\n   * an error if any are found.\n   */\n  checkRepeatedMemoryVariable() {\n    const allVariables: string[] = [];\n    for (const memory of this.memories) {\n      const overlap = allVariables.filter((x) => memory.memoryKeys.includes(x));\n      if (overlap.length > 0) {\n        throw new Error(\n          `The same variables ${[\n            ...overlap,\n          ]} are found in multiple memory objects, which is not allowed by CombinedMemory.`\n        );\n      }\n      allVariables.push(...memory.memoryKeys);\n    }\n  }\n\n  /**\n   * Checks if input keys are set for all memory objects. Logs a warning if\n   * any are missing.\n   */\n  checkInputKey() {\n    for (const memory of this.memories) {\n      if (\n        (memory as BaseChatMemory).chatHistory !== undefined &&\n        (memory as BaseChatMemory).inputKey === undefined\n      ) {\n        console.warn(\n          `When using CombinedMemory, input keys should be set so the input is known. Was not set on ${memory}.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Loads memory variables from all memory objects.\n   * @param inputValues Input values to load memory variables from.\n   * @returns Promise that resolves with an object containing the loaded memory variables.\n   */\n  async loadMemoryVariables(\n    inputValues: InputValues\n  ): Promise<MemoryVariables> {\n    let memoryData: Record<string, unknown> = {};\n\n    for (const memory of this.memories) {\n      const data = await memory.loadMemoryVariables(inputValues);\n      memoryData = {\n        ...memoryData,\n        ...data,\n      };\n    }\n    return memoryData;\n  }\n\n  /**\n   * Saves the context to all memory objects.\n   * @param inputValues Input values to save.\n   * @param outputValues Output values to save.\n   * @returns Promise that resolves when the context has been saved to all memory objects.\n   */\n  async saveContext(inputValues: InputValues, outputValues: OutputValues) {\n    for (const memory of this.memories) {\n      await memory.saveContext(inputValues, outputValues);\n    }\n  }\n\n  /**\n   * Clears all memory objects.\n   * @returns Promise that resolves when all memory objects have been cleared.\n   */\n  async clear() {\n    for (const memory of this.memories) {\n      if (typeof (memory as BaseChatMemory).clear === \"function\") {\n        await (memory as BaseChatMemory).clear();\n      }\n    }\n  }\n\n  get memoryKeys() {\n    const memoryKeys: string[] = [];\n    for (const memory of this.memories) {\n      memoryKeys.push(...memory.memoryKeys);\n    }\n    return memoryKeys;\n  }\n}\n"],"mappings":";;;;;;;;AAyBA,IAAa,iBAAb,cACUA,0CAEV;CACE,cAAc;CAEd,WAAW;CAEX,YAAY;CAEZ,WAAyB,EAAE;CAE3B,YAAY,QAA8B;AACxC,QAAM;GACJ,aAAa,QAAQ;GACrB,gBAAgB,QAAQ,kBAAkB;GAC1C,UAAU,QAAQ;GAClB,WAAW,QAAQ;GACpB,CAAC;AAEF,OAAK,WAAW,QAAQ,YAAY,KAAK;AACzC,OAAK,cAAc,QAAQ,eAAe,KAAK;AAC/C,OAAK,WAAW,QAAQ,YAAY,KAAK;AACzC,OAAK,YAAY,QAAQ,aAAa,KAAK;AAC3C,OAAK,6BAA6B;AAClC,OAAK,eAAe;;;;;;CAOtB,8BAA8B;EAC5B,MAAM,eAAyB,EAAE;AACjC,OAAK,MAAM,UAAU,KAAK,UAAU;GAClC,MAAM,UAAU,aAAa,QAAQ,MAAM,OAAO,WAAW,SAAS,EAAE,CAAC;AACzE,OAAI,QAAQ,SAAS,EACnB,OAAM,IAAI,MACR,sBAAsB,CACpB,GAAG,QACJ,CAAC,gFACH;AAEH,gBAAa,KAAK,GAAG,OAAO,WAAW;;;;;;;CAQ3C,gBAAgB;AACd,OAAK,MAAM,UAAU,KAAK,SACxB,KACG,OAA0B,gBAAgB,UAC1C,OAA0B,aAAa,OAExC,SAAQ,KACN,6FAA6F,OAAO,GACrG;;;;;;;CAUP,MAAM,oBACJ,aAC0B;EAC1B,IAAI,aAAsC,EAAE;AAE5C,OAAK,MAAM,UAAU,KAAK,UAAU;GAClC,MAAM,OAAO,MAAM,OAAO,oBAAoB,YAAY;AAC1D,gBAAa;IACX,GAAG;IACH,GAAG;IACJ;;AAEH,SAAO;;;;;;;;CAST,MAAM,YAAY,aAA0B,cAA4B;AACtE,OAAK,MAAM,UAAU,KAAK,SACxB,OAAM,OAAO,YAAY,aAAa,aAAa;;;;;;CAQvD,MAAM,QAAQ;AACZ,OAAK,MAAM,UAAU,KAAK,SACxB,KAAI,OAAQ,OAA0B,UAAU,WAC9C,OAAO,OAA0B,OAAO;;CAK9C,IAAI,aAAa;EACf,MAAM,aAAuB,EAAE;AAC/B,OAAK,MAAM,UAAU,KAAK,SACxB,YAAW,KAAK,GAAG,OAAO,WAAW;AAEvC,SAAO"}