{"version":3,"file":"base.js","names":[],"sources":["../../src/chains/base.ts"],"sourcesContent":["import { BaseMemory } from \"@langchain/core/memory\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { RUN_KEY } from \"@langchain/core/outputs\";\nimport {\n  CallbackManagerForChainRun,\n  CallbackManager,\n  Callbacks,\n  parseCallbackConfigArg,\n} from \"@langchain/core/callbacks/manager\";\nimport { ensureConfig, type RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  BaseLangChain,\n  BaseLangChainParams,\n} from \"@langchain/core/language_models/base\";\nimport { SerializedBaseChain } from \"./serde.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type LoadValues = Record<string, any>;\n\nexport interface ChainInputs extends BaseLangChainParams {\n  memory?: BaseMemory;\n\n  /**\n   * @deprecated Use `callbacks` instead\n   */\n  callbackManager?: CallbackManager;\n}\n\n/**\n * Base interface that all chains must implement.\n */\nexport abstract class BaseChain<\n  RunInput extends ChainValues = ChainValues,\n  RunOutput extends ChainValues = ChainValues,\n>\n  extends BaseLangChain<RunInput, RunOutput>\n  implements ChainInputs\n{\n  declare memory?: BaseMemory;\n\n  get lc_namespace(): string[] {\n    return [\"langchain\", \"chains\", this._chainType()];\n  }\n\n  constructor(\n    fields?: BaseMemory | ChainInputs,\n    /** @deprecated */\n    verbose?: boolean,\n    /** @deprecated */\n    callbacks?: Callbacks\n  ) {\n    if (\n      arguments.length === 1 &&\n      typeof fields === \"object\" &&\n      !(\"saveContext\" in fields)\n    ) {\n      // fields is not a BaseMemory\n      const { memory, callbackManager, ...rest } = fields;\n      super({ ...rest, callbacks: callbackManager ?? rest.callbacks });\n      this.memory = memory;\n    } else {\n      // fields is a BaseMemory\n      super({ verbose, callbacks });\n      this.memory = fields as BaseMemory;\n    }\n  }\n\n  /** @ignore */\n  _selectMemoryInputs(values: ChainValues): ChainValues {\n    const valuesForMemory = { ...values };\n    if (\"signal\" in valuesForMemory) {\n      delete valuesForMemory.signal;\n    }\n    if (\"timeout\" in valuesForMemory) {\n      delete valuesForMemory.timeout;\n    }\n    return valuesForMemory;\n  }\n\n  /**\n   * Invoke the chain with the provided input and returns the output.\n   * @param input Input values for the chain run.\n   * @param config Optional configuration for the Runnable.\n   * @returns Promise that resolves with the output of the chain run.\n   */\n  async invoke(input: RunInput, options?: RunnableConfig): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const fullValues = await this._formatValues(input);\n    const callbackManager_ = await CallbackManager.configure(\n      config?.callbacks,\n      this.callbacks,\n      config?.tags,\n      this.tags,\n      config?.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      fullValues,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    let outputValues: RunOutput;\n    try {\n      if (fullValues.signal) {\n        let listener: (() => void) | undefined;\n        outputValues = (await Promise.race([\n          this._call(fullValues as RunInput, runManager, config),\n          new Promise<never>((_, reject) => {\n            listener = () => {\n              reject(new Error(\"AbortError\"));\n            };\n            fullValues.signal?.addEventListener(\"abort\", listener, {\n              once: true,\n            });\n          }),\n        ]).finally(() => {\n          if (fullValues.signal && listener) {\n            fullValues.signal.removeEventListener(\"abort\", listener);\n          }\n        })) as RunOutput;\n      } else {\n        outputValues = await this._call(\n          fullValues as RunInput,\n          runManager,\n          config\n        );\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    if (!(this.memory == null)) {\n      await this.memory.saveContext(\n        this._selectMemoryInputs(input),\n        outputValues\n      );\n    }\n    await runManager?.handleChainEnd(outputValues);\n    // add the runManager's currentRunId to the outputValues\n    Object.defineProperty(outputValues, RUN_KEY, {\n      value: runManager ? { runId: runManager?.runId } : undefined,\n      configurable: true,\n    });\n    return outputValues;\n  }\n\n  private _validateOutputs(outputs: Record<string, unknown>): void {\n    const missingKeys = this.outputKeys.filter((k) => !(k in outputs));\n    if (missingKeys.length) {\n      throw new Error(\n        `Missing output keys: ${missingKeys.join(\n          \", \"\n        )} from chain ${this._chainType()}`\n      );\n    }\n  }\n\n  async prepOutputs(\n    inputs: Record<string, unknown>,\n    outputs: Record<string, unknown>,\n    returnOnlyOutputs = false\n  ) {\n    this._validateOutputs(outputs);\n    if (this.memory) {\n      await this.memory.saveContext(inputs, outputs);\n    }\n    if (returnOnlyOutputs) {\n      return outputs;\n    }\n    return { ...inputs, ...outputs };\n  }\n\n  /**\n   * Run the core logic of this chain and return the output\n   */\n  abstract _call(\n    values: RunInput,\n    runManager?: CallbackManagerForChainRun,\n    config?: RunnableConfig\n  ): Promise<RunOutput>;\n\n  /**\n   * Return the string type key uniquely identifying this class of chain.\n   */\n  abstract _chainType(): string;\n\n  /**\n   * Return a json-like object representing this chain.\n   */\n  serialize(): SerializedBaseChain {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  abstract get inputKeys(): string[];\n\n  abstract get outputKeys(): string[];\n\n  /** @deprecated Use .invoke() instead. Will be removed in 0.2.0. */\n  async run(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    config?: Callbacks | RunnableConfig\n  ): Promise<string> {\n    const inputKeys = this.inputKeys.filter(\n      (k) => !this.memory?.memoryKeys.includes(k)\n    );\n    const isKeylessInput = inputKeys.length <= 1;\n    if (!isKeylessInput) {\n      throw new Error(\n        `Chain ${this._chainType()} expects multiple inputs, cannot use 'run' `\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const values = inputKeys.length ? { [inputKeys[0]]: input } : ({} as any);\n    const returnValues = await this.call(values, config);\n    const keys = Object.keys(returnValues);\n\n    if (keys.length === 1) {\n      return returnValues[keys[0]];\n    }\n    throw new Error(\n      \"return values have multiple keys, `run` only supported when one key currently\"\n    );\n  }\n\n  protected async _formatValues(\n    values: ChainValues & { signal?: AbortSignal; timeout?: number }\n  ) {\n    const fullValues = { ...values } as typeof values;\n    if (fullValues.timeout && !fullValues.signal) {\n      fullValues.signal = AbortSignal.timeout(fullValues.timeout);\n      delete fullValues.timeout;\n    }\n    if (!(this.memory == null)) {\n      const newValues = await this.memory.loadMemoryVariables(\n        this._selectMemoryInputs(values)\n      );\n      for (const [key, value] of Object.entries(newValues)) {\n        fullValues[key] = value;\n      }\n    }\n    return fullValues;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n   *\n   * Run the core logic of this chain and add to output if desired.\n   *\n   * Wraps _call and handles memory.\n   */\n  async call(\n    values: ChainValues & { signal?: AbortSignal; timeout?: number },\n    config?: Callbacks | RunnableConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<RunOutput> {\n    const parsedConfig = { tags, ...parseCallbackConfigArg(config) };\n    return this.invoke(values as RunInput, parsedConfig);\n  }\n\n  /**\n   * @deprecated Use .batch() instead. Will be removed in 0.2.0.\n   *\n   * Call the chain on all inputs in the list\n   */\n  async apply(\n    inputs: RunInput[],\n    config?: (Callbacks | RunnableConfig)[]\n  ): Promise<RunOutput[]> {\n    return Promise.all(\n      inputs.map(async (i, idx) => this.call(i, config?.[idx]))\n    );\n  }\n\n  /**\n   * Load a chain from a json-like object describing it.\n   */\n  static async deserialize(\n    data: SerializedBaseChain,\n    values: LoadValues = {}\n  ): Promise<BaseChain> {\n    switch (data._type) {\n      case \"llm_chain\": {\n        const { LLMChain } = await import(\"./llm_chain.js\");\n        return LLMChain.deserialize(data);\n      }\n      case \"sequential_chain\": {\n        const { SequentialChain } = await import(\"./sequential_chain.js\");\n        return SequentialChain.deserialize(data);\n      }\n      case \"simple_sequential_chain\": {\n        const { SimpleSequentialChain } = await import(\"./sequential_chain.js\");\n        return SimpleSequentialChain.deserialize(data);\n      }\n      case \"stuff_documents_chain\": {\n        const { StuffDocumentsChain } = await import(\"./combine_docs_chain.js\");\n        return StuffDocumentsChain.deserialize(data);\n      }\n      case \"map_reduce_documents_chain\": {\n        const { MapReduceDocumentsChain } =\n          await import(\"./combine_docs_chain.js\");\n        return MapReduceDocumentsChain.deserialize(data);\n      }\n      case \"refine_documents_chain\": {\n        const { RefineDocumentsChain } =\n          await import(\"./combine_docs_chain.js\");\n        return RefineDocumentsChain.deserialize(data);\n      }\n      case \"vector_db_qa\": {\n        const { VectorDBQAChain } = await import(\"./vector_db_qa.js\");\n        return VectorDBQAChain.deserialize(data, values);\n      }\n      case \"api_chain\": {\n        const { APIChain } = await import(\"./api/api_chain.js\");\n        return APIChain.deserialize(data);\n      }\n      default:\n        throw new Error(\n          `Invalid prompt type in config: ${\n            (data as SerializedBaseChain)._type\n          }`\n        );\n    }\n  }\n}\n"],"mappings":"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"}