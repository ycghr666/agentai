{"version":3,"file":"combine_docs_chain.cjs","names":["BaseChain","LLMChain","PromptTemplate"],"sources":["../../src/chains/combine_docs_chain.ts"],"sourcesContent":["import { Document } from \"@langchain/core/documents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport { BasePromptTemplate, PromptTemplate } from \"@langchain/core/prompts\";\nimport type {\n  SerializedStuffDocumentsChain,\n  SerializedMapReduceDocumentsChain,\n  SerializedRefineDocumentsChain,\n} from \"./serde.js\";\nimport { BaseChain, ChainInputs } from \"./base.js\";\nimport { LLMChain } from \"./llm_chain.js\";\n\n/**\n * Interface for the input properties of the StuffDocumentsChain class.\n */\nexport interface StuffDocumentsChainInput extends ChainInputs {\n  /** LLM Wrapper to use after formatting documents */\n  llmChain: LLMChain;\n  inputKey?: string;\n  /** Variable name in the LLM chain to put the documents in */\n  documentVariableName?: string;\n}\n\n/**\n * Chain that combines documents by stuffing into context.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class StuffDocumentsChain\n  extends BaseChain\n  implements StuffDocumentsChainInput\n{\n  static lc_name() {\n    return \"StuffDocumentsChain\";\n  }\n\n  llmChain: LLMChain;\n\n  inputKey = \"input_documents\";\n\n  documentVariableName = \"context\";\n\n  get inputKeys() {\n    return [this.inputKey, ...this.llmChain.inputKeys].filter(\n      (key) => key !== this.documentVariableName\n    );\n  }\n\n  get outputKeys() {\n    return this.llmChain.outputKeys;\n  }\n\n  constructor(fields: StuffDocumentsChainInput) {\n    super(fields);\n    this.llmChain = fields.llmChain;\n    this.documentVariableName =\n      fields.documentVariableName ?? this.documentVariableName;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n  }\n\n  /** @ignore */\n  _prepInputs(values: ChainValues): ChainValues {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const { [this.inputKey]: docs, ...rest } = values;\n    const texts = (docs as Document[]).map(({ pageContent }) => pageContent);\n    const text = texts.join(\"\\n\\n\");\n    return {\n      ...rest,\n      [this.documentVariableName]: text,\n    };\n  }\n\n  /** @ignore */\n  async _call(\n    values: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    const result = await this.llmChain.call(\n      this._prepInputs(values),\n      runManager?.getChild(\"combine_documents\")\n    );\n    return result;\n  }\n\n  _chainType() {\n    return \"stuff_documents_chain\" as const;\n  }\n\n  static async deserialize(data: SerializedStuffDocumentsChain) {\n    if (!data.llm_chain) {\n      throw new Error(\"Missing llm_chain\");\n    }\n\n    return new StuffDocumentsChain({\n      llmChain: await LLMChain.deserialize(data.llm_chain),\n    });\n  }\n\n  serialize(): SerializedStuffDocumentsChain {\n    return {\n      _type: this._chainType(),\n      llm_chain: this.llmChain.serialize(),\n    };\n  }\n}\n\n/**\n * Interface for the input properties of the MapReduceDocumentsChain\n * class.\n */\nexport interface MapReduceDocumentsChainInput extends StuffDocumentsChainInput {\n  /** The maximum number of tokens before requiring to do the reduction */\n  maxTokens?: number;\n  /** The maximum number of iterations to run through the map */\n  maxIterations?: number;\n  /** Ensures that the map step is taken regardless of max tokens */\n  ensureMapStep?: boolean;\n  /** Chain to use to combine results of applying llm_chain to documents. */\n  combineDocumentChain: StuffDocumentsChain;\n  /** Return the results of the map steps in the output. */\n  returnIntermediateSteps?: boolean;\n}\n\n/**\n * Combine documents by mapping a chain over them, then combining results.\n * @augments BaseChain\n * @augments StuffDocumentsChainInput\n */\nexport class MapReduceDocumentsChain\n  extends BaseChain\n  implements MapReduceDocumentsChainInput\n{\n  static lc_name() {\n    return \"MapReduceDocumentsChain\";\n  }\n\n  llmChain: LLMChain;\n\n  inputKey = \"input_documents\";\n\n  documentVariableName = \"context\";\n\n  returnIntermediateSteps = false;\n\n  get inputKeys() {\n    return [this.inputKey, ...this.combineDocumentChain.inputKeys];\n  }\n\n  get outputKeys() {\n    return this.combineDocumentChain.outputKeys;\n  }\n\n  maxTokens = 3000;\n\n  maxIterations = 10;\n\n  ensureMapStep = false;\n\n  combineDocumentChain: StuffDocumentsChain;\n\n  constructor(fields: MapReduceDocumentsChainInput) {\n    super(fields);\n    this.llmChain = fields.llmChain;\n    this.combineDocumentChain = fields.combineDocumentChain;\n    this.documentVariableName =\n      fields.documentVariableName ?? this.documentVariableName;\n    this.ensureMapStep = fields.ensureMapStep ?? this.ensureMapStep;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n    this.maxTokens = fields.maxTokens ?? this.maxTokens;\n    this.maxIterations = fields.maxIterations ?? this.maxIterations;\n    this.returnIntermediateSteps = fields.returnIntermediateSteps ?? false;\n  }\n\n  /** @ignore */\n  async _call(\n    values: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const { [this.inputKey]: docs, ...rest } = values;\n\n    let currentDocs = docs as Document[];\n    let intermediateSteps: string[] = [];\n\n    // For each iteration, we'll use the `llmChain` to get a new result\n    for (let i = 0; i < this.maxIterations; i += 1) {\n      const inputs = currentDocs.map((d) => ({\n        [this.documentVariableName]: d.pageContent,\n        ...rest,\n      }));\n\n      const canSkipMapStep = i !== 0 || !this.ensureMapStep;\n      if (canSkipMapStep) {\n        // Calculate the total tokens required in the input\n        const formatted =\n          await this.combineDocumentChain.llmChain.prompt.format(\n            this.combineDocumentChain._prepInputs({\n              [this.combineDocumentChain.inputKey]: currentDocs,\n              ...rest,\n            })\n          );\n        const length =\n          await this.combineDocumentChain.llmChain._getNumTokens(formatted);\n\n        const withinTokenLimit = length < this.maxTokens;\n        // If we can skip the map step, and we're within the token limit, we don't\n        // need to run the map step, so just break out of the loop.\n        if (withinTokenLimit) {\n          break;\n        }\n      }\n\n      const results = await this.llmChain.apply(\n        inputs,\n        // If we have a runManager, then we need to create a child for each input\n        // so that we can track the progress of each input.\n        runManager\n          ? Array.from({ length: inputs.length }, (_, i) =>\n              runManager.getChild(`map_${i + 1}`)\n            )\n          : undefined\n      );\n      const { outputKey } = this.llmChain;\n\n      // If the flag is set, then concat that to the intermediate steps\n      if (this.returnIntermediateSteps) {\n        intermediateSteps = intermediateSteps.concat(\n          results.map((r) => r[outputKey])\n        );\n      }\n\n      currentDocs = results.map((r) => ({\n        pageContent: r[outputKey],\n        metadata: {},\n      }));\n    }\n\n    // Now, with the final result of all the inputs from the `llmChain`, we can\n    // run the `combineDocumentChain` over them.\n    const newInputs = {\n      [this.combineDocumentChain.inputKey]: currentDocs,\n      ...rest,\n    };\n    const result = await this.combineDocumentChain.call(\n      newInputs,\n      runManager?.getChild(\"combine_documents\")\n    );\n\n    // Return the intermediate steps results if the flag is set\n    if (this.returnIntermediateSteps) {\n      return { ...result, intermediateSteps };\n    }\n    return result;\n  }\n\n  _chainType() {\n    return \"map_reduce_documents_chain\" as const;\n  }\n\n  static async deserialize(data: SerializedMapReduceDocumentsChain) {\n    if (!data.llm_chain) {\n      throw new Error(\"Missing llm_chain\");\n    }\n\n    if (!data.combine_document_chain) {\n      throw new Error(\"Missing combine_document_chain\");\n    }\n\n    return new MapReduceDocumentsChain({\n      llmChain: await LLMChain.deserialize(data.llm_chain),\n      combineDocumentChain: await StuffDocumentsChain.deserialize(\n        data.combine_document_chain\n      ),\n    });\n  }\n\n  serialize(): SerializedMapReduceDocumentsChain {\n    return {\n      _type: this._chainType(),\n      llm_chain: this.llmChain.serialize(),\n      combine_document_chain: this.combineDocumentChain.serialize(),\n    };\n  }\n}\n\n/**\n * Interface for the input properties of the RefineDocumentsChain class.\n */\nexport interface RefineDocumentsChainInput extends StuffDocumentsChainInput {\n  refineLLMChain: LLMChain;\n  documentPrompt?: BasePromptTemplate;\n  initialResponseName?: string;\n  documentVariableName?: string;\n  outputKey?: string;\n}\n\n/**\n * Combine documents by doing a first pass and then refining on more documents.\n * @augments BaseChain\n * @augments RefineDocumentsChainInput\n */\nexport class RefineDocumentsChain\n  extends BaseChain\n  implements RefineDocumentsChainInput\n{\n  static lc_name() {\n    return \"RefineDocumentsChain\";\n  }\n\n  llmChain: LLMChain;\n\n  inputKey = \"input_documents\";\n\n  outputKey = \"output_text\";\n\n  documentVariableName = \"context\";\n\n  initialResponseName = \"existing_answer\";\n\n  refineLLMChain: LLMChain;\n\n  get defaultDocumentPrompt(): BasePromptTemplate {\n    return new PromptTemplate({\n      inputVariables: [\"page_content\"],\n      template: \"{page_content}\",\n    });\n  }\n\n  documentPrompt = this.defaultDocumentPrompt;\n\n  get inputKeys() {\n    return [\n      ...new Set([\n        this.inputKey,\n        ...this.llmChain.inputKeys,\n        ...this.refineLLMChain.inputKeys,\n      ]),\n    ].filter(\n      (key) =>\n        key !== this.documentVariableName && key !== this.initialResponseName\n    );\n  }\n\n  get outputKeys() {\n    return [this.outputKey];\n  }\n\n  constructor(fields: RefineDocumentsChainInput) {\n    super(fields);\n    this.llmChain = fields.llmChain;\n    this.refineLLMChain = fields.refineLLMChain;\n    this.documentVariableName =\n      fields.documentVariableName ?? this.documentVariableName;\n    this.inputKey = fields.inputKey ?? this.inputKey;\n    this.outputKey = fields.outputKey ?? this.outputKey;\n    this.documentPrompt = fields.documentPrompt ?? this.documentPrompt;\n    this.initialResponseName =\n      fields.initialResponseName ?? this.initialResponseName;\n  }\n\n  /** @ignore */\n  async _constructInitialInputs(doc: Document, rest: Record<string, unknown>) {\n    const baseInfo: Record<string, unknown> = {\n      page_content: doc.pageContent,\n      ...doc.metadata,\n    };\n    const documentInfo: Record<string, unknown> = {};\n    this.documentPrompt.inputVariables.forEach((value) => {\n      documentInfo[value] = baseInfo[value];\n    });\n\n    const baseInputs: Record<string, unknown> = {\n      [this.documentVariableName]: await this.documentPrompt.format({\n        ...documentInfo,\n      }),\n    };\n    const inputs = { ...baseInputs, ...rest };\n    return inputs;\n  }\n\n  /** @ignore */\n  async _constructRefineInputs(doc: Document, res: string) {\n    const baseInfo: Record<string, unknown> = {\n      page_content: doc.pageContent,\n      ...doc.metadata,\n    };\n    const documentInfo: Record<string, unknown> = {};\n    this.documentPrompt.inputVariables.forEach((value) => {\n      documentInfo[value] = baseInfo[value];\n    });\n    const baseInputs: Record<string, unknown> = {\n      [this.documentVariableName]: await this.documentPrompt.format({\n        ...documentInfo,\n      }),\n    };\n    const inputs = { [this.initialResponseName]: res, ...baseInputs };\n    return inputs;\n  }\n\n  /** @ignore */\n  async _call(\n    values: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    if (!(this.inputKey in values)) {\n      throw new Error(`Document key ${this.inputKey} not found.`);\n    }\n    const { [this.inputKey]: docs, ...rest } = values;\n\n    const currentDocs = docs as Document[];\n\n    const initialInputs = await this._constructInitialInputs(\n      currentDocs[0],\n      rest\n    );\n    let res = await this.llmChain.predict(\n      { ...initialInputs },\n      runManager?.getChild(\"answer\")\n    );\n\n    const refineSteps = [res];\n\n    for (let i = 1; i < currentDocs.length; i += 1) {\n      const refineInputs = await this._constructRefineInputs(\n        currentDocs[i],\n        res\n      );\n      const inputs = { ...refineInputs, ...rest };\n      res = await this.refineLLMChain.predict(\n        { ...inputs },\n        runManager?.getChild(\"refine\")\n      );\n      refineSteps.push(res);\n    }\n\n    return { [this.outputKey]: res };\n  }\n\n  _chainType() {\n    return \"refine_documents_chain\" as const;\n  }\n\n  static async deserialize(data: SerializedRefineDocumentsChain) {\n    const SerializedLLMChain = data.llm_chain;\n\n    if (!SerializedLLMChain) {\n      throw new Error(\"Missing llm_chain\");\n    }\n\n    const SerializedRefineDocumentChain = data.refine_llm_chain;\n\n    if (!SerializedRefineDocumentChain) {\n      throw new Error(\"Missing refine_llm_chain\");\n    }\n\n    return new RefineDocumentsChain({\n      llmChain: await LLMChain.deserialize(SerializedLLMChain),\n      refineLLMChain: await LLMChain.deserialize(SerializedRefineDocumentChain),\n    });\n  }\n\n  serialize(): SerializedRefineDocumentsChain {\n    return {\n      _type: this._chainType(),\n      llm_chain: this.llmChain.serialize(),\n      refine_llm_chain: this.refineLLMChain.serialize(),\n    };\n  }\n}\n"],"mappings":"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"}