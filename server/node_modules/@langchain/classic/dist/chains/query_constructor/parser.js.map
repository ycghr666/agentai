{"version":3,"file":"parser.js","names":[],"sources":["../../../src/chains/query_constructor/parser.ts"],"sourcesContent":["import {\n  Comparator,\n  Comparators,\n  Comparison,\n  FilterDirective,\n  Operation,\n  Operator,\n  Operators,\n} from \"@langchain/core/structured_query\";\nimport {\n  CallExpressionType,\n  ExpressionParser,\n  ParsedType,\n} from \"../../output_parsers/expression.js\";\n\n/**\n * A type representing the possible types that can be traversed in an\n * expression.\n */\nexport type TraverseType =\n  | boolean\n  | Operation\n  | Comparison\n  | string\n  | number\n  | { [key: string]: TraverseType }\n  | TraverseType[];\n\n/**\n * A class for transforming and parsing query expressions.\n */\nexport class QueryTransformer {\n  constructor(\n    public allowedComparators: Comparator[] = [],\n    public allowedOperators: Operator[] = []\n  ) {}\n\n  /**\n   * Matches a function name to a comparator or operator. Throws an error if\n   * the function name is unknown or not allowed.\n   * @param funcName The function name to match.\n   * @returns The matched function name.\n   */\n  private matchFunctionName(funcName: string) {\n    if (funcName in Comparators) {\n      if (this.allowedComparators.length > 0) {\n        if (this.allowedComparators.includes(funcName as Comparator)) {\n          return funcName;\n        } else {\n          throw new Error(\"Received comparator not allowed\");\n        }\n      } else {\n        return funcName;\n      }\n    }\n    if (funcName in Operators) {\n      if (this.allowedOperators.length > 0) {\n        if (this.allowedOperators.includes(funcName as Operator)) {\n          return funcName;\n        } else {\n          throw new Error(\"Received operator not allowed\");\n        }\n      } else {\n        return funcName;\n      }\n    }\n    throw new Error(\"Unknown function name\");\n  }\n\n  /**\n   * Transforms a parsed expression into an operation or comparison. Throws\n   * an error if the parsed expression is not supported.\n   * @param parsed The parsed expression to transform.\n   * @returns The transformed operation or comparison.\n   */\n  private transform(parsed: CallExpressionType): Operation | Comparison {\n    const traverse = (node: ParsedType): TraverseType => {\n      switch (node.type) {\n        case \"call_expression\": {\n          if (typeof node.funcCall !== \"string\") {\n            throw new Error(\n              \"Property access expression and element access expression not supported\"\n            );\n          }\n          const funcName = this.matchFunctionName(node.funcCall);\n          if (funcName in Operators) {\n            return new Operation(\n              funcName as Operator,\n              node.args?.map((arg) => traverse(arg)) as FilterDirective[]\n            );\n          }\n          if (funcName in Comparators) {\n            if (node.args && node.args.length === 2) {\n              const [attribute, value] = node.args;\n              return new Comparison(\n                funcName as Comparator,\n                traverse(attribute) as string,\n                traverse(value) as string | number\n              );\n            }\n            throw new Error(\"Comparator must have exactly 2 arguments\");\n          }\n          throw new Error(\"Function name neither operator nor comparator\");\n        }\n        case \"string_literal\": {\n          return node.value;\n        }\n        case \"numeric_literal\": {\n          return node.value;\n        }\n        case \"array_literal\": {\n          return node.values.map((value) => traverse(value));\n        }\n        case \"object_literal\": {\n          return node.values.reduce(\n            (acc, value) => {\n              acc[value.identifier] = traverse(value.value);\n              return acc;\n            },\n            {} as { [key: string]: TraverseType }\n          );\n        }\n        case \"boolean_literal\": {\n          return node.value;\n        }\n        default: {\n          throw new Error(\"Unknown node type\");\n        }\n      }\n    };\n    return traverse(parsed) as Operation | Comparison;\n  }\n\n  /**\n   * Parses an expression and returns the transformed operation or\n   * comparison. Throws an error if the expression cannot be parsed.\n   * @param expression The expression to parse.\n   * @returns A Promise that resolves to the transformed operation or comparison.\n   */\n  async parse(expression: string): Promise<Operation | Comparison> {\n    const expressionParser = new ExpressionParser();\n    const parsed = (await expressionParser.parse(\n      expression\n    )) as CallExpressionType;\n    if (!parsed) {\n      throw new Error(\"Could not parse expression\");\n    }\n    return this.transform(parsed);\n  }\n}\n"],"mappings":";;;;;;;AA+BA,IAAa,mBAAb,MAA8B;CAC5B,YACE,AAAO,qBAAmC,EAAE,EAC5C,AAAO,mBAA+B,EAAE,EACxC;EAFO;EACA;;;;;;;;CAST,AAAQ,kBAAkB,UAAkB;AAC1C,MAAI,YAAY,YACd,KAAI,KAAK,mBAAmB,SAAS,EACnC,KAAI,KAAK,mBAAmB,SAAS,SAAuB,CAC1D,QAAO;MAEP,OAAM,IAAI,MAAM,kCAAkC;MAGpD,QAAO;AAGX,MAAI,YAAY,UACd,KAAI,KAAK,iBAAiB,SAAS,EACjC,KAAI,KAAK,iBAAiB,SAAS,SAAqB,CACtD,QAAO;MAEP,OAAM,IAAI,MAAM,gCAAgC;MAGlD,QAAO;AAGX,QAAM,IAAI,MAAM,wBAAwB;;;;;;;;CAS1C,AAAQ,UAAU,QAAoD;EACpE,MAAM,YAAY,SAAmC;AACnD,WAAQ,KAAK,MAAb;IACE,KAAK,mBAAmB;AACtB,SAAI,OAAO,KAAK,aAAa,SAC3B,OAAM,IAAI,MACR,yEACD;KAEH,MAAM,WAAW,KAAK,kBAAkB,KAAK,SAAS;AACtD,SAAI,YAAY,UACd,QAAO,IAAI,UACT,UACA,KAAK,MAAM,KAAK,QAAQ,SAAS,IAAI,CAAC,CACvC;AAEH,SAAI,YAAY,aAAa;AAC3B,UAAI,KAAK,QAAQ,KAAK,KAAK,WAAW,GAAG;OACvC,MAAM,CAAC,WAAW,SAAS,KAAK;AAChC,cAAO,IAAI,WACT,UACA,SAAS,UAAU,EACnB,SAAS,MAAM,CAChB;;AAEH,YAAM,IAAI,MAAM,2CAA2C;;AAE7D,WAAM,IAAI,MAAM,gDAAgD;;IAElE,KAAK,iBACH,QAAO,KAAK;IAEd,KAAK,kBACH,QAAO,KAAK;IAEd,KAAK,gBACH,QAAO,KAAK,OAAO,KAAK,UAAU,SAAS,MAAM,CAAC;IAEpD,KAAK,iBACH,QAAO,KAAK,OAAO,QAChB,KAAK,UAAU;AACd,SAAI,MAAM,cAAc,SAAS,MAAM,MAAM;AAC7C,YAAO;OAET,EAAE,CACH;IAEH,KAAK,kBACH,QAAO,KAAK;IAEd,QACE,OAAM,IAAI,MAAM,oBAAoB;;;AAI1C,SAAO,SAAS,OAAO;;;;;;;;CASzB,MAAM,MAAM,YAAqD;EAE/D,MAAM,SAAU,MADS,IAAI,kBAAkB,CACR,MACrC,WACD;AACD,MAAI,CAAC,OACH,OAAM,IAAI,MAAM,6BAA6B;AAE/C,SAAO,KAAK,UAAU,OAAO"}