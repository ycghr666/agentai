{"version":3,"file":"multi_prompt.js","names":[],"sources":["../../../src/chains/router/multi_prompt.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { z } from \"zod/v3\";\nimport { interpolateFString, PromptTemplate } from \"@langchain/core/prompts\";\nimport { MultiRouteChain, MultiRouteChainInput } from \"./multi_route.js\";\nimport { STRUCTURED_MULTI_PROMPT_ROUTER_TEMPLATE } from \"./multi_prompt_prompt.js\";\nimport { BaseChain } from \"../../chains/base.js\";\nimport { LLMChain, LLMChainInput } from \"../../chains/llm_chain.js\";\nimport { LLMRouterChain } from \"./llm_router.js\";\nimport { ConversationChain } from \"../../chains/conversation.js\";\nimport { zipEntries } from \"./utils.js\";\nimport { RouterOutputParser } from \"../../output_parsers/router.js\";\n\n/**\n * A class that represents a multi-prompt chain in the LangChain\n * framework. It extends the MultiRouteChain class and provides additional\n * functionality specific to multi-prompt chains.\n * @example\n * ```typescript\n * const multiPromptChain = MultiPromptChain.fromLLMAndPrompts(\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   {\n *     promptNames: [\"physics\", \"math\", \"history\"],\n *     promptDescriptions: [\n *       \"Good for answering questions about physics\",\n *       \"Good for answering math questions\",\n *       \"Good for answering questions about history\",\n *     ],\n *     promptTemplates: [\n *       `You are a very smart physics professor. Here is a question:\\n{input}\\n`,\n *       `You are a very good mathematician. Here is a question:\\n{input}\\n`,\n *       `You are a very smart history professor. Here is a question:\\n{input}\\n`,\n *     ],\n *   }\n * );\n * const result = await multiPromptChain.call({\n *   input: \"What is the speed of light?\",\n * });\n * ```\n */\nexport class MultiPromptChain extends MultiRouteChain {\n  /**\n   * @deprecated Use `fromLLMAndPrompts` instead\n   */\n  static fromPrompts(\n    llm: BaseLanguageModelInterface,\n    promptNames: string[],\n    promptDescriptions: string[],\n    promptTemplates: string[] | PromptTemplate[],\n    defaultChain?: BaseChain,\n    options?: Omit<MultiRouteChainInput, \"defaultChain\">\n  ) {\n    return MultiPromptChain.fromLLMAndPrompts(llm, {\n      promptNames,\n      promptDescriptions,\n      promptTemplates,\n      defaultChain,\n      multiRouteChainOpts: options,\n    });\n  }\n\n  /**\n   * A static method that creates an instance of MultiPromptChain from a\n   * BaseLanguageModel and a set of prompts. It takes in optional parameters\n   * for the default chain and additional options.\n   * @param llm A BaseLanguageModel instance.\n   * @param promptNames An array of prompt names.\n   * @param promptDescriptions An array of prompt descriptions.\n   * @param promptTemplates An array of prompt templates.\n   * @param defaultChain An optional BaseChain instance to be used as the default chain.\n   * @param llmChainOpts Optional parameters for the LLMChainInput, excluding 'llm' and 'prompt'.\n   * @param conversationChainOpts Optional parameters for the LLMChainInput, excluding 'llm' and 'outputKey'.\n   * @param multiRouteChainOpts Optional parameters for the MultiRouteChainInput, excluding 'defaultChain'.\n   * @returns An instance of MultiPromptChain.\n   */\n  static fromLLMAndPrompts(\n    llm: BaseLanguageModelInterface,\n    {\n      promptNames,\n      promptDescriptions,\n      promptTemplates,\n      defaultChain,\n      llmChainOpts,\n      conversationChainOpts,\n      multiRouteChainOpts,\n    }: {\n      promptNames: string[];\n      promptDescriptions: string[];\n      promptTemplates: string[] | PromptTemplate[];\n      defaultChain?: BaseChain;\n      llmChainOpts?: Omit<LLMChainInput, \"llm\" | \"prompt\">;\n      conversationChainOpts?: Omit<LLMChainInput, \"llm\" | \"outputKey\">;\n      multiRouteChainOpts?: Omit<MultiRouteChainInput, \"defaultChain\">;\n    }\n  ): MultiPromptChain {\n    const destinations = zipEntries(promptNames, promptDescriptions).map(\n      ([name, desc]) => `${name}: ${desc}`\n    );\n\n    const structuredOutputParserSchema = z.object({\n      destination: z\n        .string()\n        .optional()\n        .describe('name of the question answering system to use or \"DEFAULT\"'),\n      next_inputs: z\n        .object({\n          input: z\n            .string()\n            .describe(\"a potentially modified version of the original input\"),\n        })\n        .describe(\"input to be fed to the next model\"),\n    });\n\n    const outputParser = new RouterOutputParser(structuredOutputParserSchema);\n\n    const destinationsStr = destinations.join(\"\\n\");\n    const routerTemplate = interpolateFString(\n      STRUCTURED_MULTI_PROMPT_ROUTER_TEMPLATE(\n        outputParser.getFormatInstructions({ interpolationDepth: 4 })\n      ),\n      {\n        destinations: destinationsStr,\n      }\n    );\n\n    const routerPrompt = new PromptTemplate({\n      template: routerTemplate,\n      inputVariables: [\"input\"],\n      outputParser,\n    });\n\n    const routerChain = LLMRouterChain.fromLLM(llm, routerPrompt);\n    const destinationChains = zipEntries<[string, string | PromptTemplate]>(\n      promptNames,\n      promptTemplates\n    ).reduce(\n      (acc, [name, template]) => {\n        let myPrompt: string | PromptTemplate;\n        if (typeof template === \"object\") {\n          myPrompt = template;\n        } else if (typeof template === \"string\") {\n          myPrompt = new PromptTemplate({\n            template: template as string,\n            inputVariables: [\"input\"],\n          });\n        } else {\n          throw new Error(\"Invalid prompt template\");\n        }\n        acc[name as string] = new LLMChain({\n          ...llmChainOpts,\n          llm,\n          prompt: myPrompt,\n        });\n        return acc;\n      },\n      {} as { [name: string]: LLMChain }\n    );\n\n    const convChain = new ConversationChain({\n      ...conversationChainOpts,\n      llm,\n      outputKey: \"text\",\n    });\n\n    return new MultiPromptChain({\n      ...multiRouteChainOpts,\n      routerChain,\n      destinationChains,\n      defaultChain: defaultChain ?? convChain,\n    });\n  }\n\n  _chainType(): string {\n    return \"multi_prompt_chain\";\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,IAAa,mBAAb,MAAa,yBAAyB,gBAAgB;;;;CAIpD,OAAO,YACL,KACA,aACA,oBACA,iBACA,cACA,SACA;AACA,SAAO,iBAAiB,kBAAkB,KAAK;GAC7C;GACA;GACA;GACA;GACA,qBAAqB;GACtB,CAAC;;;;;;;;;;;;;;;;CAiBJ,OAAO,kBACL,KACA,EACE,aACA,oBACA,iBACA,cACA,cACA,uBACA,uBAUgB;EAClB,MAAM,eAAe,WAAW,aAAa,mBAAmB,CAAC,KAC9D,CAAC,MAAM,UAAU,GAAG,KAAK,IAAI,OAC/B;EAgBD,MAAM,eAAe,IAAI,mBAdY,EAAE,OAAO;GAC5C,aAAa,EACV,QAAQ,CACR,UAAU,CACV,SAAS,8DAA4D;GACxE,aAAa,EACV,OAAO,EACN,OAAO,EACJ,QAAQ,CACR,SAAS,uDAAuD,EACpE,CAAC,CACD,SAAS,oCAAoC;GACjD,CAAC,CAEuE;EAEzE,MAAM,kBAAkB,aAAa,KAAK,KAAK;EAU/C,MAAM,eAAe,IAAI,eAAe;GACtC,UAVqB,mBACrB,wCACE,aAAa,sBAAsB,EAAE,oBAAoB,GAAG,CAAC,CAC9D,EACD,EACE,cAAc,iBACf,CACF;GAIC,gBAAgB,CAAC,QAAQ;GACzB;GACD,CAAC;EAEF,MAAM,cAAc,eAAe,QAAQ,KAAK,aAAa;EAC7D,MAAM,oBAAoB,WACxB,aACA,gBACD,CAAC,QACC,KAAK,CAAC,MAAM,cAAc;GACzB,IAAI;AACJ,OAAI,OAAO,aAAa,SACtB,YAAW;YACF,OAAO,aAAa,SAC7B,YAAW,IAAI,eAAe;IAClB;IACV,gBAAgB,CAAC,QAAQ;IAC1B,CAAC;OAEF,OAAM,IAAI,MAAM,0BAA0B;AAE5C,OAAI,QAAkB,IAAI,SAAS;IACjC,GAAG;IACH;IACA,QAAQ;IACT,CAAC;AACF,UAAO;KAET,EAAE,CACH;EAED,MAAM,YAAY,IAAI,kBAAkB;GACtC,GAAG;GACH;GACA,WAAW;GACZ,CAAC;AAEF,SAAO,IAAI,iBAAiB;GAC1B,GAAG;GACH;GACA;GACA,cAAc,gBAAgB;GAC/B,CAAC;;CAGJ,aAAqB;AACnB,SAAO"}