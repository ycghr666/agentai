{"version":3,"file":"openapi.js","names":[],"sources":["../../../src/chains/openai_functions/openapi.ts"],"sourcesContent":["import type { OpenAIClient } from \"@langchain/openai\";\nimport {\n  type JsonSchema7ObjectType,\n  type JsonSchema7ArrayType,\n  type JsonSchema7Type,\n} from \"@langchain/core/utils/json_schema\";\nimport type { OpenAPIV3_1 } from \"openapi-types\";\n\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { BaseChatModel } from \"@langchain/core/language_models/chat_models\";\nimport { BaseFunctionCallOptions } from \"@langchain/core/language_models/base\";\nimport {\n  ChatPromptTemplate,\n  HumanMessagePromptTemplate,\n  BasePromptTemplate,\n} from \"@langchain/core/prompts\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport { OpenAPISpec } from \"../../util/openapi.js\";\nimport { BaseChain } from \"../base.js\";\nimport { LLMChain, LLMChainInput } from \"../llm_chain.js\";\nimport { SequentialChain } from \"../sequential_chain.js\";\nimport { JsonOutputFunctionsParser } from \"../../output_parsers/openai_functions.js\";\n\n/**\n * Type representing a function for executing OpenAPI requests.\n */\ntype OpenAPIExecutionMethod = (\n  name: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  requestArgs: Record<string, any>,\n  options?: {\n    headers?: Record<string, string>;\n    params?: Record<string, string>;\n  }\n) => Promise<string>;\n\n/**\n * Type representing the composition types of a schema.\n */\ntype CompositionType = \"anyOf\" | \"allOf\" | \"oneOf\";\n\n/**\n * Gets the composition type of a schema if it exists.\n * @param schema\n * @returns The composition type of the schema if it exists.\n */\nfunction getCompositionType(\n  schema: OpenAPIV3_1.SchemaObject\n): CompositionType | undefined {\n  if (schema.anyOf !== undefined) {\n    return \"anyOf\";\n  }\n  if (schema.allOf !== undefined) {\n    return \"allOf\";\n  }\n  if (schema.oneOf !== undefined) {\n    return \"oneOf\";\n  }\n  return undefined;\n}\n\n/**\n * Formats a URL by replacing path parameters with their corresponding\n * values.\n * @param url The URL to format.\n * @param pathParams The path parameters to replace in the URL.\n * @returns The formatted URL.\n */\nfunction formatURL(url: string, pathParams: Record<string, string>): string {\n  const expectedPathParamNames = [...url.matchAll(/{(.*?)}/g)].map(\n    (match) => match[1]\n  );\n  const newParams: Record<string, string> = {};\n  for (const paramName of expectedPathParamNames) {\n    const cleanParamName = paramName.replace(/^\\.;/, \"\").replace(/\\*$/, \"\");\n    const value = pathParams[cleanParamName];\n    let formattedValue;\n    if (Array.isArray(value)) {\n      if (paramName.startsWith(\".\")) {\n        const separator = paramName.endsWith(\"*\") ? \".\" : \",\";\n        formattedValue = `.${value.join(separator)}`;\n      } else if (paramName.startsWith(\",\")) {\n        const separator = paramName.endsWith(\"*\") ? `${cleanParamName}=` : \",\";\n        formattedValue = `${cleanParamName}=${value.join(separator)}`;\n      } else {\n        formattedValue = value.join(\",\");\n      }\n    } else if (typeof value === \"object\") {\n      const kvSeparator = paramName.endsWith(\"*\") ? \"=\" : \",\";\n      const kvStrings = Object.entries(value).map(\n        ([k, v]) => k + kvSeparator + v\n      );\n      let entrySeparator;\n      if (paramName.startsWith(\".\")) {\n        entrySeparator = \".\";\n        formattedValue = \".\";\n      } else if (paramName.startsWith(\";\")) {\n        entrySeparator = \";\";\n        formattedValue = \";\";\n      } else {\n        entrySeparator = \",\";\n        formattedValue = \"\";\n      }\n      formattedValue += kvStrings.join(entrySeparator);\n    } else {\n      if (paramName.startsWith(\".\")) {\n        formattedValue = `.${value}`;\n      } else if (paramName.startsWith(\";\")) {\n        formattedValue = `;${cleanParamName}=${value}`;\n      } else {\n        formattedValue = value;\n      }\n    }\n    newParams[paramName] = formattedValue;\n  }\n  let formattedUrl = url;\n  for (const [key, newValue] of Object.entries(newParams)) {\n    formattedUrl = formattedUrl.replace(`{${key}}`, newValue);\n  }\n  return formattedUrl;\n}\n\n/**\n * Converts OpenAPI parameters to JSON schema format.\n * @param params The OpenAPI parameters to convert.\n * @param spec The OpenAPI specification that contains the parameters.\n * @returns The JSON schema representation of the OpenAPI parameters.\n */\nfunction convertOpenAPIParamsToJSONSchema(\n  params: OpenAPIV3_1.ParameterObject[],\n  spec: OpenAPISpec\n) {\n  return params.reduce(\n    (jsonSchema: JsonSchema7ObjectType, param) => {\n      let schema;\n      if (param.schema) {\n        schema = spec.getSchema(param.schema);\n        jsonSchema.properties[param.name] = convertOpenAPISchemaToJSONSchema(\n          schema,\n          spec\n        );\n      } else if (param.content) {\n        const mediaTypeSchema = Object.values(param.content)[0].schema;\n        if (mediaTypeSchema) {\n          schema = spec.getSchema(mediaTypeSchema);\n        }\n        if (!schema) {\n          return jsonSchema;\n        }\n        if (schema.description === undefined) {\n          schema.description = param.description ?? \"\";\n        }\n        jsonSchema.properties[param.name] = convertOpenAPISchemaToJSONSchema(\n          schema,\n          spec\n        );\n      } else {\n        return jsonSchema;\n      }\n      if (param.required && Array.isArray(jsonSchema.required)) {\n        jsonSchema.required.push(param.name);\n      }\n      return jsonSchema;\n    },\n    {\n      type: \"object\",\n      properties: {},\n      required: [],\n      additionalProperties: {},\n    }\n  );\n}\n\n// OpenAI throws errors on extraneous schema properties, e.g. if \"required\" is set on individual ones\n/**\n * Converts OpenAPI schemas to JSON schema format.\n * @param schema The OpenAPI schema to convert.\n * @param spec The OpenAPI specification that contains the schema.\n * @returns The JSON schema representation of the OpenAPI schema.\n */\nexport function convertOpenAPISchemaToJSONSchema(\n  schema: OpenAPIV3_1.SchemaObject,\n  spec: OpenAPISpec\n): JsonSchema7Type {\n  const compositionType = getCompositionType(schema);\n  if (compositionType !== undefined && schema[compositionType] !== undefined) {\n    return {\n      [compositionType]: schema[compositionType].map((s) =>\n        convertOpenAPISchemaToJSONSchema(spec.getSchema(s), spec)\n      ),\n    } as JsonSchema7Type;\n  }\n\n  if (schema.type === \"object\") {\n    return Object.keys(schema.properties ?? {}).reduce(\n      (jsonSchema: JsonSchema7ObjectType, propertyName) => {\n        if (!schema.properties) {\n          return jsonSchema;\n        }\n        const openAPIProperty = spec.getSchema(schema.properties[propertyName]);\n        if (openAPIProperty.type === undefined) {\n          return jsonSchema;\n        }\n        jsonSchema.properties[propertyName] = convertOpenAPISchemaToJSONSchema(\n          openAPIProperty,\n          spec\n        );\n        if (\n          schema.required?.includes(propertyName) &&\n          jsonSchema.required !== undefined\n        ) {\n          jsonSchema.required.push(propertyName);\n        }\n        return jsonSchema;\n      },\n      {\n        type: \"object\",\n        properties: {},\n        required: [],\n        additionalProperties: {},\n      }\n    );\n  }\n\n  if (schema.type === \"array\") {\n    const openAPIItems = spec.getSchema(schema.items ?? {});\n    return {\n      type: \"array\",\n      items: convertOpenAPISchemaToJSONSchema(openAPIItems, spec),\n      minItems: schema.minItems,\n      maxItems: schema.maxItems,\n    } as JsonSchema7ArrayType;\n  }\n  return {\n    type: schema.type ?? \"string\",\n  } as JsonSchema7Type;\n}\n\n/**\n * Converts an OpenAPI specification to OpenAI functions.\n * @param spec The OpenAPI specification to convert.\n * @returns An object containing the OpenAI functions derived from the OpenAPI specification and a default execution method.\n */\nexport function convertOpenAPISpecToOpenAIFunctions(spec: OpenAPISpec): {\n  openAIFunctions: OpenAIClient.Chat.ChatCompletionCreateParams.Function[];\n  defaultExecutionMethod?: OpenAPIExecutionMethod;\n} {\n  if (!spec.document.paths) {\n    return { openAIFunctions: [] };\n  }\n  const openAIFunctions = [];\n  const nameToCallMap: Record<string, { method: string; url: string }> = {};\n  for (const path of Object.keys(spec.document.paths)) {\n    const pathParameters = spec.getParametersForPath(path);\n    for (const method of spec.getMethodsForPath(path)) {\n      const operation = spec.getOperation(path, method);\n      if (!operation) {\n        return { openAIFunctions: [] };\n      }\n      const operationParametersByLocation = pathParameters\n        .concat(spec.getParametersForOperation(operation))\n        .reduce(\n          (\n            operationParams: Record<string, OpenAPIV3_1.ParameterObject[]>,\n            param\n          ) => {\n            if (!operationParams[param.in]) {\n              operationParams[param.in] = [];\n            }\n            operationParams[param.in].push(param);\n            return operationParams;\n          },\n          {}\n        );\n      const paramLocationToRequestArgNameMap: Record<string, string> = {\n        query: \"params\",\n        header: \"headers\",\n        cookie: \"cookies\",\n        path: \"path_params\",\n      };\n      const requestArgsSchema: Record<string, JsonSchema7ObjectType> & {\n        data?:\n          | JsonSchema7ObjectType\n          | {\n              anyOf?: JsonSchema7ObjectType[];\n            };\n      } = {};\n      for (const paramLocation of Object.keys(\n        paramLocationToRequestArgNameMap\n      )) {\n        if (operationParametersByLocation[paramLocation]) {\n          requestArgsSchema[paramLocationToRequestArgNameMap[paramLocation]] =\n            convertOpenAPIParamsToJSONSchema(\n              operationParametersByLocation[paramLocation],\n              spec\n            );\n        }\n      }\n      const requestBody = spec.getRequestBodyForOperation(operation);\n      if (requestBody?.content !== undefined) {\n        const requestBodySchemas: Record<string, JsonSchema7ObjectType> = {};\n        for (const [mediaType, mediaTypeObject] of Object.entries(\n          requestBody.content\n        )) {\n          if (mediaTypeObject.schema !== undefined) {\n            const schema = spec.getSchema(mediaTypeObject.schema);\n            requestBodySchemas[mediaType] = convertOpenAPISchemaToJSONSchema(\n              schema,\n              spec\n            ) as JsonSchema7ObjectType;\n          }\n        }\n        const mediaTypes = Object.keys(requestBodySchemas);\n        if (mediaTypes.length === 1) {\n          requestArgsSchema.data = requestBodySchemas[mediaTypes[0]];\n        } else if (mediaTypes.length > 1) {\n          requestArgsSchema.data = {\n            anyOf: Object.values(requestBodySchemas),\n          };\n        }\n      }\n      const openAIFunction: OpenAIClient.Chat.ChatCompletionCreateParams.Function =\n        {\n          name: OpenAPISpec.getCleanedOperationId(operation, path, method),\n          description: operation.description ?? operation.summary ?? \"\",\n          parameters: {\n            type: \"object\",\n            properties: requestArgsSchema,\n            // All remaining top-level parameters are required\n            required: Object.keys(requestArgsSchema),\n          },\n        };\n\n      openAIFunctions.push(openAIFunction);\n      const baseUrl = (spec.baseUrl ?? \"\").endsWith(\"/\")\n        ? (spec.baseUrl ?? \"\").slice(0, -1)\n        : (spec.baseUrl ?? \"\");\n      nameToCallMap[openAIFunction.name] = {\n        method,\n        url: baseUrl + path,\n      };\n    }\n  }\n  return {\n    openAIFunctions,\n    defaultExecutionMethod: async (\n      name: string,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      requestArgs: Record<string, any>,\n      options?: {\n        headers?: Record<string, string>;\n        params?: Record<string, string>;\n      }\n    ) => {\n      const {\n        headers: customHeaders,\n        params: customParams,\n        ...rest\n      } = options ?? {};\n      const { method, url } = nameToCallMap[name];\n      const requestParams = requestArgs.params ?? {};\n      const nonEmptyParams = Object.keys(requestParams).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (filteredArgs: Record<string, any>, argName) => {\n          if (\n            requestParams[argName] !== \"\" &&\n            requestParams[argName] !== null &&\n            requestParams[argName] !== undefined\n          ) {\n            filteredArgs[argName] = requestParams[argName];\n          }\n          return filteredArgs;\n        },\n        {}\n      );\n      const queryString = new URLSearchParams({\n        ...nonEmptyParams,\n        ...customParams,\n      }).toString();\n      const pathParams = requestArgs.path_params;\n      const formattedUrl =\n        formatURL(url, pathParams) +\n        (queryString.length ? `?${queryString}` : \"\");\n      const headers: Record<string, string> = {};\n      let body;\n      if (requestArgs.data !== undefined) {\n        let contentType = \"text/plain\";\n        if (typeof requestArgs.data !== \"string\") {\n          if (typeof requestArgs.data === \"object\") {\n            contentType = \"application/json\";\n          }\n          body = JSON.stringify(requestArgs.data);\n        } else {\n          body = requestArgs.data;\n        }\n        headers[\"content-type\"] = contentType;\n      }\n      const response = await fetch(formattedUrl, {\n        ...requestArgs,\n        method,\n        headers: {\n          ...headers,\n          ...requestArgs.headers,\n          ...customHeaders,\n        },\n        body,\n        ...rest,\n      });\n      let output;\n      if (response.status < 200 || response.status > 299) {\n        output = `${response.status}: ${\n          response.statusText\n        } for ${name} called with ${JSON.stringify(queryString)}`;\n      } else {\n        output = await response.text();\n      }\n      return output;\n    },\n  };\n}\n\n/**\n * Type representing a function for executing simple requests.\n */\ntype SimpleRequestChainExecutionMethod = (\n  name: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  requestArgs: Record<string, any>\n) => Promise<string>;\n\n/**\n * A chain for making simple API requests.\n */\nclass SimpleRequestChain extends BaseChain {\n  static lc_name() {\n    return \"SimpleRequestChain\";\n  }\n\n  private requestMethod: SimpleRequestChainExecutionMethod;\n\n  inputKey = \"function\";\n\n  outputKey = \"response\";\n\n  constructor(config: { requestMethod: SimpleRequestChainExecutionMethod }) {\n    super();\n    this.requestMethod = config.requestMethod;\n  }\n\n  get inputKeys() {\n    return [this.inputKey];\n  }\n\n  get outputKeys() {\n    return [this.outputKey];\n  }\n\n  _chainType() {\n    return \"simple_request_chain\" as const;\n  }\n\n  /** @ignore */\n  async _call(\n    values: ChainValues,\n    _runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    const inputKeyValue = values[this.inputKey];\n    const methodName = inputKeyValue.name;\n    const args = inputKeyValue.arguments;\n    const response = await this.requestMethod(methodName, args);\n    return { [this.outputKey]: response };\n  }\n}\n\n/**\n * Type representing the options for creating an OpenAPI chain.\n */\nexport type OpenAPIChainOptions = {\n  llm?: BaseChatModel<BaseFunctionCallOptions>;\n  prompt?: BasePromptTemplate;\n  requestChain?: BaseChain;\n  llmChainInputs?: LLMChainInput;\n  headers?: Record<string, string>;\n  params?: Record<string, string>;\n  verbose?: boolean;\n};\n\n/**\n * Create a chain for querying an API from a OpenAPI spec.\n * @param spec OpenAPISpec or url/file/text string corresponding to one.\n * @param options Custom options passed into the chain\n * @returns OpenAPIChain\n */\nexport async function createOpenAPIChain(\n  spec: OpenAPIV3_1.Document | string,\n  options: OpenAPIChainOptions = {}\n) {\n  let convertedSpec;\n  if (typeof spec === \"string\") {\n    try {\n      convertedSpec = await OpenAPISpec.fromURL(spec);\n    } catch {\n      try {\n        convertedSpec = OpenAPISpec.fromString(spec);\n      } catch {\n        throw new Error(`Unable to parse spec from source ${spec}.`);\n      }\n    }\n  } else {\n    convertedSpec = OpenAPISpec.fromObject(spec);\n  }\n  const { openAIFunctions, defaultExecutionMethod } =\n    convertOpenAPISpecToOpenAIFunctions(convertedSpec);\n  if (defaultExecutionMethod === undefined) {\n    throw new Error(\n      `Could not parse any valid operations from the provided spec.`\n    );\n  }\n\n  if (!options.llm) {\n    throw new Error(\"`llm` option is required\");\n  }\n\n  const {\n    llm = options.llm,\n    prompt = ChatPromptTemplate.fromMessages([\n      HumanMessagePromptTemplate.fromTemplate(\n        \"Use the provided API's to respond to this user query:\\n\\n{query}\"\n      ),\n    ]),\n    requestChain = new SimpleRequestChain({\n      requestMethod: async (name, args) =>\n        defaultExecutionMethod(name, args, {\n          headers: options.headers,\n          params: options.params,\n        }),\n    }),\n    llmChainInputs = {},\n    verbose,\n    ...rest\n  } = options;\n  const formatChain = new LLMChain({\n    llm,\n    prompt,\n    outputParser: new JsonOutputFunctionsParser({ argsOnly: false }),\n    outputKey: \"function\",\n    llmKwargs: { functions: openAIFunctions },\n    ...llmChainInputs,\n  });\n  return new SequentialChain({\n    chains: [formatChain, requestChain],\n    outputVariables: [\"response\"],\n    inputVariables: formatChain.inputKeys,\n    verbose,\n    ...rest,\n  });\n}\n"],"mappings":"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"}