{"version":3,"file":"base.js","names":[],"sources":["../../../src/evaluation/embedding_distance/base.ts"],"sourcesContent":["import type { EmbeddingsInterface } from \"@langchain/core/embeddings\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport {\n  CallbackManagerForChainRun,\n  Callbacks,\n  BaseCallbackConfig,\n} from \"@langchain/core/callbacks/manager\";\nimport {\n  PairwiseStringEvaluator,\n  PairwiseStringEvaluatorArgs,\n  StringEvaluator,\n  StringEvaluatorArgs,\n} from \"../base.js\";\nimport { cosine } from \"../../util/ml-distance/similarities.js\";\nimport { chebyshev, manhattan } from \"../../util/ml-distance/distances.js\";\nimport { euclidean } from \"../../util/ml-distance-euclidean/euclidean.js\";\n\n/**\n *\n * Embedding Distance Metric.\n *\n * COSINE: Cosine distance metric.\n * EUCLIDEAN: Euclidean distance metric.\n * MANHATTAN: Manhattan distance metric.\n * CHEBYSHEV: Chebyshev distance metric.\n * HAMMING: Hamming distance metric.\n */\nexport type EmbeddingDistanceType =\n  | \"cosine\"\n  | \"euclidean\"\n  | \"manhattan\"\n  | \"chebyshev\";\n\n/**\n * Embedding Distance Evaluation Chain Input.\n */\nexport interface EmbeddingDistanceEvalChainInput {\n  /**\n   * The embedding objects to vectorize the outputs.\n   */\n  embedding?: EmbeddingsInterface;\n\n  /**\n   * The distance metric to use\n   * for comparing the embeddings.\n   */\n  distanceMetric?: EmbeddingDistanceType;\n}\n\ntype VectorFunction = (xVector: number[], yVector: number[]) => number;\n\n/**\n * Get the distance function for the given distance type.\n * @param distance The distance type.\n * @return The distance function.\n */\nexport function getDistanceCalculationFunction(\n  distanceType: EmbeddingDistanceType\n): VectorFunction {\n  const distanceFunctions: { [key in EmbeddingDistanceType]: VectorFunction } =\n    {\n      cosine: (X: number[], Y: number[]) => 1.0 - cosine(X, Y),\n      euclidean,\n      manhattan,\n      chebyshev,\n    };\n\n  return distanceFunctions[distanceType];\n}\n\n/**\n * Compute the score based on the distance metric.\n * @param vectors The input vectors.\n * @param distanceMetric The distance metric.\n * @return The computed score.\n */\nexport function computeEvaluationScore(\n  vectors: number[][],\n  distanceMetric: EmbeddingDistanceType\n): number {\n  const metricFunction = getDistanceCalculationFunction(distanceMetric);\n  return metricFunction(vectors[0], vectors[1]);\n}\n\n/**\n * Use embedding distances to score semantic difference between\n * a prediction and reference.\n */\nexport class EmbeddingDistanceEvalChain\n  extends StringEvaluator\n  implements EmbeddingDistanceEvalChainInput\n{\n  requiresReference = true;\n\n  requiresInput = false;\n\n  outputKey = \"score\";\n\n  embedding?: EmbeddingsInterface;\n\n  distanceMetric: EmbeddingDistanceType = \"cosine\";\n\n  constructor(fields: EmbeddingDistanceEvalChainInput) {\n    super();\n    this.embedding = fields?.embedding;\n    this.distanceMetric = fields?.distanceMetric || \"cosine\";\n  }\n\n  _chainType() {\n    return `embedding_${this.distanceMetric}_distance` as const;\n  }\n\n  async _evaluateStrings(\n    args: StringEvaluatorArgs,\n    config: Callbacks | BaseCallbackConfig | undefined\n  ): Promise<ChainValues> {\n    const result = await this.call(args, config);\n\n    return { [this.outputKey]: result[this.outputKey] };\n  }\n\n  get inputKeys(): string[] {\n    return [\"reference\", \"prediction\"];\n  }\n\n  get outputKeys(): string[] {\n    return [this.outputKey];\n  }\n\n  async _call(\n    values: ChainValues,\n    _runManager: CallbackManagerForChainRun | undefined\n  ): Promise<ChainValues> {\n    const { prediction, reference } = values;\n\n    if (!this.embedding) throw new Error(\"Embedding is undefined\");\n\n    const vectors = await this.embedding.embedDocuments([\n      prediction,\n      reference,\n    ]);\n\n    const score = computeEvaluationScore(vectors, this.distanceMetric);\n\n    return { [this.outputKey]: score };\n  }\n}\n\n/**\n * Use embedding distances to score semantic difference between two predictions.\n */\nexport class PairwiseEmbeddingDistanceEvalChain\n  extends PairwiseStringEvaluator\n  implements EmbeddingDistanceEvalChainInput\n{\n  requiresReference = false;\n\n  requiresInput = false;\n\n  outputKey = \"score\";\n\n  embedding?: EmbeddingsInterface;\n\n  distanceMetric: EmbeddingDistanceType = \"cosine\";\n\n  constructor(fields: EmbeddingDistanceEvalChainInput) {\n    super();\n    this.embedding = fields?.embedding;\n    this.distanceMetric = fields?.distanceMetric || \"cosine\";\n  }\n\n  _chainType() {\n    return `pairwise_embedding_${this.distanceMetric}_distance` as const;\n  }\n\n  async _evaluateStringPairs(\n    args: PairwiseStringEvaluatorArgs,\n    config?: Callbacks | BaseCallbackConfig\n  ): Promise<ChainValues> {\n    const result = await this.call(args, config);\n\n    return { [this.outputKey]: result[this.outputKey] };\n  }\n\n  get inputKeys(): string[] {\n    return [\"prediction\", \"predictionB\"];\n  }\n\n  get outputKeys(): string[] {\n    return [this.outputKey];\n  }\n\n  async _call(\n    values: ChainValues,\n    _runManager: CallbackManagerForChainRun | undefined\n  ): Promise<ChainValues> {\n    const { prediction, predictionB } = values;\n\n    if (!this.embedding) throw new Error(\"Embedding is undefined\");\n\n    const vectors = await this.embedding.embedDocuments([\n      prediction,\n      predictionB,\n    ]);\n\n    const score = computeEvaluationScore(vectors, this.distanceMetric);\n\n    return { [this.outputKey]: score };\n  }\n}\n"],"mappings":";;;;;;;;;;;AAwDA,SAAgB,+BACd,cACgB;AAShB,QAPE;EACE,SAAS,GAAa,MAAgB,IAAM,OAAO,GAAG,EAAE;EACxD;EACA;EACA;EACD,CAEsB;;;;;;;;AAS3B,SAAgB,uBACd,SACA,gBACQ;AAER,QADuB,+BAA+B,eAAe,CAC/C,QAAQ,IAAI,QAAQ,GAAG;;;;;;AAO/C,IAAa,6BAAb,cACU,gBAEV;CACE,oBAAoB;CAEpB,gBAAgB;CAEhB,YAAY;CAEZ;CAEA,iBAAwC;CAExC,YAAY,QAAyC;AACnD,SAAO;AACP,OAAK,YAAY,QAAQ;AACzB,OAAK,iBAAiB,QAAQ,kBAAkB;;CAGlD,aAAa;AACX,SAAO,aAAa,KAAK,eAAe;;CAG1C,MAAM,iBACJ,MACA,QACsB;EACtB,MAAM,SAAS,MAAM,KAAK,KAAK,MAAM,OAAO;AAE5C,SAAO,GAAG,KAAK,YAAY,OAAO,KAAK,YAAY;;CAGrD,IAAI,YAAsB;AACxB,SAAO,CAAC,aAAa,aAAa;;CAGpC,IAAI,aAAuB;AACzB,SAAO,CAAC,KAAK,UAAU;;CAGzB,MAAM,MACJ,QACA,aACsB;EACtB,MAAM,EAAE,YAAY,cAAc;AAElC,MAAI,CAAC,KAAK,UAAW,OAAM,IAAI,MAAM,yBAAyB;EAO9D,MAAM,QAAQ,uBALE,MAAM,KAAK,UAAU,eAAe,CAClD,YACA,UACD,CAAC,EAE4C,KAAK,eAAe;AAElE,SAAO,GAAG,KAAK,YAAY,OAAO;;;;;;AAOtC,IAAa,qCAAb,cACU,wBAEV;CACE,oBAAoB;CAEpB,gBAAgB;CAEhB,YAAY;CAEZ;CAEA,iBAAwC;CAExC,YAAY,QAAyC;AACnD,SAAO;AACP,OAAK,YAAY,QAAQ;AACzB,OAAK,iBAAiB,QAAQ,kBAAkB;;CAGlD,aAAa;AACX,SAAO,sBAAsB,KAAK,eAAe;;CAGnD,MAAM,qBACJ,MACA,QACsB;EACtB,MAAM,SAAS,MAAM,KAAK,KAAK,MAAM,OAAO;AAE5C,SAAO,GAAG,KAAK,YAAY,OAAO,KAAK,YAAY;;CAGrD,IAAI,YAAsB;AACxB,SAAO,CAAC,cAAc,cAAc;;CAGtC,IAAI,aAAuB;AACzB,SAAO,CAAC,KAAK,UAAU;;CAGzB,MAAM,MACJ,QACA,aACsB;EACtB,MAAM,EAAE,YAAY,gBAAgB;AAEpC,MAAI,CAAC,KAAK,UAAW,OAAM,IAAI,MAAM,yBAAyB;EAO9D,MAAM,QAAQ,uBALE,MAAM,KAAK,UAAU,eAAe,CAClD,YACA,YACD,CAAC,EAE4C,KAAK,eAAe;AAElE,SAAO,GAAG,KAAK,YAAY,OAAO"}