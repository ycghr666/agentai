{"version":3,"file":"runner_utils.js","names":[],"sources":["../../src/smith/runner_utils.ts"],"sourcesContent":["import { BaseLanguageModel } from \"@langchain/core/language_models/base\";\nimport { Serialized } from \"@langchain/core/load/serializable\";\nimport { mapStoredMessagesToChatMessages } from \"@langchain/core/messages\";\nimport {\n  Runnable,\n  RunnableConfig,\n  RunnableLambda,\n  getCallbackManagerForConfig,\n} from \"@langchain/core/runnables\";\nimport { LangChainTracer } from \"@langchain/core/tracers/tracer_langchain\";\nimport { BaseTracer } from \"@langchain/core/tracers/base\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { AsyncCaller } from \"@langchain/core/utils/async_caller\";\nimport type {\n  CallbackManager,\n  CallbackManagerForChainRun,\n} from \"@langchain/core/callbacks/manager\";\nimport {\n  Client,\n  Example,\n  Feedback,\n  Run,\n  RunTree,\n  RunTreeConfig,\n} from \"langsmith\";\nimport { EvaluationResult, RunEvaluator } from \"langsmith/evaluation\";\nimport { DataType } from \"langsmith/schemas\";\nimport type { TraceableFunction } from \"langsmith/singletons/traceable\";\nimport { LLMStringEvaluator } from \"../evaluation/base.js\";\nimport { loadEvaluator } from \"../evaluation/loader.js\";\nimport { EvaluatorType } from \"../evaluation/types.js\";\nimport {\n  isOffTheShelfEvaluator,\n  type DynamicRunEvaluatorParams,\n  type EvalConfig,\n  type EvaluatorInputFormatter,\n  type RunEvalConfig,\n  type RunEvaluatorLike,\n  isCustomEvaluator,\n} from \"./config.js\";\nimport { randomName } from \"./name_generation.js\";\nimport { ProgressBar } from \"./progress.js\";\n\nexport type ChainOrFactory =\n  | Runnable\n  | (() => Runnable)\n  | AnyTraceableFunction\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | ((obj: any) => any)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | ((obj: any) => Promise<any>)\n  | (() => (obj: unknown) => unknown)\n  | (() => (obj: unknown) => Promise<unknown>);\n\nclass SingleRunIdExtractor {\n  runIdPromiseResolver: (runId: string) => void;\n\n  runIdPromise: Promise<string>;\n\n  constructor() {\n    this.runIdPromise = new Promise<string>((extract) => {\n      this.runIdPromiseResolver = extract;\n    });\n  }\n\n  handleChainStart = (\n    _chain: Serialized,\n    _inputs: ChainValues,\n    runId: string\n  ) => {\n    this.runIdPromiseResolver(runId);\n  };\n\n  async extract(): Promise<string> {\n    return this.runIdPromise;\n  }\n}\n\nclass SingleRunExtractor extends BaseTracer {\n  runPromiseResolver: (run: Run) => void;\n\n  runPromise: Promise<Run>;\n\n  /** The name of the callback handler. */\n  name = \"single_run_extractor\";\n\n  constructor() {\n    super();\n    this.runPromise = new Promise<Run>((extract) => {\n      this.runPromiseResolver = extract;\n    });\n  }\n\n  async persistRun(run: Run) {\n    this.runPromiseResolver(run);\n  }\n\n  async extract(): Promise<Run> {\n    return this.runPromise;\n  }\n}\n\n/**\n * Wraps an evaluator function + implements the RunEvaluator interface.\n */\nclass DynamicRunEvaluator implements RunEvaluator {\n  evaluator: RunnableLambda<DynamicRunEvaluatorParams, EvaluationResult>;\n\n  constructor(evaluator: RunEvaluatorLike) {\n    this.evaluator = new RunnableLambda({ func: evaluator });\n  }\n\n  /**\n   * Evaluates a run with an optional example and returns the evaluation result.\n   * @param run The run to evaluate.\n   * @param example The optional example to use for evaluation.\n   * @returns A promise that extracts to the evaluation result.\n   */\n  async evaluateRun(run: Run, example?: Example): Promise<EvaluationResult> {\n    const extractor = new SingleRunIdExtractor();\n    const tracer = new LangChainTracer({ projectName: \"evaluators\" });\n    const result = await this.evaluator.invoke(\n      {\n        run,\n        example,\n        input: run.inputs,\n        prediction: run.outputs,\n        reference: example?.outputs,\n      },\n      {\n        callbacks: [extractor, tracer],\n      }\n    );\n    const runId = await extractor.extract();\n    return {\n      sourceRunId: runId,\n      ...result,\n    };\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isLLMStringEvaluator(evaluator: any): evaluator is LLMStringEvaluator {\n  return evaluator && typeof evaluator.evaluateStrings === \"function\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyTraceableFunction = TraceableFunction<(...any: any[]) => any>;\n\n/**\n * Internal implementation of RunTree, which uses the\n * provided callback manager instead of the internal LangSmith client.\n *\n * The goal of this class is to ensure seamless interop when intergrated\n * with other Runnables.\n */\nclass CallbackManagerRunTree extends RunTree {\n  callbackManager: CallbackManager;\n\n  activeCallbackManager: CallbackManagerForChainRun | undefined = undefined;\n\n  constructor(config: RunTreeConfig, callbackManager: CallbackManager) {\n    super(config);\n\n    this.callbackManager = callbackManager;\n  }\n\n  createChild(config: RunTreeConfig): CallbackManagerRunTree {\n    const child = new CallbackManagerRunTree(\n      {\n        ...config,\n        parent_run: this,\n        project_name: this.project_name,\n        client: this.client,\n      },\n      this.activeCallbackManager?.getChild() ?? this.callbackManager\n    );\n    this.child_runs.push(child);\n    return child;\n  }\n\n  async postRun(): Promise<void> {\n    // how it is translated in comparison to basic RunTree?\n    this.activeCallbackManager = await this.callbackManager.handleChainStart(\n      typeof this.serialized !== \"object\" &&\n        this.serialized != null &&\n        \"lc\" in this.serialized\n        ? this.serialized\n        : {\n            id: [\"langchain\", \"smith\", \"CallbackManagerRunTree\"],\n            lc: 1,\n            type: \"not_implemented\",\n          },\n      this.inputs,\n      this.id,\n      this.run_type,\n      undefined,\n      undefined,\n      this.name\n    );\n  }\n\n  async patchRun(): Promise<void> {\n    if (this.error) {\n      await this.activeCallbackManager?.handleChainError(\n        this.error,\n        this.id,\n        this.parent_run?.id,\n        undefined,\n        undefined\n      );\n    } else {\n      await this.activeCallbackManager?.handleChainEnd(\n        this.outputs ?? {},\n        this.id,\n        this.parent_run?.id,\n        undefined,\n        undefined\n      );\n    }\n  }\n}\n\nclass RunnableTraceable<RunInput, RunOutput> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  lc_serializable = false;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected func: AnyTraceableFunction;\n\n  constructor(fields: { func: AnyTraceableFunction }) {\n    super(fields);\n\n    if (!isLangsmithTraceableFunction(fields.func)) {\n      throw new Error(\n        \"RunnableTraceable requires a function that is wrapped in traceable higher-order function\"\n      );\n    }\n\n    this.func = fields.func;\n  }\n\n  async invoke(input: RunInput, options?: Partial<RunnableConfig>) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const callbackManager = await getCallbackManagerForConfig(config);\n\n    const partialConfig =\n      \"langsmith:traceable\" in this.func\n        ? (this.func[\"langsmith:traceable\"] as RunTreeConfig)\n        : { name: \"<lambda>\" };\n\n    if (!callbackManager) throw new Error(\"CallbackManager not found\");\n    const runTree = new CallbackManagerRunTree(\n      {\n        ...partialConfig,\n        parent_run: callbackManager?._parentRunId\n          ? new RunTree({ name: \"<parent>\", id: callbackManager?._parentRunId })\n          : undefined,\n      },\n      callbackManager\n    );\n\n    if (\n      typeof input === \"object\" &&\n      input != null &&\n      Object.keys(input).length === 1\n    ) {\n      if (\"args\" in input && Array.isArray(input)) {\n        return (await this.func(runTree, ...input)) as RunOutput;\n      }\n\n      if (\n        \"input\" in input &&\n        !(\n          typeof input === \"object\" &&\n          input != null &&\n          !Array.isArray(input) &&\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          !(input instanceof Date)\n        )\n      ) {\n        try {\n          return (await this.func(runTree, input.input)) as RunOutput;\n        } catch {\n          return (await this.func(runTree, input)) as RunOutput;\n        }\n      }\n    }\n\n    return (await this.func(runTree, input)) as RunOutput;\n  }\n}\n\n/**\n * Wraps an off-the-shelf evaluator (loaded using loadEvaluator; of EvaluatorType[T])\n * and composes with a prepareData function so the user can prepare the trace and\n * dataset data for the evaluator.\n */\nclass PreparedRunEvaluator implements RunEvaluator {\n  evaluator: LLMStringEvaluator;\n\n  formatEvaluatorInputs: EvaluatorInputFormatter;\n\n  isStringEvaluator: boolean;\n\n  evaluationName: string;\n\n  constructor(\n    evaluator: LLMStringEvaluator,\n    evaluationName: string,\n    formatEvaluatorInputs: EvaluatorInputFormatter\n  ) {\n    this.evaluator = evaluator;\n    this.isStringEvaluator = typeof evaluator?.evaluateStrings === \"function\";\n    this.evaluationName = evaluationName;\n    this.formatEvaluatorInputs = formatEvaluatorInputs;\n  }\n\n  static async fromEvalConfig(\n    config: EvalConfig | keyof EvaluatorType\n  ): Promise<PreparedRunEvaluator> {\n    const evaluatorType =\n      typeof config === \"string\" ? config : config.evaluatorType;\n    const evalConfig = typeof config === \"string\" ? ({} as EvalConfig) : config;\n    const evaluator = await loadEvaluator(evaluatorType, evalConfig);\n    const feedbackKey = evalConfig?.feedbackKey ?? evaluator?.evaluationName;\n    if (!isLLMStringEvaluator(evaluator)) {\n      throw new Error(\n        `Evaluator of type ${evaluatorType} not yet supported. ` +\n          \"Please use a string evaluator, or implement your \" +\n          \"evaluation logic as a custom evaluator.\"\n      );\n    }\n    if (!feedbackKey) {\n      throw new Error(\n        `Evaluator of type ${evaluatorType} must have an evaluationName` +\n          ` or feedbackKey. Please manually provide a feedbackKey in the EvalConfig.`\n      );\n    }\n    return new PreparedRunEvaluator(\n      evaluator as LLMStringEvaluator,\n      feedbackKey,\n      evalConfig?.formatEvaluatorInputs\n    );\n  }\n\n  /**\n   * Evaluates a run with an optional example and returns the evaluation result.\n   * @param run The run to evaluate.\n   * @param example The optional example to use for evaluation.\n   * @returns A promise that extracts to the evaluation result.\n   */\n  async evaluateRun(run: Run, example?: Example): Promise<EvaluationResult> {\n    const { prediction, input, reference } = this.formatEvaluatorInputs({\n      rawInput: run.inputs,\n      rawPrediction: run.outputs,\n      rawReferenceOutput: example?.outputs,\n      run,\n    });\n    const extractor = new SingleRunIdExtractor();\n    const tracer = new LangChainTracer({ projectName: \"evaluators\" });\n    if (this.isStringEvaluator) {\n      const evalResult = await this.evaluator.evaluateStrings(\n        {\n          prediction: prediction as string,\n          reference: reference as string,\n          input: input as string,\n        },\n        {\n          callbacks: [extractor, tracer],\n        }\n      );\n      const runId = await extractor.extract();\n      return {\n        key: this.evaluationName,\n        comment: evalResult?.reasoning,\n        sourceRunId: runId,\n        ...evalResult,\n      };\n    }\n    throw new Error(\n      \"Evaluator not yet supported. \" +\n        \"Please use a string evaluator, or implement your \" +\n        \"evaluation logic as a custom evaluator.\"\n    );\n  }\n}\n\nclass LoadedEvalConfig {\n  constructor(public evaluators: (RunEvaluator | DynamicRunEvaluator)[]) {}\n\n  static async fromRunEvalConfig(\n    config: RunEvalConfig<keyof EvaluatorType>\n  ): Promise<LoadedEvalConfig> {\n    // Custom evaluators are applied \"as-is\"\n    const customEvaluators = (\n      config?.customEvaluators ?? config.evaluators?.filter(isCustomEvaluator)\n    )?.map((evaluator) => {\n      if (typeof evaluator === \"function\") {\n        return new DynamicRunEvaluator(evaluator);\n      } else {\n        return evaluator;\n      }\n    });\n\n    const offTheShelfEvaluators = await Promise.all(\n      config?.evaluators\n        ?.filter(isOffTheShelfEvaluator)\n        ?.map(\n          async (evaluator) =>\n            await PreparedRunEvaluator.fromEvalConfig(evaluator)\n        ) ?? []\n    );\n    return new LoadedEvalConfig(\n      (customEvaluators ?? []).concat(offTheShelfEvaluators ?? [])\n    );\n  }\n}\n\nexport interface RunOnDatasetParams extends Omit<\n  RunEvalConfig,\n  \"customEvaluators\"\n> {\n  /**\n   * Name of the project for logging and tracking.\n   */\n  projectName?: string;\n\n  /**\n   * Additional metadata for the project.\n   */\n  projectMetadata?: Record<string, unknown>;\n\n  /**\n   * Client instance for LangSmith service interaction.\n   */\n  client?: Client;\n\n  /**\n   * Maximum concurrency level for dataset processing.\n   */\n  maxConcurrency?: number;\n\n  /**\n   * @deprecated Pass keys directly to the RunOnDatasetParams instead\n   */\n  evaluationConfig?: RunEvalConfig;\n}\n\n/**\n * Internals expect a constructor () -> Runnable. This function wraps/coerces\n * the provided LangChain object, custom function, or factory function into\n * a constructor of a runnable.\n * @param modelOrFactory The model or factory to create a wrapped model from.\n * @returns A function that returns the wrapped model.\n * @throws Error if the modelOrFactory is invalid.\n */\nconst createWrappedModel = async (modelOrFactory: ChainOrFactory) => {\n  if (Runnable.isRunnable(modelOrFactory)) {\n    return () => modelOrFactory;\n  }\n  if (typeof modelOrFactory === \"function\") {\n    if (isLangsmithTraceableFunction(modelOrFactory)) {\n      const wrappedModel = new RunnableTraceable({ func: modelOrFactory });\n      return () => wrappedModel;\n    }\n\n    try {\n      // If it works with no arguments, assume it's a factory\n      let res = (modelOrFactory as () => Runnable)();\n      if (\n        res &&\n        typeof (res as unknown as Promise<Runnable>).then === \"function\"\n      ) {\n        res = await res;\n      }\n      return modelOrFactory as () => Runnable;\n    } catch {\n      // Otherwise, it's a custom UDF, and we'll wrap\n      // the function in a lambda\n      const wrappedModel = new RunnableLambda({ func: modelOrFactory });\n      return () => wrappedModel;\n    }\n  }\n  throw new Error(\"Invalid modelOrFactory\");\n};\n\nconst loadExamples = async ({\n  datasetName,\n  client,\n  projectName,\n}: {\n  datasetName: string;\n  client: Client;\n  projectName: string;\n  maxConcurrency: number;\n}) => {\n  const exampleIterator = client.listExamples({ datasetName });\n  const configs: RunnableConfig[] = [];\n  const runExtractors = [];\n  const examples = [];\n  for await (const example of exampleIterator) {\n    const runExtractor = new SingleRunExtractor();\n    configs.push({\n      callbacks: [\n        new LangChainTracer({ exampleId: example.id, projectName }),\n        runExtractor,\n      ],\n    });\n    examples.push(example);\n    runExtractors.push(runExtractor);\n  }\n  return {\n    configs,\n    examples,\n    runExtractors,\n  };\n};\n\nconst applyEvaluators = async ({\n  evaluation,\n  runs,\n  examples,\n  client,\n  maxConcurrency,\n}: {\n  evaluation: LoadedEvalConfig;\n  runs: Run[];\n  examples: Example[];\n  client: Client;\n  maxConcurrency: number;\n}): Promise<{\n  [key: string]: {\n    execution_time?: number;\n    run_id: string;\n    feedback: Feedback[];\n  };\n}> => {\n  // TODO: Parallelize and/or put in callbacks to speed up evals.\n  const { evaluators } = evaluation;\n  const progress = new ProgressBar({\n    total: examples.length,\n    format: \"Running Evaluators: {bar} {percentage}% | {value}/{total}\\n\",\n  });\n  const caller = new AsyncCaller({\n    maxConcurrency,\n  });\n  const requests = runs.map(\n    async (\n      run,\n      i\n    ): Promise<{\n      run_id: string;\n      execution_time?: number;\n      feedback: Feedback[];\n    }> =>\n      caller.call(async () => {\n        const evaluatorResults = await Promise.allSettled(\n          evaluators.map((evaluator) =>\n            client.evaluateRun(run, evaluator, {\n              referenceExample: examples[i],\n              loadChildRuns: false,\n            })\n          )\n        );\n        progress.increment();\n        return {\n          execution_time:\n            run?.end_time && run.start_time\n              ? new Date(run.end_time).getTime() -\n                new Date(run.start_time).getTime()\n              : undefined,\n          feedback: evaluatorResults.map((evalResult) =>\n            evalResult.status === \"fulfilled\"\n              ? evalResult.value\n              : evalResult.reason\n          ),\n          run_id: run.id,\n        };\n      })\n  );\n  const results = await Promise.all(requests);\n\n  return results.reduce(\n    (acc, result, i) => ({\n      ...acc,\n      [examples[i].id]: result,\n    }),\n    {}\n  );\n};\n\nexport type EvalResults = {\n  projectName: string;\n  results: {\n    [key: string]: {\n      execution_time?: number;\n      run_id: string;\n      feedback: Feedback[];\n    };\n  };\n};\n\nconst getExamplesInputs = (\n  examples: Example[],\n  chainOrFactory: ChainOrFactory,\n  dataType?: DataType\n) => {\n  if (dataType === \"chat\") {\n    // For some batty reason, we store the chat dataset differently.\n    // { type: \"system\", data: { content: inputs.input } },\n    // But we need to create AIMesage, SystemMessage, etc.\n    return examples.map(({ inputs }) =>\n      mapStoredMessagesToChatMessages(inputs.input)\n    );\n  }\n  // If it's a language model and ALL example inputs have a single value,\n  // then we can be friendly and flatten the inputs to a list of strings.\n  const isLanguageModel =\n    typeof chainOrFactory === \"object\" &&\n    typeof (chainOrFactory as BaseLanguageModel)._llmType === \"function\";\n  if (\n    isLanguageModel &&\n    examples.every(({ inputs }) => Object.keys(inputs).length === 1)\n  ) {\n    return examples.map(({ inputs }) => Object.values(inputs)[0]);\n  }\n  return examples.map(({ inputs }) => inputs);\n};\n\n/**\n * Evaluates a given model or chain against a specified LangSmith dataset.\n *\n * This function fetches example records from the specified dataset,\n * runs the model or chain against each example, and returns the evaluation\n * results.\n *\n * @param chainOrFactory - A model or factory/constructor function to be evaluated. It can be a\n * Runnable instance, a factory function that returns a Runnable, or a user-defined\n * function or factory.\n *\n * @param datasetName - The name of the dataset against which the evaluation will be\n * performed. This dataset should already be defined and contain the relevant data\n * for evaluation.\n *\n * @param options - (Optional) Additional parameters for the evaluation process:\n *   - `evaluators` (RunEvalType[]): Evaluators to apply to a dataset run.\n *   - `formatEvaluatorInputs` (EvaluatorInputFormatter): Convert the evaluation data into formats that can be used by the evaluator.\n *   - `projectName` (string): Name of the project for logging and tracking.\n *   - `projectMetadata` (Record<string, unknown>): Additional metadata for the project.\n *   - `client` (Client): Client instance for LangSmith service interaction.\n *   - `maxConcurrency` (number): Maximum concurrency level for dataset processing.\n *\n * @returns A promise that resolves to an `EvalResults` object. This object includes\n * detailed results of the evaluation, such as execution time, run IDs, and feedback\n * for each entry in the dataset.\n *\n * @example\n * ```typescript\n * // Example usage for evaluating a model on a dataset\n * async function evaluateModel() {\n *   const chain = /* ...create your model or chain...*\\//\n *   const datasetName = 'example-dataset';\n *   const client = new Client(/* ...config... *\\//);\n *\n *   const results = await runOnDataset(chain, datasetName, {\n *     evaluators: [/* ...evaluators... *\\//],\n *     client,\n *   });\n *\n *   console.log('Evaluation Results:', results);\n * }\n *\n * evaluateModel();\n * ```\n * In this example, `runOnDataset` is used to evaluate a language model (or a chain of models) against\n * a dataset named 'example-dataset'. The evaluation process is configured using `RunOnDatasetParams[\"evaluators\"]`, which can\n * include both standard and custom evaluators. The `Client` instance is used to interact with LangChain services.\n * The function returns the evaluation results, which can be logged or further processed as needed.\n */\n\nexport async function runOnDataset(\n  chainOrFactory: ChainOrFactory,\n  datasetName: string,\n  options?: RunOnDatasetParams\n) {\n  const {\n    projectName,\n    projectMetadata,\n    client,\n    maxConcurrency,\n  }: RunOnDatasetParams = options ?? {};\n\n  const evaluationConfig: RunEvalConfig | undefined =\n    options?.evaluationConfig ??\n    (options?.evaluators != null\n      ? {\n          evaluators: options.evaluators,\n          formatEvaluatorInputs: options.formatEvaluatorInputs,\n        }\n      : undefined);\n\n  const wrappedModel = await createWrappedModel(chainOrFactory);\n  const testClient = client ?? new Client();\n  const testProjectName = projectName ?? randomName();\n  const dataset = await testClient.readDataset({ datasetName });\n  const datasetId = dataset.id;\n  const testConcurrency = maxConcurrency ?? 5;\n  const { configs, examples, runExtractors } = await loadExamples({\n    datasetName,\n    client: testClient,\n    projectName: testProjectName,\n    maxConcurrency: testConcurrency,\n  });\n\n  await testClient.createProject({\n    projectName: testProjectName,\n    referenceDatasetId: datasetId,\n    projectExtra: { metadata: { ...projectMetadata } },\n  });\n  const wrappedRunnable: Runnable = new RunnableLambda({\n    func: wrappedModel,\n  }).withConfig({ runName: \"evaluationRun\" });\n  const runInputs = getExamplesInputs(\n    examples,\n    chainOrFactory,\n    dataset.data_type\n  );\n  const progress = new ProgressBar({\n    total: runInputs.length,\n    format: \"Predicting: {bar} {percentage}% | {value}/{total}\",\n  });\n  // TODO: Collect the runs as well.\n  await wrappedRunnable\n    .withListeners({\n      onEnd: () => progress.increment(),\n    })\n    // TODO: Insert evaluation inline for immediate feedback.\n    .batch(runInputs, configs, {\n      maxConcurrency,\n      returnExceptions: true,\n    });\n\n  progress.complete();\n  const runs: Run[] = [];\n  for (let i = 0; i < examples.length; i += 1) {\n    runs.push(await runExtractors[i].extract());\n  }\n  let evalResults: Record<\n    string,\n    { run_id: string; execution_time?: number; feedback: Feedback[] }\n  > = {};\n  if (evaluationConfig) {\n    const loadedEvalConfig =\n      await LoadedEvalConfig.fromRunEvalConfig(evaluationConfig);\n    evalResults = await applyEvaluators({\n      evaluation: loadedEvalConfig,\n      runs,\n      examples,\n      client: testClient,\n      maxConcurrency: testConcurrency,\n    });\n  }\n  const results: EvalResults = {\n    projectName: testProjectName,\n    results: evalResults ?? {},\n  };\n  return results;\n}\n\nfunction isLangsmithTraceableFunction(x: unknown): x is AnyTraceableFunction {\n  return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n"],"mappings":"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"}