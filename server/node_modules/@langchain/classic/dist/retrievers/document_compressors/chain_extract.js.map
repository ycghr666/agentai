{"version":3,"file":"chain_extract.js","names":[],"sources":["../../../src/retrievers/document_compressors/chain_extract.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { type DocumentInterface, Document } from \"@langchain/core/documents\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\nimport { BaseOutputParser } from \"@langchain/core/output_parsers\";\nimport { LLMChain } from \"../../chains/llm_chain.js\";\nimport { BaseDocumentCompressor } from \"./index.js\";\nimport { PROMPT_TEMPLATE } from \"./chain_extract_prompt.js\";\n\nfunction defaultGetInput(\n  query: string,\n  doc: DocumentInterface\n): Record<string, unknown> {\n  return { question: query, context: doc.pageContent };\n}\n\nclass NoOutputParser extends BaseOutputParser<string> {\n  lc_namespace = [\n    \"langchain\",\n    \"retrievers\",\n    \"document_compressors\",\n    \"chain_extract\",\n  ];\n\n  noOutputStr = \"NO_OUTPUT\";\n\n  parse(text: string): Promise<string> {\n    const cleanedText = text.trim();\n    if (cleanedText === this.noOutputStr) {\n      return Promise.resolve(\"\");\n    }\n    return Promise.resolve(cleanedText);\n  }\n\n  getFormatInstructions(): string {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n\nfunction getDefaultChainPrompt(): PromptTemplate {\n  const outputParser = new NoOutputParser();\n  const template = PROMPT_TEMPLATE(outputParser.noOutputStr);\n  return new PromptTemplate({\n    template,\n    inputVariables: [\"question\", \"context\"],\n    outputParser,\n  });\n}\n\n/**\n * Interface for the arguments required to create an instance of\n * LLMChainExtractor.\n */\nexport interface LLMChainExtractorArgs {\n  llmChain: LLMChain;\n  getInput: (query: string, doc: DocumentInterface) => Record<string, unknown>;\n}\n\n/**\n * A class that uses an LLM chain to extract relevant parts of documents.\n * It extends the BaseDocumentCompressor class.\n */\nexport class LLMChainExtractor extends BaseDocumentCompressor {\n  llmChain: LLMChain;\n\n  getInput: (query: string, doc: DocumentInterface) => Record<string, unknown> =\n    defaultGetInput;\n\n  constructor({ llmChain, getInput }: LLMChainExtractorArgs) {\n    super();\n    this.llmChain = llmChain;\n    this.getInput = getInput;\n  }\n\n  /**\n   * Compresses a list of documents based on the output of an LLM chain.\n   * @param documents The list of documents to be compressed.\n   * @param query The query to be used for document compression.\n   * @returns A list of compressed documents.\n   */\n  async compressDocuments(\n    documents: DocumentInterface[],\n    query: string\n  ): Promise<DocumentInterface[]> {\n    const compressedDocs = await Promise.all(\n      documents.map(async (doc) => {\n        const input = this.getInput(query, doc);\n        const output = await this.llmChain.predict(input);\n        return output.length > 0\n          ? new Document({\n              pageContent: output,\n              metadata: doc.metadata,\n            })\n          : undefined;\n      })\n    );\n    return compressedDocs.filter((doc): doc is Document => doc !== undefined);\n  }\n\n  /**\n   * Creates a new instance of LLMChainExtractor from a given LLM, prompt\n   * template, and getInput function.\n   * @param llm The BaseLanguageModel instance used for document extraction.\n   * @param prompt The PromptTemplate instance used for document extraction.\n   * @param getInput A function used for constructing the chain input from the query and a Document.\n   * @returns A new instance of LLMChainExtractor.\n   */\n  static fromLLM(\n    llm: BaseLanguageModelInterface,\n    prompt?: PromptTemplate,\n    getInput?: (\n      query: string,\n      doc: DocumentInterface\n    ) => Record<string, unknown>\n  ): LLMChainExtractor {\n    const _prompt = prompt || getDefaultChainPrompt();\n    const _getInput = getInput || defaultGetInput;\n    const llmChain = new LLMChain({ llm, prompt: _prompt });\n    return new LLMChainExtractor({ llmChain, getInput: _getInput });\n  }\n}\n"],"mappings":";;;;;;;;;;AAQA,SAAS,gBACP,OACA,KACyB;AACzB,QAAO;EAAE,UAAU;EAAO,SAAS,IAAI;EAAa;;AAGtD,IAAM,iBAAN,cAA6B,iBAAyB;CACpD,eAAe;EACb;EACA;EACA;EACA;EACD;CAED,cAAc;CAEd,MAAM,MAA+B;EACnC,MAAM,cAAc,KAAK,MAAM;AAC/B,MAAI,gBAAgB,KAAK,YACvB,QAAO,QAAQ,QAAQ,GAAG;AAE5B,SAAO,QAAQ,QAAQ,YAAY;;CAGrC,wBAAgC;AAC9B,QAAM,IAAI,MAAM,0BAA0B;;;AAI9C,SAAS,wBAAwC;CAC/C,MAAM,eAAe,IAAI,gBAAgB;AAEzC,QAAO,IAAI,eAAe;EACxB,UAFe,gBAAgB,aAAa,YAAY;EAGxD,gBAAgB,CAAC,YAAY,UAAU;EACvC;EACD,CAAC;;;;;;AAgBJ,IAAa,oBAAb,MAAa,0BAA0B,uBAAuB;CAC5D;CAEA,WACE;CAEF,YAAY,EAAE,UAAU,YAAmC;AACzD,SAAO;AACP,OAAK,WAAW;AAChB,OAAK,WAAW;;;;;;;;CASlB,MAAM,kBACJ,WACA,OAC8B;AAa9B,UAZuB,MAAM,QAAQ,IACnC,UAAU,IAAI,OAAO,QAAQ;GAC3B,MAAM,QAAQ,KAAK,SAAS,OAAO,IAAI;GACvC,MAAM,SAAS,MAAM,KAAK,SAAS,QAAQ,MAAM;AACjD,UAAO,OAAO,SAAS,IACnB,IAAI,SAAS;IACX,aAAa;IACb,UAAU,IAAI;IACf,CAAC,GACF;IACJ,CACH,EACqB,QAAQ,QAAyB,QAAQ,OAAU;;;;;;;;;;CAW3E,OAAO,QACL,KACA,QACA,UAImB;EACnB,MAAM,UAAU,UAAU,uBAAuB;EACjD,MAAM,YAAY,YAAY;AAE9B,SAAO,IAAI,kBAAkB;GAAE,UADd,IAAI,SAAS;IAAE;IAAK,QAAQ;IAAS,CAAC;GACd,UAAU;GAAW,CAAC"}