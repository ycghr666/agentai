{"version":3,"file":"structured.cjs","names":["BaseOutputParser","z","OutputParserException"],"sources":["../../src/output_parsers/structured.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport {\n  toJsonSchema,\n  type JsonSchema7Type,\n  type JsonSchema7ArrayType,\n  type JsonSchema7ObjectType,\n  type JsonSchema7StringType,\n  type JsonSchema7NumberType,\n  type JsonSchema7NullableType,\n} from \"@langchain/core/utils/json_schema\";\nimport {\n  BaseOutputParser,\n  FormatInstructionsOptions,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\nimport {\n  interopParseAsync,\n  type InferInteropZodOutput,\n  type InteropZodType,\n} from \"@langchain/core/utils/types\";\n\nexport type JsonMarkdownStructuredOutputParserInput = {\n  interpolationDepth?: number;\n};\n\nexport interface JsonMarkdownFormatInstructionsOptions extends FormatInstructionsOptions {\n  interpolationDepth?: number;\n}\n\nexport class StructuredOutputParser<\n  T extends InteropZodType,\n> extends BaseOutputParser<InferInteropZodOutput<T>> {\n  static lc_name() {\n    return \"StructuredOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"structured\"];\n\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n\n  constructor(public schema: T) {\n    super(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a Zod schema.\n   * @param schema The Zod schema which the output should match\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a set of names and\n   * descriptions.\n   * @param schemas An object where each key is a name and each value is a description\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this(zodSchema);\n  }\n\n  /**\n   * Returns a markdown code snippet with a JSON object formatted according\n   * to the schema.\n   * @param options Optional. The options for formatting the instructions\n   * @returns A markdown code snippet with a JSON object formatted according to the schema.\n   */\n  getFormatInstructions(): string {\n    return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(toJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n  }\n\n  /**\n   * Parses the given text according to the schema.\n   * @param text The text to parse\n   * @returns The parsed output.\n   */\n  async parse(text: string): Promise<InferInteropZodOutput<T>> {\n    try {\n      const json = text.includes(\"```\")\n        ? text.trim().split(/```(?:json)?/)[1]\n        : text.trim();\n      return await interopParseAsync(this.schema, JSON.parse(json));\n    } catch {\n      try {\n        return await interopParseAsync(this.schema, JSON.parse(text.trim()));\n      } catch (e2) {\n        throw new OutputParserException(\n          `Failed to parse. Text: \"${text}\". Error: ${e2}`,\n          text\n        );\n      }\n    }\n  }\n}\n\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser<\n  T extends InteropZodType,\n> extends StructuredOutputParser<T> {\n  static lc_name() {\n    return \"JsonMarkdownStructuredOutputParser\";\n  }\n\n  getFormatInstructions(\n    options?: JsonMarkdownFormatInstructionsOptions\n  ): string {\n    const interpolationDepth = options?.interpolationDepth ?? 1;\n    if (interpolationDepth < 1) {\n      throw new Error(\"f string interpolation depth must be at least 1\");\n    }\n\n    return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(\n      toJsonSchema(this.schema)\n    )\n      .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n      .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n  }\n\n  private _schemaToInstruction(\n    schemaInput: JsonSchema7Type,\n    indent = 2\n  ): string {\n    const schema = schemaInput as Extract<\n      JsonSchema7Type,\n      | JsonSchema7ObjectType\n      | JsonSchema7ArrayType\n      | JsonSchema7StringType\n      | JsonSchema7NumberType\n      | JsonSchema7NullableType\n    >;\n\n    if (\"type\" in schema) {\n      let nullable = false;\n      let type: string;\n      if (Array.isArray(schema.type)) {\n        const nullIdx = schema.type.findIndex((type) => type === \"null\");\n        if (nullIdx !== -1) {\n          nullable = true;\n          schema.type.splice(nullIdx, 1);\n        }\n        type = schema.type.join(\" | \") as string;\n      } else {\n        type = schema.type;\n      }\n\n      if (schema.type === \"object\" && schema.properties) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        const properties = Object.entries(schema.properties)\n          .map(([key, value]) => {\n            const isOptional = schema.required?.includes(key)\n              ? \"\"\n              : \" (optional)\";\n            return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(\n              value,\n              indent + 2\n            )}${isOptional}`;\n          })\n          .join(\"\\n\");\n        return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n      }\n      if (schema.type === \"array\" && schema.items) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(\n          schema.items,\n          indent + 2\n        )}\\n${\" \".repeat(indent - 2)}] ${description}`;\n      }\n      const isNullable = nullable ? \" (nullable)\" : \"\";\n      const description = schema.description ? ` // ${schema.description}` : \"\";\n      return `${type}${description}${isNullable}`;\n    }\n\n    if (\"anyOf\" in schema) {\n      return schema.anyOf\n        .map((s) => this._schemaToInstruction(s, indent))\n        .join(`\\n${\" \".repeat(indent - 2)}`);\n    }\n\n    throw new Error(\"unsupported schema type\");\n  }\n\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this<T>(schema);\n  }\n\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this<typeof zodSchema>(zodSchema);\n  }\n}\n\nexport interface AsymmetricStructuredOutputParserFields<\n  T extends InteropZodType,\n> {\n  inputSchema: T;\n}\n\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport abstract class AsymmetricStructuredOutputParser<\n  T extends InteropZodType,\n  Y = unknown,\n> extends BaseOutputParser<Y> {\n  private structuredInputParser: JsonMarkdownStructuredOutputParser<T>;\n\n  constructor({ inputSchema }: AsymmetricStructuredOutputParserFields<T>) {\n    super(...arguments);\n    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(\n      inputSchema\n    );\n  }\n\n  /**\n   * Processes the parsed input into the desired output format. Must be\n   * implemented by subclasses.\n   * @param input The parsed input\n   * @returns The processed output.\n   */\n  abstract outputProcessor(input: InferInteropZodOutput<T>): Promise<Y>;\n\n  async parse(text: string): Promise<Y> {\n    let parsedInput;\n    try {\n      parsedInput = await this.structuredInputParser.parse(text);\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n\n    return this.outputProcessor(parsedInput);\n  }\n\n  getFormatInstructions(): string {\n    return this.structuredInputParser.getFormatInstructions();\n  }\n}\n"],"mappings":"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"}