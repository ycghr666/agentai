{"version":3,"file":"call_expression_handler.cjs","names":["NodeHandler","ASTParser"],"sources":["../../../src/output_parsers/expression_type_handlers/call_expression_handler.ts"],"sourcesContent":["import { NodeHandler, ASTParser } from \"./base.js\";\nimport { CallExpressionType, MemberExpressionType } from \"./types.js\";\nimport type {\n  ExpressionNode,\n  CallExpression,\n  MemberExpression,\n} from \"../../types/expression-parser.js\";\n\n/**\n * Handles call expressions in the AST parsed by the `ASTParser`. This\n * class is part of the LangChain Expression Language (LCEL), a\n * declarative way to compose chains together in LangChain.\n */\nexport class CallExpressionHandler extends NodeHandler {\n  /**\n   * Checks if a given node is a call expression. If it is, it returns the\n   * node; otherwise, it returns false.\n   * @param node The node to check.\n   * @returns The node if it is a call expression, or false otherwise.\n   */\n  async accepts(node: ExpressionNode): Promise<CallExpression | boolean> {\n    if (ASTParser.isCallExpression(node)) {\n      return node;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Processes a call expression node. It checks the type of the callee (the\n   * function being called) and the arguments passed to it. If the callee is\n   * an identifier, it extracts the function name. If the callee is a member\n   * expression, it delegates handling to the parent handler. It also checks\n   * the types of the arguments and delegates their handling to the parent\n   * handler. The method returns an object representing the call expression,\n   * including the function call and its arguments.\n   * @param node The call expression node to process.\n   * @returns An object representing the call expression, including the function call and its arguments.\n   */\n  async handle(node: CallExpression): Promise<CallExpressionType> {\n    function checkCallExpressionArgumentType(arg: ExpressionNode): boolean {\n      return [\n        ASTParser.isStringLiteral,\n        ASTParser.isNumericLiteral,\n        ASTParser.isBooleanLiteral,\n        ASTParser.isArrayExpression,\n        ASTParser.isObjectExpression,\n        ASTParser.isCallExpression,\n        ASTParser.isIdentifier,\n      ].reduce((acc, func) => acc || func(arg), false);\n    }\n    if (this.parentHandler === undefined) {\n      throw new Error(\n        \"ArrayLiteralExpressionHandler must have a parent handler\"\n      );\n    }\n    const { callee } = node;\n    let funcCall;\n    if (ASTParser.isIdentifier(callee)) {\n      funcCall = callee.name.replace(/^[\"'](.+(?=[\"']$))[\"']$/, \"$1\");\n    } else if (ASTParser.isMemberExpression(callee)) {\n      funcCall = (await this.parentHandler.handle(\n        callee as MemberExpression\n      )) as MemberExpressionType;\n    } else {\n      throw new Error(\"Unknown expression type\");\n    }\n\n    const args = await Promise.all(\n      node.arguments.map((arg) => {\n        if (!checkCallExpressionArgumentType(arg)) {\n          throw new Error(\"Unknown argument type\");\n        }\n        if (!this.parentHandler) {\n          throw new Error(\"CallExpressionHandler must have a parent handler\");\n        }\n        return this.parentHandler.handle(arg as ExpressionNode);\n      })\n    );\n    return { type: \"call_expression\", funcCall, args };\n  }\n}\n"],"mappings":";;;;;;;;AAaA,IAAa,wBAAb,cAA2CA,yBAAY;;;;;;;CAOrD,MAAM,QAAQ,MAAyD;AACrE,MAAIC,uBAAU,iBAAiB,KAAK,CAClC,QAAO;MAEP,QAAO;;;;;;;;;;;;;CAeX,MAAM,OAAO,MAAmD;EAC9D,SAAS,gCAAgC,KAA8B;AACrE,UAAO;IACLA,uBAAU;IACVA,uBAAU;IACVA,uBAAU;IACVA,uBAAU;IACVA,uBAAU;IACVA,uBAAU;IACVA,uBAAU;IACX,CAAC,QAAQ,KAAK,SAAS,OAAO,KAAK,IAAI,EAAE,MAAM;;AAElD,MAAI,KAAK,kBAAkB,OACzB,OAAM,IAAI,MACR,2DACD;EAEH,MAAM,EAAE,WAAW;EACnB,IAAI;AACJ,MAAIA,uBAAU,aAAa,OAAO,CAChC,YAAW,OAAO,KAAK,QAAQ,2BAA2B,KAAK;WACtDA,uBAAU,mBAAmB,OAAO,CAC7C,YAAY,MAAM,KAAK,cAAc,OACnC,OACD;MAED,OAAM,IAAI,MAAM,0BAA0B;EAG5C,MAAM,OAAO,MAAM,QAAQ,IACzB,KAAK,UAAU,KAAK,QAAQ;AAC1B,OAAI,CAAC,gCAAgC,IAAI,CACvC,OAAM,IAAI,MAAM,wBAAwB;AAE1C,OAAI,CAAC,KAAK,cACR,OAAM,IAAI,MAAM,mDAAmD;AAErE,UAAO,KAAK,cAAc,OAAO,IAAsB;IACvD,CACH;AACD,SAAO;GAAE,MAAM;GAAmB;GAAU;GAAM"}