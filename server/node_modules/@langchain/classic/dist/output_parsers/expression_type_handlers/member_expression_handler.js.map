{"version":3,"file":"member_expression_handler.js","names":[],"sources":["../../../src/output_parsers/expression_type_handlers/member_expression_handler.ts"],"sourcesContent":["import { NodeHandler, ASTParser } from \"./base.js\";\nimport { MemberExpressionType } from \"./types.js\";\nimport type {\n  ExpressionNode,\n  MemberExpression,\n} from \"../../types/expression-parser.js\";\n\n/**\n * Handles member expressions in the LangChain Expression Language (LCEL).\n * Extends the NodeHandler base class.\n */\nexport class MemberExpressionHandler extends NodeHandler {\n  /**\n   * Checks if a given node is a member expression. If it is, the method\n   * returns the node; otherwise, it returns false.\n   * @param node The node to check.\n   * @returns The node if it is a member expression, or false otherwise.\n   */\n  async accepts(node: ExpressionNode): Promise<MemberExpression | boolean> {\n    if (ASTParser.isMemberExpression(node)) {\n      return node;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Processes a member expression node. It extracts the object and property\n   * from the node, validates their types, and returns an object with the\n   * type of the expression, the identifier, and the property.\n   * @param node The member expression node to process.\n   * @returns An object with the type of the expression, the identifier, and the property.\n   */\n  async handle(node: MemberExpression): Promise<MemberExpressionType> {\n    if (!this.parentHandler) {\n      throw new Error(\n        \"ArrayLiteralExpressionHandler must have a parent handler\"\n      );\n    }\n    const { object, property } = node;\n    let prop: string;\n    if (ASTParser.isIdentifier(property)) {\n      prop = property.name.replace(/^[\"'](.+(?=[\"']$))[\"']$/, \"$1\");\n    } else if (ASTParser.isStringLiteral(property)) {\n      prop = (`${property.value}` as string).replace(\n        /^[\"'](.+(?=[\"']$))[\"']$/,\n        \"$1\"\n      );\n    } else {\n      throw new Error(\"Invalid property key type\");\n    }\n    let identifier: string;\n    if (ASTParser.isIdentifier(object)) {\n      identifier = object.name.replace(/^[\"'](.+(?=[\"']$))[\"']$/, \"$1\");\n    } else if (ASTParser.isStringLiteral(object)) {\n      identifier = (`${object.value}` as string).replace(\n        /^[\"'](.+(?=[\"']$))[\"']$/,\n        \"$1\"\n      );\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (object.type !== \"Identifier\" && object.type !== \"StringLiteral\") {\n      throw new Error(\"ArrayExpression is not supported\");\n    }\n\n    return { type: \"member_expression\", identifier, property: prop };\n  }\n}\n"],"mappings":";;;;;;;AAWA,IAAa,0BAAb,cAA6C,YAAY;;;;;;;CAOvD,MAAM,QAAQ,MAA2D;AACvE,MAAI,UAAU,mBAAmB,KAAK,CACpC,QAAO;MAEP,QAAO;;;;;;;;;CAWX,MAAM,OAAO,MAAuD;AAClE,MAAI,CAAC,KAAK,cACR,OAAM,IAAI,MACR,2DACD;EAEH,MAAM,EAAE,QAAQ,aAAa;EAC7B,IAAI;AACJ,MAAI,UAAU,aAAa,SAAS,CAClC,QAAO,SAAS,KAAK,QAAQ,2BAA2B,KAAK;WACpD,UAAU,gBAAgB,SAAS,CAC5C,QAAQ,GAAG,SAAS,QAAmB,QACrC,2BACA,KACD;MAED,OAAM,IAAI,MAAM,4BAA4B;EAE9C,IAAI;AACJ,MAAI,UAAU,aAAa,OAAO,CAChC,cAAa,OAAO,KAAK,QAAQ,2BAA2B,KAAK;WACxD,UAAU,gBAAgB,OAAO,CAC1C,cAAc,GAAG,OAAO,QAAmB,QACzC,2BACA,KACD;MAED,OAAM,IAAI,MAAM,sBAAsB;AAExC,MAAI,OAAO,SAAS,gBAAgB,OAAO,SAAS,gBAClD,OAAM,IAAI,MAAM,mCAAmC;AAGrD,SAAO;GAAE,MAAM;GAAqB;GAAY,UAAU;GAAM"}