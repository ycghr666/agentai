{"version":3,"file":"regex.js","names":[],"sources":["../../src/output_parsers/regex.ts"],"sourcesContent":["import {\n  BaseOutputParser,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\n\nexport interface RegExpFields {\n  pattern: string;\n  flags?: string;\n}\n\n/**\n * Interface for the fields required to create a RegexParser instance.\n */\nexport interface RegexParserFields {\n  regex: string | RegExp | RegExpFields;\n  outputKeys: string[];\n  defaultOutputKey?: string;\n}\n\n/**\n * Class to parse the output of an LLM call into a dictionary.\n * @augments BaseOutputParser\n */\nexport class RegexParser extends BaseOutputParser<Record<string, string>> {\n  static lc_name() {\n    return \"RegexParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"regex\"];\n\n  lc_serializable = true;\n\n  get lc_attributes(): SerializedFields | undefined {\n    return {\n      regex: this.lc_kwargs.regex,\n    };\n  }\n\n  regex: string | RegExp;\n\n  outputKeys: string[];\n\n  defaultOutputKey?: string;\n\n  constructor(fields: RegexParserFields);\n\n  constructor(\n    regex: string | RegExp,\n    outputKeys: string[],\n    defaultOutputKey?: string\n  );\n\n  constructor(\n    fields: string | RegExp | RegexParserFields,\n    outputKeys?: string[],\n    defaultOutputKey?: string\n  ) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (typeof fields === \"string\" || fields instanceof RegExp) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { regex: fields, outputKeys: outputKeys!, defaultOutputKey };\n    }\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields.regex instanceof RegExp) {\n      fields.regex = {\n        pattern: fields.regex.source,\n        flags: fields.regex.flags,\n      };\n    }\n    super(fields);\n    this.regex =\n      typeof fields.regex === \"string\"\n        ? new RegExp(fields.regex)\n        : \"pattern\" in fields.regex\n          ? new RegExp(fields.regex.pattern, fields.regex.flags)\n          : fields.regex;\n    this.outputKeys = fields.outputKeys;\n    this.defaultOutputKey = fields.defaultOutputKey;\n  }\n\n  _type() {\n    return \"regex_parser\";\n  }\n\n  /**\n   * Parses the given text using the regex pattern and returns a dictionary\n   * with the parsed output. If the regex pattern does not match the text\n   * and no defaultOutputKey is provided, throws an OutputParserException.\n   * @param text The text to be parsed.\n   * @returns A dictionary with the parsed output.\n   */\n  async parse(text: string): Promise<Record<string, string>> {\n    const match = text.match(this.regex);\n    if (match) {\n      return this.outputKeys.reduce(\n        (acc, key, index) => {\n          acc[key] = match[index + 1];\n          return acc;\n        },\n        {} as Record<string, string>\n      );\n    }\n\n    if (this.defaultOutputKey === undefined) {\n      throw new OutputParserException(`Could not parse output: ${text}`, text);\n    }\n\n    return this.outputKeys.reduce(\n      (acc, key) => {\n        acc[key] = key === this.defaultOutputKey ? text : \"\";\n        return acc;\n      },\n      {} as Record<string, string>\n    );\n  }\n\n  /**\n   * Returns a string with instructions on how the LLM output should be\n   * formatted to match the regex pattern.\n   * @returns A string with formatting instructions.\n   */\n  getFormatInstructions(): string {\n    return `Your response should match the following regex: ${this.regex}`;\n  }\n}\n"],"mappings":";;;;;;;AAwBA,IAAa,cAAb,cAAiC,iBAAyC;CACxE,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe;EAAC;EAAa;EAAkB;EAAQ;CAEvD,kBAAkB;CAElB,IAAI,gBAA8C;AAChD,SAAO,EACL,OAAO,KAAK,UAAU,OACvB;;CAGH;CAEA;CAEA;CAUA,YACE,QACA,YACA,kBACA;AAEA,MAAI,OAAO,WAAW,YAAY,kBAAkB,OAElD,UAAS;GAAE,OAAO;GAAoB;GAAa;GAAkB;AAGvE,MAAI,OAAO,iBAAiB,OAC1B,QAAO,QAAQ;GACb,SAAS,OAAO,MAAM;GACtB,OAAO,OAAO,MAAM;GACrB;AAEH,QAAM,OAAO;AACb,OAAK,QACH,OAAO,OAAO,UAAU,WACpB,IAAI,OAAO,OAAO,MAAM,GACxB,aAAa,OAAO,QAClB,IAAI,OAAO,OAAO,MAAM,SAAS,OAAO,MAAM,MAAM,GACpD,OAAO;AACf,OAAK,aAAa,OAAO;AACzB,OAAK,mBAAmB,OAAO;;CAGjC,QAAQ;AACN,SAAO;;;;;;;;;CAUT,MAAM,MAAM,MAA+C;EACzD,MAAM,QAAQ,KAAK,MAAM,KAAK,MAAM;AACpC,MAAI,MACF,QAAO,KAAK,WAAW,QACpB,KAAK,KAAK,UAAU;AACnB,OAAI,OAAO,MAAM,QAAQ;AACzB,UAAO;KAET,EAAE,CACH;AAGH,MAAI,KAAK,qBAAqB,OAC5B,OAAM,IAAI,sBAAsB,2BAA2B,QAAQ,KAAK;AAG1E,SAAO,KAAK,WAAW,QACpB,KAAK,QAAQ;AACZ,OAAI,OAAO,QAAQ,KAAK,mBAAmB,OAAO;AAClD,UAAO;KAET,EAAE,CACH;;;;;;;CAQH,wBAAgC;AAC9B,SAAO,mDAAmD,KAAK"}