{"version":3,"file":"openai_tools.js","names":[],"sources":["../../src/output_parsers/openai_tools.ts"],"sourcesContent":["import { BaseLLMOutputParser } from \"@langchain/core/output_parsers\";\nimport type { ChatGeneration } from \"@langchain/core/outputs\";\n\n/**\n * @deprecated Import from \"@langchain/core/output_parsers/openai_tools\"\n */\nexport type ParsedToolCall = {\n  id?: string;\n\n  type: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: Record<string, any>;\n\n  /** @deprecated Use `type` instead. Will be removed in 0.2.0. */\n  name: string;\n\n  /** @deprecated Use `args` instead. Will be removed in 0.2.0. */\n  arguments: Record<string, any>; // eslint-disable-line @typescript-eslint/no-explicit-any\n};\n\n/**\n * @deprecated Import from \"@langchain/core/output_parsers/openai_tools\"\n */\nexport type JsonOutputToolsParserParams = {\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n};\n\n/**\n * @deprecated Import from \"@langchain/core/output_parsers/openai_tools\"\n */\nexport class JsonOutputToolsParser extends BaseLLMOutputParser<\n  ParsedToolCall[]\n> {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n\n  returnId = false;\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  constructor(fields?: JsonOutputToolsParserParams) {\n    super(fields);\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parseResult(generations: ChatGeneration[]): Promise<ParsedToolCall[]> {\n    const toolCalls = generations[0].message.additional_kwargs.tool_calls;\n    if (!toolCalls) {\n      throw new Error(\n        `No tools_call in message ${JSON.stringify(generations)}`\n      );\n    }\n    const clonedToolCalls = JSON.parse(JSON.stringify(toolCalls));\n    const parsedToolCalls = [];\n    for (const toolCall of clonedToolCalls) {\n      if (toolCall.function !== undefined) {\n        // @ts-expect-error name and arguemnts are defined by Object.defineProperty\n        const parsedToolCall: ParsedToolCall = {\n          type: toolCall.function.name,\n          args: JSON.parse(toolCall.function.arguments),\n        };\n\n        if (this.returnId) {\n          parsedToolCall.id = toolCall.id;\n        }\n\n        // backward-compatibility with previous\n        // versions of Langchain JS, which uses `name` and `arguments`\n        Object.defineProperty(parsedToolCall, \"name\", {\n          get() {\n            return this.type;\n          },\n        });\n\n        Object.defineProperty(parsedToolCall, \"arguments\", {\n          get() {\n            return this.args;\n          },\n        });\n\n        parsedToolCalls.push(parsedToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n\nexport type JsonOutputKeyToolsParserParams = {\n  keyName: string;\n  returnSingle?: boolean;\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n};\n\n/**\n * @deprecated Import from \"@langchain/core/output_parsers/openai_tools\"\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class JsonOutputKeyToolsParser extends BaseLLMOutputParser<any> {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  initialParser: JsonOutputToolsParser;\n\n  constructor(params: JsonOutputKeyToolsParserParams) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.initialParser = new JsonOutputToolsParser(params);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await this.initialParser.parseResult(generations);\n    const matchingResults = results.filter(\n      (result) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!this.returnId) {\n      returnedValues = matchingResults.map((result) => result.args);\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n}\n"],"mappings":";;;;;;AAgCA,IAAa,wBAAb,cAA2C,oBAEzC;CACA,OAAO,UAAU;AACf,SAAO;;CAGT,WAAW;CAEX,eAAe;EAAC;EAAa;EAAkB;EAAe;CAE9D,kBAAkB;CAElB,YAAY,QAAsC;AAChD,QAAM,OAAO;AACb,OAAK,WAAW,QAAQ,YAAY,KAAK;;;;;;;;CAS3C,MAAM,YAAY,aAA0D;EAC1E,MAAM,YAAY,YAAY,GAAG,QAAQ,kBAAkB;AAC3D,MAAI,CAAC,UACH,OAAM,IAAI,MACR,4BAA4B,KAAK,UAAU,YAAY,GACxD;EAEH,MAAM,kBAAkB,KAAK,MAAM,KAAK,UAAU,UAAU,CAAC;EAC7D,MAAM,kBAAkB,EAAE;AAC1B,OAAK,MAAM,YAAY,gBACrB,KAAI,SAAS,aAAa,QAAW;GAEnC,MAAM,iBAAiC;IACrC,MAAM,SAAS,SAAS;IACxB,MAAM,KAAK,MAAM,SAAS,SAAS,UAAU;IAC9C;AAED,OAAI,KAAK,SACP,gBAAe,KAAK,SAAS;AAK/B,UAAO,eAAe,gBAAgB,QAAQ,EAC5C,MAAM;AACJ,WAAO,KAAK;MAEf,CAAC;AAEF,UAAO,eAAe,gBAAgB,aAAa,EACjD,MAAM;AACJ,WAAO,KAAK;MAEf,CAAC;AAEF,mBAAgB,KAAK,eAAe;;AAGxC,SAAO;;;;;;AAeX,IAAa,2BAAb,cAA8C,oBAAyB;CACrE,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe;EAAC;EAAa;EAAkB;EAAe;CAE9D,kBAAkB;CAElB,WAAW;;CAGX;;CAGA,eAAe;CAEf;CAEA,YAAY,QAAwC;AAClD,QAAM,OAAO;AACb,OAAK,UAAU,OAAO;AACtB,OAAK,eAAe,OAAO,gBAAgB,KAAK;AAChD,OAAK,gBAAgB,IAAI,sBAAsB,OAAO;;CAIxD,MAAM,YAAY,aAA6C;EAE7D,MAAM,mBADU,MAAM,KAAK,cAAc,YAAY,YAAY,EACjC,QAC7B,WAAW,OAAO,SAAS,KAAK,QAClC;EAED,IAAI,iBACF;AACF,MAAI,CAAC,KAAK,SACR,kBAAiB,gBAAgB,KAAK,WAAW,OAAO,KAAK;AAE/D,MAAI,KAAK,aACP,QAAO,eAAe;AAExB,SAAO"}