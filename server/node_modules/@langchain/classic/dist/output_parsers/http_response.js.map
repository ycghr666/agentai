{"version":3,"file":"http_response.js","names":[],"sources":["../../src/output_parsers/http_response.ts"],"sourcesContent":["import { BaseMessage } from \"@langchain/core/messages\";\nimport {\n  BaseTransformOutputParser,\n  StringOutputParser,\n} from \"@langchain/core/output_parsers\";\n\nexport type HttpResponseOutputParserInput = {\n  outputParser?: BaseTransformOutputParser;\n  contentType?: \"text/plain\" | \"text/event-stream\";\n};\n\n/**\n * OutputParser that formats chunks emitted from an LLM for different HTTP content types.\n */\nexport class HttpResponseOutputParser extends BaseTransformOutputParser<Uint8Array> {\n  static lc_name() {\n    return \"HttpResponseOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parser\"];\n\n  lc_serializable = true;\n\n  outputParser: BaseTransformOutputParser = new StringOutputParser();\n\n  contentType: \"text/plain\" | \"text/event-stream\" = \"text/plain\";\n\n  constructor(fields?: HttpResponseOutputParserInput) {\n    super(fields);\n    this.outputParser = fields?.outputParser ?? this.outputParser;\n    this.contentType = fields?.contentType ?? this.contentType;\n  }\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<Uint8Array> {\n    for await (const chunk of this.outputParser._transform(inputGenerator)) {\n      if (typeof chunk === \"string\") {\n        yield this.parse(chunk);\n      } else {\n        yield this.parse(JSON.stringify(chunk));\n      }\n    }\n    if (this.contentType === \"text/event-stream\") {\n      const encoder = new TextEncoder();\n      yield encoder.encode(`event: end\\n\\n`);\n    }\n  }\n\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  async parse(text: string): Promise<Uint8Array> {\n    const chunk = await this.outputParser.parse(text);\n    const encoder = new TextEncoder();\n    if (this.contentType === \"text/event-stream\") {\n      return encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`);\n    }\n    let parsedChunk;\n    if (typeof chunk === \"string\") {\n      parsedChunk = chunk;\n    } else {\n      parsedChunk = JSON.stringify(chunk);\n    }\n    return encoder.encode(parsedChunk);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n"],"mappings":";;;;;;AAcA,IAAa,2BAAb,cAA8C,0BAAsC;CAClF,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe,CAAC,aAAa,gBAAgB;CAE7C,kBAAkB;CAElB,eAA0C,IAAI,oBAAoB;CAElE,cAAkD;CAElD,YAAY,QAAwC;AAClD,QAAM,OAAO;AACb,OAAK,eAAe,QAAQ,gBAAgB,KAAK;AACjD,OAAK,cAAc,QAAQ,eAAe,KAAK;;CAGjD,OAAO,WACL,gBAC4B;AAC5B,aAAW,MAAM,SAAS,KAAK,aAAa,WAAW,eAAe,CACpE,KAAI,OAAO,UAAU,SACnB,OAAM,KAAK,MAAM,MAAM;MAEvB,OAAM,KAAK,MAAM,KAAK,UAAU,MAAM,CAAC;AAG3C,MAAI,KAAK,gBAAgB,oBAEvB,OADgB,IAAI,aAAa,CACnB,OAAO,iBAAiB;;;;;;;;;;CAY1C,MAAM,MAAM,MAAmC;EAC7C,MAAM,QAAQ,MAAM,KAAK,aAAa,MAAM,KAAK;EACjD,MAAM,UAAU,IAAI,aAAa;AACjC,MAAI,KAAK,gBAAgB,oBACvB,QAAO,QAAQ,OAAO,sBAAsB,KAAK,UAAU,MAAM,CAAC,MAAM;EAE1E,IAAI;AACJ,MAAI,OAAO,UAAU,SACnB,eAAc;MAEd,eAAc,KAAK,UAAU,MAAM;AAErC,SAAO,QAAQ,OAAO,YAAY;;CAGpC,wBAAgC;AAC9B,SAAO"}