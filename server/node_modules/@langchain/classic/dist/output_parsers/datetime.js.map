{"version":3,"file":"datetime.js","names":[],"sources":["../../src/output_parsers/datetime.ts"],"sourcesContent":["import {\n  BaseOutputParser,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\n\n/**\n * Class to parse the output of an LLM call to a date.\n * @augments BaseOutputParser\n */\nexport class DatetimeOutputParser extends BaseOutputParser<Date> {\n  static lc_name() {\n    return \"DatetimeOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  /**\n   * ISO 8601 date time standard.\n   */\n  format = \"YYYY-MM-DDTHH:mm:ssZ\";\n\n  /**\n   * Parses the given text into a Date.\n   * If the parsing fails, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns A date object.\n   */\n  async parse(text: string): Promise<Date> {\n    const parsedDate = new Date(text.trim());\n    if (Number.isNaN(parsedDate.getTime())) {\n      throw new OutputParserException(`Could not parse output: ${text}`, text);\n    }\n    return parsedDate;\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CommaSeparatedListOutputParser.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return [\n      `Your response should be a datetime string that matches the following pattern: \"${this.format}\".`,\n      `Examples: 2011-10-05T14:48:00Z, 2019-01-01T00:00:00Z, 1932-04-21T04:42:23Z`,\n      `Return ONLY this string, no other words!`,\n    ].join(\"\\n\\n\");\n  }\n}\n"],"mappings":";;;;;;;AASA,IAAa,uBAAb,cAA0C,iBAAuB;CAC/D,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe,CAAC,aAAa,iBAAiB;CAE9C,kBAAkB;;;;CAKlB,SAAS;;;;;;;CAQT,MAAM,MAAM,MAA6B;EACvC,MAAM,aAAa,IAAI,KAAK,KAAK,MAAM,CAAC;AACxC,MAAI,OAAO,MAAM,WAAW,SAAS,CAAC,CACpC,OAAM,IAAI,sBAAsB,2BAA2B,QAAQ,KAAK;AAE1E,SAAO;;;;;;;CAQT,wBAAgC;AAC9B,SAAO;GACL,kFAAkF,KAAK,OAAO;GAC9F;GACA;GACD,CAAC,KAAK,OAAO"}