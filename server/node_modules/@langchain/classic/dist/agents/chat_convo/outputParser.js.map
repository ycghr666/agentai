{"version":3,"file":"outputParser.js","names":[],"sources":["../../../src/agents/chat_convo/outputParser.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport type { AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport {\n  FormatInstructionsOptions,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\nimport { renderTemplate } from \"@langchain/core/prompts\";\nimport { AgentActionOutputParser } from \"../types.js\";\nimport { FORMAT_INSTRUCTIONS } from \"./prompt.js\";\nimport { OutputFixingParser } from \"../../output_parsers/fix.js\";\n\nexport type ChatConversationalAgentOutputParserFormatInstructionsOptions =\n  FormatInstructionsOptions & {\n    toolNames: string[];\n    raw?: boolean;\n  };\n\n/**\n * Class that represents an output parser for the ChatConversationalAgent\n * class. It extends the AgentActionOutputParser class and provides\n * methods for parsing the output of the MRKL chain into agent actions.\n */\nexport class ChatConversationalAgentOutputParser extends AgentActionOutputParser {\n  lc_namespace = [\"langchain\", \"agents\", \"chat_convo\"];\n\n  private toolNames: string[];\n\n  constructor(fields: { toolNames: string[] }) {\n    super(...arguments);\n    this.toolNames = fields.toolNames;\n  }\n\n  /**\n   * Parses the given text into an AgentAction or AgentFinish object. If an\n   * output fixing parser is defined, uses it to parse the text.\n   * @param text Text to parse.\n   * @returns Promise that resolves to an AgentAction or AgentFinish object.\n   */\n  async parse(text: string): Promise<AgentAction | AgentFinish> {\n    let jsonOutput = text.trim();\n    if (jsonOutput.includes(\"```json\") || jsonOutput.includes(\"```\")) {\n      const testString = jsonOutput.includes(\"```json\") ? \"```json\" : \"```\";\n      const firstIndex = jsonOutput.indexOf(testString);\n      const actionInputIndex = jsonOutput.indexOf(\"action_input\");\n      if (actionInputIndex > firstIndex) {\n        jsonOutput = jsonOutput\n          .slice(firstIndex + testString.length)\n          .trimStart();\n        const lastIndex = jsonOutput.lastIndexOf(\"```\");\n        if (lastIndex !== -1) {\n          jsonOutput = jsonOutput.slice(0, lastIndex).trimEnd();\n        }\n      }\n    }\n\n    try {\n      const response = JSON.parse(jsonOutput);\n\n      const { action, action_input } = response;\n\n      if (action === \"Final Answer\") {\n        return { returnValues: { output: action_input }, log: text };\n      }\n      return { tool: action, toolInput: action_input, log: text };\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`\n      );\n    }\n  }\n\n  /**\n   * Returns the format instructions as a string. If the 'raw' option is\n   * true, returns the raw FORMAT_INSTRUCTIONS.\n   * @param options Options for getting the format instructions.\n   * @returns Format instructions as a string.\n   */\n  getFormatInstructions(): string {\n    return renderTemplate(FORMAT_INSTRUCTIONS, \"f-string\", {\n      tool_names: this.toolNames.join(\", \"),\n    });\n  }\n}\n\nexport type ChatConversationalAgentOutputParserArgs = {\n  baseParser?: ChatConversationalAgentOutputParser;\n  outputFixingParser?: OutputFixingParser<AgentAction | AgentFinish>;\n  toolNames?: string[];\n};\n\n/**\n * Class that represents an output parser with retries for the\n * ChatConversationalAgent class. It extends the AgentActionOutputParser\n * class and provides methods for parsing the output of the MRKL chain\n * into agent actions with retry functionality.\n */\nexport class ChatConversationalAgentOutputParserWithRetries extends AgentActionOutputParser {\n  lc_namespace = [\"langchain\", \"agents\", \"chat_convo\"];\n\n  private baseParser: ChatConversationalAgentOutputParser;\n\n  private outputFixingParser?: OutputFixingParser<AgentAction | AgentFinish>;\n\n  private toolNames: string[] = [];\n\n  constructor(fields: ChatConversationalAgentOutputParserArgs) {\n    super(fields);\n    this.toolNames = fields.toolNames ?? this.toolNames;\n    this.baseParser =\n      fields?.baseParser ??\n      new ChatConversationalAgentOutputParser({ toolNames: this.toolNames });\n    this.outputFixingParser = fields?.outputFixingParser;\n  }\n\n  /**\n   * Returns the format instructions as a string.\n   * @returns Format instructions as a string.\n   */\n  getFormatInstructions(\n    options: ChatConversationalAgentOutputParserFormatInstructionsOptions\n  ): string {\n    if (options.raw) {\n      return FORMAT_INSTRUCTIONS;\n    }\n    return renderTemplate(FORMAT_INSTRUCTIONS, \"f-string\", {\n      tool_names: options.toolNames.join(\", \"),\n    });\n  }\n\n  /**\n   * Parses the given text into an AgentAction or AgentFinish object.\n   * @param text Text to parse.\n   * @returns Promise that resolves to an AgentAction or AgentFinish object.\n   */\n  async parse(text: string): Promise<AgentAction | AgentFinish> {\n    if (this.outputFixingParser !== undefined) {\n      return this.outputFixingParser.parse(text);\n    }\n    return this.baseParser.parse(text);\n  }\n\n  /**\n   * Static method to create a new\n   * ChatConversationalAgentOutputParserWithRetries from a BaseLanguageModelInterface\n   * and options. If no base parser is provided in the options, a new\n   * ChatConversationalAgentOutputParser is created. An OutputFixingParser\n   * is also created from the BaseLanguageModelInterface and the base parser.\n   * @param llm BaseLanguageModelInterface instance used to create the OutputFixingParser.\n   * @param options Options for creating the ChatConversationalAgentOutputParserWithRetries instance.\n   * @returns A new instance of ChatConversationalAgentOutputParserWithRetries.\n   */\n  static fromLLM(\n    llm: BaseLanguageModelInterface,\n    options: Omit<ChatConversationalAgentOutputParserArgs, \"outputFixingParser\">\n  ): ChatConversationalAgentOutputParserWithRetries {\n    const baseParser =\n      options.baseParser ??\n      new ChatConversationalAgentOutputParser({\n        toolNames: options.toolNames ?? [],\n      });\n    const outputFixingParser = OutputFixingParser.fromLLM(llm, baseParser);\n    return new ChatConversationalAgentOutputParserWithRetries({\n      baseParser,\n      outputFixingParser,\n      toolNames: options.toolNames,\n    });\n  }\n}\n"],"mappings":";;;;;;;;;;;;AAsBA,IAAa,sCAAb,cAAyD,wBAAwB;CAC/E,eAAe;EAAC;EAAa;EAAU;EAAa;CAEpD,AAAQ;CAER,YAAY,QAAiC;AAC3C,QAAM,GAAG,UAAU;AACnB,OAAK,YAAY,OAAO;;;;;;;;CAS1B,MAAM,MAAM,MAAkD;EAC5D,IAAI,aAAa,KAAK,MAAM;AAC5B,MAAI,WAAW,SAAS,UAAU,IAAI,WAAW,SAAS,MAAM,EAAE;GAChE,MAAM,aAAa,WAAW,SAAS,UAAU,GAAG,YAAY;GAChE,MAAM,aAAa,WAAW,QAAQ,WAAW;AAEjD,OADyB,WAAW,QAAQ,eAAe,GACpC,YAAY;AACjC,iBAAa,WACV,MAAM,aAAa,WAAW,OAAO,CACrC,WAAW;IACd,MAAM,YAAY,WAAW,YAAY,MAAM;AAC/C,QAAI,cAAc,GAChB,cAAa,WAAW,MAAM,GAAG,UAAU,CAAC,SAAS;;;AAK3D,MAAI;GAGF,MAAM,EAAE,QAAQ,iBAFC,KAAK,MAAM,WAAW;AAIvC,OAAI,WAAW,eACb,QAAO;IAAE,cAAc,EAAE,QAAQ,cAAc;IAAE,KAAK;IAAM;AAE9D,UAAO;IAAE,MAAM;IAAQ,WAAW;IAAc,KAAK;IAAM;WACpD,GAAG;AACV,SAAM,IAAI,sBACR,2BAA2B,KAAK,YAAY,IAC7C;;;;;;;;;CAUL,wBAAgC;AAC9B,SAAO,eAAe,qBAAqB,YAAY,EACrD,YAAY,KAAK,UAAU,KAAK,KAAK,EACtC,CAAC;;;;;;;;;AAgBN,IAAa,iDAAb,MAAa,uDAAuD,wBAAwB;CAC1F,eAAe;EAAC;EAAa;EAAU;EAAa;CAEpD,AAAQ;CAER,AAAQ;CAER,AAAQ,YAAsB,EAAE;CAEhC,YAAY,QAAiD;AAC3D,QAAM,OAAO;AACb,OAAK,YAAY,OAAO,aAAa,KAAK;AAC1C,OAAK,aACH,QAAQ,cACR,IAAI,oCAAoC,EAAE,WAAW,KAAK,WAAW,CAAC;AACxE,OAAK,qBAAqB,QAAQ;;;;;;CAOpC,sBACE,SACQ;AACR,MAAI,QAAQ,IACV,QAAO;AAET,SAAO,eAAe,qBAAqB,YAAY,EACrD,YAAY,QAAQ,UAAU,KAAK,KAAK,EACzC,CAAC;;;;;;;CAQJ,MAAM,MAAM,MAAkD;AAC5D,MAAI,KAAK,uBAAuB,OAC9B,QAAO,KAAK,mBAAmB,MAAM,KAAK;AAE5C,SAAO,KAAK,WAAW,MAAM,KAAK;;;;;;;;;;;;CAapC,OAAO,QACL,KACA,SACgD;EAChD,MAAM,aACJ,QAAQ,cACR,IAAI,oCAAoC,EACtC,WAAW,QAAQ,aAAa,EAAE,EACnC,CAAC;AAEJ,SAAO,IAAI,+CAA+C;GACxD;GACA,oBAHyB,mBAAmB,QAAQ,KAAK,WAAW;GAIpE,WAAW,QAAQ;GACpB,CAAC"}