{"version":3,"file":"agent.cjs","names":["Serializable","RunnableSequence"],"sources":["../../src/agents/agent.ts"],"sourcesContent":["import type {\n  StructuredToolInterface,\n  ToolInterface,\n} from \"@langchain/core/tools\";\nimport type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { CallbackManager, Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { AgentAction, AgentFinish, AgentStep } from \"@langchain/core/agents\";\nimport { BaseMessage } from \"@langchain/core/messages\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\nimport {\n  Runnable,\n  patchConfig,\n  type RunnableConfig,\n  RunnableSequence,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { LLMChain } from \"../chains/llm_chain.js\";\nimport type {\n  AgentActionOutputParser,\n  AgentInput,\n  RunnableMultiActionAgentInput,\n  RunnableSingleActionAgentInput,\n  SerializedAgent,\n  StoppingMethod,\n} from \"./types.js\";\n\n/**\n * Record type for arguments passed to output parsers.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type OutputParserArgs = Record<string, any>;\n\n/**\n * Error class for parse errors in LangChain. Contains information about\n * the error message and the output that caused the error.\n */\nclass ParseError extends Error {\n  output: string;\n\n  constructor(msg: string, output: string) {\n    super(msg);\n    this.output = output;\n  }\n}\n\n/**\n * Abstract base class for agents in LangChain. Provides common\n * functionality for agents, such as handling inputs and outputs.\n */\nexport abstract class BaseAgent extends Serializable {\n  declare ToolType: StructuredToolInterface;\n\n  abstract get inputKeys(): string[];\n\n  get returnValues(): string[] {\n    return [\"output\"];\n  }\n\n  get allowedTools(): string[] | undefined {\n    return undefined;\n  }\n\n  /**\n   * Return the string type key uniquely identifying this class of agent.\n   */\n  _agentType(): string {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Return the string type key uniquely identifying multi or single action agents.\n   */\n  abstract _agentActionType(): string;\n\n  /**\n   * Return response when agent has been stopped due to max iterations\n   */\n  returnStoppedResponse(\n    earlyStoppingMethod: StoppingMethod,\n    _steps: AgentStep[],\n    _inputs: ChainValues,\n    _callbackManager?: CallbackManager\n  ): Promise<AgentFinish> {\n    if (earlyStoppingMethod === \"force\") {\n      return Promise.resolve({\n        returnValues: { output: \"Agent stopped due to max iterations.\" },\n        log: \"\",\n      });\n    }\n\n    throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`);\n  }\n\n  /**\n   * Prepare the agent for output, if needed\n   */\n  async prepareForOutput(\n    _returnValues: AgentFinish[\"returnValues\"],\n    _steps: AgentStep[]\n  ): Promise<AgentFinish[\"returnValues\"]> {\n    return {};\n  }\n}\n\n/**\n * Abstract base class for single action agents in LangChain. Extends the\n * BaseAgent class and provides additional functionality specific to\n * single action agents.\n */\nexport abstract class BaseSingleActionAgent extends BaseAgent {\n  _agentActionType(): string {\n    return \"single\" as const;\n  }\n\n  /**\n   * Decide what to do, given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   * @param callbackManager - Callback manager.\n   *\n   * @returns Action specifying what tool to use.\n   */\n  abstract plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager,\n    config?: RunnableConfig\n  ): Promise<AgentAction | AgentFinish>;\n}\n\n/**\n * Abstract base class for multi-action agents in LangChain. Extends the\n * BaseAgent class and provides additional functionality specific to\n * multi-action agents.\n */\nexport abstract class BaseMultiActionAgent extends BaseAgent {\n  _agentActionType(): string {\n    return \"multi\" as const;\n  }\n\n  /**\n   * Decide what to do, given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   * @param callbackManager - Callback manager.\n   *\n   * @returns Actions specifying what tools to use.\n   */\n  abstract plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager,\n    config?: RunnableConfig\n  ): Promise<AgentAction[] | AgentFinish>;\n}\n\nfunction isAgentAction(input: unknown): input is AgentAction {\n  return !Array.isArray(input) && (input as AgentAction)?.tool !== undefined;\n}\n\nexport function isRunnableAgent(x: BaseAgent) {\n  return (\n    (x as RunnableMultiActionAgent | RunnableSingleActionAgent).runnable !==\n    undefined\n  );\n}\n\n// TODO: Remove in the future. Only for backwards compatibility.\n// Allows for the creation of runnables with properties that will\n// be passed to the agent executor constructor.\nexport class AgentRunnableSequence<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n> extends RunnableSequence<RunInput, RunOutput> {\n  streamRunnable?: boolean;\n\n  singleAction: boolean;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromRunnables<RunInput = any, RunOutput = any>(\n    [first, ...runnables]: [\n      RunnableLike<RunInput>,\n      ...RunnableLike[],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      RunnableLike<any, RunOutput>,\n    ],\n    config: { singleAction: boolean; streamRunnable?: boolean; name?: string }\n  ): AgentRunnableSequence<RunInput, Exclude<RunOutput, Error>> {\n    const sequence = RunnableSequence.from(\n      [first, ...runnables],\n      config.name\n    ) as AgentRunnableSequence<RunInput, Exclude<RunOutput, Error>>;\n    sequence.singleAction = config.singleAction;\n    sequence.streamRunnable = config.streamRunnable;\n    return sequence;\n  }\n\n  static isAgentRunnableSequence(x: Runnable): x is AgentRunnableSequence {\n    return typeof (x as AgentRunnableSequence).singleAction === \"boolean\";\n  }\n}\n\n/**\n * Class representing a single-action agent powered by runnables.\n * Extends the BaseSingleActionAgent class and provides methods for\n * planning agent actions with runnables.\n */\nexport class RunnableSingleActionAgent extends BaseSingleActionAgent {\n  lc_namespace = [\"langchain\", \"agents\", \"runnable\"];\n\n  runnable: Runnable<\n    ChainValues & { steps: AgentStep[] },\n    AgentAction | AgentFinish\n  >;\n\n  get inputKeys(): string[] {\n    return [];\n  }\n\n  /**\n   * Whether to stream from the runnable or not.\n   * If true, the underlying LLM is invoked in a streaming fashion to make it\n   * possible to get access to the individual LLM tokens when using\n   * `streamLog` with the Agent Executor. If false then LLM is invoked in a\n   * non-streaming fashion and individual LLM tokens will not be available\n   * in `streamLog`.\n   *\n   * Note that the runnable should still only stream a single action or\n   * finish chunk.\n   */\n  streamRunnable = true;\n\n  defaultRunName = \"RunnableAgent\";\n\n  constructor(fields: RunnableSingleActionAgentInput) {\n    super(fields);\n    this.runnable = fields.runnable;\n    this.defaultRunName =\n      fields.defaultRunName ?? this.runnable.name ?? this.defaultRunName;\n    this.streamRunnable = fields.streamRunnable ?? this.streamRunnable;\n  }\n\n  async plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager,\n    config?: RunnableConfig\n  ): Promise<AgentAction | AgentFinish> {\n    const combinedInput = { ...inputs, steps };\n    const combinedConfig = patchConfig(config, {\n      callbacks: callbackManager,\n      runName: this.defaultRunName,\n    });\n    if (this.streamRunnable) {\n      const stream = await this.runnable.stream(combinedInput, combinedConfig);\n      let finalOutput: AgentAction | AgentFinish | undefined;\n      for await (const chunk of stream) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          throw new Error(\n            [\n              `Multiple agent actions/finishes received in streamed agent output.`,\n              `Set \"streamRunnable: false\" when initializing the agent to invoke this agent in non-streaming mode.`,\n            ].join(\"\\n\")\n          );\n        }\n      }\n      if (finalOutput === undefined) {\n        throw new Error(\n          [\n            \"No streaming output received from underlying runnable.\",\n            `Set \"streamRunnable: false\" when initializing the agent to invoke this agent in non-streaming mode.`,\n          ].join(\"\\n\")\n        );\n      }\n      return finalOutput;\n    } else {\n      return this.runnable.invoke(combinedInput, combinedConfig);\n    }\n  }\n}\n\n/**\n * Class representing a multi-action agent powered by runnables.\n * Extends the BaseMultiActionAgent class and provides methods for\n * planning agent actions with runnables.\n */\nexport class RunnableMultiActionAgent extends BaseMultiActionAgent {\n  lc_namespace = [\"langchain\", \"agents\", \"runnable\"];\n\n  // TODO: Rename input to \"intermediate_steps\"\n  runnable: Runnable<\n    ChainValues & { steps: AgentStep[] },\n    AgentAction[] | AgentAction | AgentFinish\n  >;\n\n  defaultRunName = \"RunnableAgent\";\n\n  stop?: string[];\n\n  streamRunnable = true;\n\n  get inputKeys(): string[] {\n    return [];\n  }\n\n  constructor(fields: RunnableMultiActionAgentInput) {\n    super(fields);\n    this.runnable = fields.runnable;\n    this.stop = fields.stop;\n    this.defaultRunName =\n      fields.defaultRunName ?? this.runnable.name ?? this.defaultRunName;\n    this.streamRunnable = fields.streamRunnable ?? this.streamRunnable;\n  }\n\n  async plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager,\n    config?: RunnableConfig\n  ): Promise<AgentAction[] | AgentFinish> {\n    const combinedInput = { ...inputs, steps };\n    const combinedConfig = patchConfig(config, {\n      callbacks: callbackManager,\n      runName: this.defaultRunName,\n    });\n    let output;\n    if (this.streamRunnable) {\n      const stream = await this.runnable.stream(combinedInput, combinedConfig);\n      let finalOutput: AgentAction | AgentFinish | AgentAction[] | undefined;\n      for await (const chunk of stream) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          throw new Error(\n            [\n              `Multiple agent actions/finishes received in streamed agent output.`,\n              `Set \"streamRunnable: false\" when initializing the agent to invoke this agent in non-streaming mode.`,\n            ].join(\"\\n\")\n          );\n        }\n      }\n      if (finalOutput === undefined) {\n        throw new Error(\n          [\n            \"No streaming output received from underlying runnable.\",\n            `Set \"streamRunnable: false\" when initializing the agent to invoke this agent in non-streaming mode.`,\n          ].join(\"\\n\")\n        );\n      }\n      output = finalOutput;\n    } else {\n      output = await this.runnable.invoke(combinedInput, combinedConfig);\n    }\n\n    if (isAgentAction(output)) {\n      return [output];\n    }\n\n    return output;\n  }\n}\n\nexport class RunnableAgent extends RunnableMultiActionAgent {}\n\n/**\n * Interface for input data for creating a LLMSingleActionAgent.\n */\nexport interface LLMSingleActionAgentInput {\n  llmChain: LLMChain;\n  outputParser: AgentActionOutputParser;\n  stop?: string[];\n}\n\n/**\n * Class representing a single action agent using a LLMChain in LangChain.\n * Extends the BaseSingleActionAgent class and provides methods for\n * planning agent actions based on LLMChain outputs.\n * @example\n * ```typescript\n * const customPromptTemplate = new CustomPromptTemplate({\n *   tools: [new Calculator()],\n *   inputVariables: [\"input\", \"agent_scratchpad\"],\n * });\n * const customOutputParser = new CustomOutputParser();\n * const agent = new LLMSingleActionAgent({\n *   llmChain: new LLMChain({\n *     prompt: customPromptTemplate,\n *     llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0 }),\n *   }),\n *   outputParser: customOutputParser,\n *   stop: [\"\\nObservation\"],\n * });\n * const executor = new AgentExecutor({\n *   agent,\n *   tools: [new Calculator()],\n * });\n * const result = await executor.invoke({\n *   input:\n *     \"Who is Olivia Wilde's boyfriend? What is his current age raised to the 0.23 power?\",\n * });\n * ```\n */\nexport class LLMSingleActionAgent extends BaseSingleActionAgent {\n  lc_namespace = [\"langchain\", \"agents\"];\n\n  llmChain: LLMChain;\n\n  outputParser: AgentActionOutputParser;\n\n  stop?: string[];\n\n  constructor(input: LLMSingleActionAgentInput) {\n    super(input);\n    this.stop = input.stop;\n    this.llmChain = input.llmChain;\n    this.outputParser = input.outputParser;\n  }\n\n  get inputKeys(): string[] {\n    return this.llmChain.inputKeys;\n  }\n\n  /**\n   * Decide what to do given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   * @param callbackManager - Callback manager.\n   *\n   * @returns Action specifying what tool to use.\n   */\n  async plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager\n  ): Promise<AgentAction | AgentFinish> {\n    const output = await this.llmChain.call(\n      {\n        intermediate_steps: steps,\n        stop: this.stop,\n        ...inputs,\n      },\n      callbackManager\n    );\n    return this.outputParser.parse(\n      output[this.llmChain.outputKey],\n      callbackManager\n    );\n  }\n}\n\n/**\n * Interface for arguments used to create an agent in LangChain.\n */\nexport interface AgentArgs {\n  outputParser?: AgentActionOutputParser;\n\n  callbacks?: Callbacks;\n\n  /**\n   * @deprecated Use `callbacks` instead.\n   */\n  callbackManager?: CallbackManager;\n}\n\n/**\n * Class responsible for calling a language model and deciding an action.\n *\n * @remarks This is driven by an LLMChain. The prompt in the LLMChain *must*\n * include a variable called \"agent_scratchpad\" where the agent can put its\n * intermediary work.\n */\nexport abstract class Agent extends BaseSingleActionAgent {\n  llmChain: LLMChain;\n\n  outputParser: AgentActionOutputParser | undefined;\n\n  private _allowedTools?: string[] = undefined;\n\n  get allowedTools(): string[] | undefined {\n    return this._allowedTools;\n  }\n\n  get inputKeys(): string[] {\n    return this.llmChain.inputKeys.filter((k) => k !== \"agent_scratchpad\");\n  }\n\n  constructor(input: AgentInput) {\n    super(input);\n\n    this.llmChain = input.llmChain;\n    this._allowedTools = input.allowedTools;\n    this.outputParser = input.outputParser;\n  }\n\n  /**\n   * Prefix to append the observation with.\n   */\n  abstract observationPrefix(): string;\n\n  /**\n   * Prefix to append the LLM call with.\n   */\n  abstract llmPrefix(): string;\n\n  /**\n   * Return the string type key uniquely identifying this class of agent.\n   */\n  abstract _agentType(): string;\n\n  /**\n   * Get the default output parser for this agent.\n   */\n  static getDefaultOutputParser(\n    _fields?: OutputParserArgs\n  ): AgentActionOutputParser {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Create a prompt for this class\n   *\n   * @param _tools - List of tools the agent will have access to, used to format the prompt.\n   * @param _fields - Additional fields used to format the prompt.\n   *\n   * @returns A PromptTemplate assembled from the given tools and fields.\n   * */\n  static createPrompt(\n    _tools: StructuredToolInterface[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _fields?: Record<string, any>\n  ): BasePromptTemplate {\n    throw new Error(\"Not implemented\");\n  }\n\n  /** Construct an agent from an LLM and a list of tools */\n  static fromLLMAndTools(\n    _llm: BaseLanguageModelInterface,\n    _tools: StructuredToolInterface[],\n\n    _args?: AgentArgs\n  ): Agent {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Validate that appropriate tools are passed in\n   */\n  static validateTools(_tools: StructuredToolInterface[]): void {}\n\n  _stop(): string[] {\n    return [`\\n${this.observationPrefix()}`];\n  }\n\n  /**\n   * Name of tool to use to terminate the chain.\n   */\n  finishToolName(): string {\n    return \"Final Answer\";\n  }\n\n  /**\n   * Construct a scratchpad to let the agent continue its thought process\n   */\n  async constructScratchPad(\n    steps: AgentStep[]\n  ): Promise<string | BaseMessage[]> {\n    return steps.reduce(\n      (thoughts, { action, observation }) =>\n        thoughts +\n        [\n          action.log,\n          `${this.observationPrefix()}${observation}`,\n          this.llmPrefix(),\n        ].join(\"\\n\"),\n      \"\"\n    );\n  }\n\n  private async _plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    suffix?: string,\n    callbackManager?: CallbackManager\n  ): Promise<AgentAction | AgentFinish> {\n    const thoughts = await this.constructScratchPad(steps);\n    const newInputs: ChainValues = {\n      ...inputs,\n      agent_scratchpad: suffix ? `${thoughts}${suffix}` : thoughts,\n    };\n\n    if (this._stop().length !== 0) {\n      newInputs.stop = this._stop();\n    }\n\n    const output = await this.llmChain.predict(newInputs, callbackManager);\n    if (!this.outputParser) {\n      throw new Error(\"Output parser not set\");\n    }\n    return this.outputParser.parse(output, callbackManager);\n  }\n\n  /**\n   * Decide what to do given some input.\n   *\n   * @param steps - Steps the LLM has taken so far, along with observations from each.\n   * @param inputs - User inputs.\n   * @param callbackManager - Callback manager to use for this call.\n   *\n   * @returns Action specifying what tool to use.\n   */\n  plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager\n  ): Promise<AgentAction | AgentFinish> {\n    return this._plan(steps, inputs, undefined, callbackManager);\n  }\n\n  /**\n   * Return response when agent has been stopped due to max iterations\n   */\n  async returnStoppedResponse(\n    earlyStoppingMethod: StoppingMethod,\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager\n  ): Promise<AgentFinish> {\n    if (earlyStoppingMethod === \"force\") {\n      return {\n        returnValues: { output: \"Agent stopped due to max iterations.\" },\n        log: \"\",\n      };\n    }\n\n    if (earlyStoppingMethod === \"generate\") {\n      try {\n        const action = await this._plan(\n          steps,\n          inputs,\n          \"\\n\\nI now need to return a final answer based on the previous steps:\",\n          callbackManager\n        );\n        if (\"returnValues\" in action) {\n          return action;\n        }\n\n        return { returnValues: { output: action.log }, log: action.log };\n      } catch (err) {\n        // fine to use instanceof because we're in the same module\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!(err instanceof ParseError)) {\n          throw err;\n        }\n        return { returnValues: { output: err.output }, log: err.output };\n      }\n    }\n\n    throw new Error(`Invalid stopping method: ${earlyStoppingMethod}`);\n  }\n\n  /**\n   * Load an agent from a json-like object describing it.\n   */\n  static async deserialize(\n    data: SerializedAgent & {\n      llm?: BaseLanguageModelInterface;\n      tools?: ToolInterface[];\n    }\n  ): Promise<Agent> {\n    switch (data._type) {\n      case \"zero-shot-react-description\": {\n        const { ZeroShotAgent } = await import(\"./mrkl/index.js\");\n        return ZeroShotAgent.deserialize(data);\n      }\n      default:\n        throw new Error(\"Unknown agent type\");\n    }\n  }\n}\n"],"mappings":"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"}