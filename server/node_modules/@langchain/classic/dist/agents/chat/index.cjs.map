{"version":3,"file":"index.cjs","names":["Agent","ChatAgentOutputParser","PREFIX","SUFFIX","FORMAT_INSTRUCTIONS","SystemMessagePromptTemplate","HumanMessagePromptTemplate","ChatPromptTemplate","LLMChain"],"sources":["../../../src/agents/chat/index.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport type { ToolInterface } from \"@langchain/core/tools\";\nimport {\n  ChatPromptTemplate,\n  HumanMessagePromptTemplate,\n  SystemMessagePromptTemplate,\n} from \"@langchain/core/prompts\";\nimport type { AgentStep } from \"@langchain/core/agents\";\nimport { LLMChain } from \"../../chains/llm_chain.js\";\nimport { Optional } from \"../../types/type-utils.js\";\nimport { Agent, AgentArgs, OutputParserArgs } from \"../agent.js\";\nimport { AgentInput } from \"../types.js\";\nimport { ChatAgentOutputParser } from \"./outputParser.js\";\nimport { FORMAT_INSTRUCTIONS, PREFIX, SUFFIX } from \"./prompt.js\";\n\nconst DEFAULT_HUMAN_MESSAGE_TEMPLATE = \"{input}\\n\\n{agent_scratchpad}\";\n\n/**\n * Interface for arguments used to create a chat prompt.\n */\nexport interface ChatCreatePromptArgs {\n  /** String to put after the list of tools. */\n  suffix?: string;\n  /** String to put before the list of tools. */\n  prefix?: string;\n  /** String to use directly as the human message template. */\n  humanMessageTemplate?: string;\n  /** Formattable string to use as the instructions template. */\n  formatInstructions?: string;\n  /** List of input variables the final prompt will expect. */\n  inputVariables?: string[];\n}\n\n/**\n * Type for input data for creating a ChatAgent, extending AgentInput with\n * optional 'outputParser'.\n */\nexport type ChatAgentInput = Optional<AgentInput, \"outputParser\">;\n\n/**\n * Agent for the MRKL chain.\n * @augments Agent\n */\nexport class ChatAgent extends Agent {\n  static lc_name() {\n    return \"ChatAgent\";\n  }\n\n  lc_namespace = [\"langchain\", \"agents\", \"chat\"];\n\n  declare ToolType: ToolInterface;\n\n  constructor(input: ChatAgentInput) {\n    const outputParser =\n      input?.outputParser ?? ChatAgent.getDefaultOutputParser();\n    super({ ...input, outputParser });\n  }\n\n  _agentType() {\n    return \"chat-zero-shot-react-description\" as const;\n  }\n\n  observationPrefix() {\n    return \"Observation: \";\n  }\n\n  llmPrefix() {\n    return \"Thought:\";\n  }\n\n  _stop(): string[] {\n    return [\"Observation:\"];\n  }\n\n  /**\n   * Validates that all tools have descriptions. Throws an error if a tool\n   * without a description is found.\n   * @param tools Array of Tool instances to validate.\n   * @returns void\n   */\n  static validateTools(tools: ToolInterface[]) {\n    const descriptionlessTool = tools.find((tool) => !tool.description);\n    if (descriptionlessTool) {\n      const msg =\n        `Got a tool ${descriptionlessTool.name} without a description.` +\n        ` This agent requires descriptions for all tools.`;\n      throw new Error(msg);\n    }\n  }\n\n  /**\n   * Returns a default output parser for the ChatAgent.\n   * @param _fields Optional OutputParserArgs to customize the output parser.\n   * @returns ChatAgentOutputParser instance\n   */\n  static getDefaultOutputParser(_fields?: OutputParserArgs) {\n    return new ChatAgentOutputParser();\n  }\n\n  /**\n   * Constructs the agent's scratchpad, which is a string representation of\n   * the agent's previous steps.\n   * @param steps Array of AgentStep instances representing the agent's previous steps.\n   * @returns Promise resolving to a string representing the agent's scratchpad.\n   */\n  async constructScratchPad(steps: AgentStep[]): Promise<string> {\n    const agentScratchpad = await super.constructScratchPad(steps);\n    if (agentScratchpad) {\n      return `This was your previous work (but I haven't seen any of it! I only see what you return as final answer):\\n${agentScratchpad}`;\n    }\n    return agentScratchpad;\n  }\n\n  /**\n   * Create prompt in the style of the zero shot agent.\n   *\n   * @param tools - List of tools the agent will have access to, used to format the prompt.\n   * @param args - Arguments to create the prompt with.\n   * @param args.suffix - String to put after the list of tools.\n   * @param args.prefix - String to put before the list of tools.\n   * @param args.humanMessageTemplate - String to use directly as the human message template\n   * @param args.formatInstructions - Formattable string to use as the instructions template\n   */\n  static createPrompt(tools: ToolInterface[], args?: ChatCreatePromptArgs) {\n    const {\n      prefix = PREFIX,\n      suffix = SUFFIX,\n      humanMessageTemplate = DEFAULT_HUMAN_MESSAGE_TEMPLATE,\n      formatInstructions = FORMAT_INSTRUCTIONS,\n    } = args ?? {};\n    const toolStrings = tools\n      .map((tool) => `${tool.name}: ${tool.description}`)\n      .join(\"\\n\");\n    const template = [prefix, toolStrings, formatInstructions, suffix].join(\n      \"\\n\\n\"\n    );\n    const messages = [\n      SystemMessagePromptTemplate.fromTemplate(template),\n      HumanMessagePromptTemplate.fromTemplate(humanMessageTemplate),\n    ];\n    return ChatPromptTemplate.fromMessages(messages);\n  }\n\n  /**\n   * Creates a ChatAgent instance using a language model, tools, and\n   * optional arguments.\n   * @param llm BaseLanguageModelInterface instance to use in the agent.\n   * @param tools Array of Tool instances to include in the agent.\n   * @param args Optional arguments to customize the agent and prompt.\n   * @returns ChatAgent instance\n   */\n  static fromLLMAndTools(\n    llm: BaseLanguageModelInterface,\n    tools: ToolInterface[],\n    args?: ChatCreatePromptArgs & AgentArgs\n  ) {\n    ChatAgent.validateTools(tools);\n    const prompt = ChatAgent.createPrompt(tools, args);\n    const chain = new LLMChain({\n      prompt,\n      llm,\n      callbacks: args?.callbacks ?? args?.callbackManager,\n    });\n    const outputParser =\n      args?.outputParser ?? ChatAgent.getDefaultOutputParser();\n\n    return new ChatAgent({\n      llmChain: chain,\n      outputParser,\n      allowedTools: tools.map((t) => t.name),\n    });\n  }\n}\n"],"mappings":";;;;;;;;AAeA,MAAM,iCAAiC;;;;;AA4BvC,IAAa,YAAb,MAAa,kBAAkBA,oBAAM;CACnC,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe;EAAC;EAAa;EAAU;EAAO;CAI9C,YAAY,OAAuB;EACjC,MAAM,eACJ,OAAO,gBAAgB,UAAU,wBAAwB;AAC3D,QAAM;GAAE,GAAG;GAAO;GAAc,CAAC;;CAGnC,aAAa;AACX,SAAO;;CAGT,oBAAoB;AAClB,SAAO;;CAGT,YAAY;AACV,SAAO;;CAGT,QAAkB;AAChB,SAAO,CAAC,eAAe;;;;;;;;CASzB,OAAO,cAAc,OAAwB;EAC3C,MAAM,sBAAsB,MAAM,MAAM,SAAS,CAAC,KAAK,YAAY;AACnE,MAAI,qBAAqB;GACvB,MAAM,MACJ,cAAc,oBAAoB,KAAK;AAEzC,SAAM,IAAI,MAAM,IAAI;;;;;;;;CASxB,OAAO,uBAAuB,SAA4B;AACxD,SAAO,IAAIC,4CAAuB;;;;;;;;CASpC,MAAM,oBAAoB,OAAqC;EAC7D,MAAM,kBAAkB,MAAM,MAAM,oBAAoB,MAAM;AAC9D,MAAI,gBACF,QAAO,4GAA4G;AAErH,SAAO;;;;;;;;;;;;CAaT,OAAO,aAAa,OAAwB,MAA6B;EACvE,MAAM,EACJ,SAASC,uBACT,SAASC,uBACT,uBAAuB,gCACvB,qBAAqBC,uCACnB,QAAQ,EAAE;EAId,MAAM,WAAW;GAAC;GAHE,MACjB,KAAK,SAAS,GAAG,KAAK,KAAK,IAAI,KAAK,cAAc,CAClD,KAAK,KAAK;GAC0B;GAAoB;GAAO,CAAC,KACjE,OACD;EACD,MAAM,WAAW,CACfC,oDAA4B,aAAa,SAAS,EAClDC,mDAA2B,aAAa,qBAAqB,CAC9D;AACD,SAAOC,2CAAmB,aAAa,SAAS;;;;;;;;;;CAWlD,OAAO,gBACL,KACA,OACA,MACA;AACA,YAAU,cAAc,MAAM;AAU9B,SAAO,IAAI,UAAU;GACnB,UATY,IAAIC,2BAAS;IACzB,QAFa,UAAU,aAAa,OAAO,KAAK;IAGhD;IACA,WAAW,MAAM,aAAa,MAAM;IACrC,CAAC;GAMA,cAJA,MAAM,gBAAgB,UAAU,wBAAwB;GAKxD,cAAc,MAAM,KAAK,MAAM,EAAE,KAAK;GACvC,CAAC"}