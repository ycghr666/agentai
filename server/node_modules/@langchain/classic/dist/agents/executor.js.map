{"version":3,"file":"executor.js","names":[],"sources":["../../src/agents/executor.ts"],"sourcesContent":["import {\n  type StructuredToolInterface,\n  type ToolInterface,\n  ToolInputParsingException,\n  Tool,\n} from \"@langchain/core/tools\";\nimport {\n  Runnable,\n  type RunnableConfig,\n  patchConfig,\n} from \"@langchain/core/runnables\";\nimport { AgentAction, AgentFinish, AgentStep } from \"@langchain/core/agents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport {\n  CallbackManager,\n  CallbackManagerForChainRun,\n  Callbacks,\n} from \"@langchain/core/callbacks/manager\";\nimport { OutputParserException } from \"@langchain/core/output_parsers\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\nimport { SerializedLLMChain } from \"../chains/serde.js\";\nimport { StoppingMethod } from \"./types.js\";\nimport {\n  AgentRunnableSequence,\n  BaseMultiActionAgent,\n  BaseSingleActionAgent,\n  RunnableMultiActionAgent,\n  RunnableSingleActionAgent,\n  isRunnableAgent,\n} from \"./agent.js\";\nimport { BaseChain, ChainInputs } from \"../chains/base.js\";\n\ninterface AgentExecutorIteratorInput {\n  agentExecutor: AgentExecutor;\n  inputs: Record<string, string>;\n  config?: RunnableConfig;\n  /** @deprecated Use \"config\" */\n  callbacks?: Callbacks;\n  /** @deprecated Use \"config\" */\n  tags?: string[];\n  /** @deprecated Use \"config\" */\n  metadata?: Record<string, unknown>;\n  runName?: string;\n  runManager?: CallbackManagerForChainRun;\n}\n\nexport class AgentExecutorIterator\n  extends Serializable\n  implements AgentExecutorIteratorInput\n{\n  lc_namespace = [\"langchain\", \"agents\", \"executor_iterator\"];\n\n  agentExecutor: AgentExecutor;\n\n  inputs: Record<string, string>;\n\n  config?: RunnableConfig;\n\n  /** @deprecated Use \"config\" */\n  callbacks?: Callbacks;\n\n  /** @deprecated Use \"config\" */\n  tags: string[] | undefined;\n\n  /** @deprecated Use \"config\" */\n  metadata: Record<string, unknown> | undefined;\n\n  /** @deprecated Use \"config\" */\n  runName: string | undefined;\n\n  private _finalOutputs: Record<string, unknown> | undefined;\n\n  get finalOutputs(): Record<string, unknown> | undefined {\n    return this._finalOutputs;\n  }\n\n  /** Intended to be used as a setter method, needs to be async. */\n  async setFinalOutputs(value: Record<string, unknown> | undefined) {\n    this._finalOutputs = undefined;\n    if (value) {\n      const preparedOutputs: Record<string, unknown> =\n        await this.agentExecutor.prepOutputs(this.inputs, value, true);\n      this._finalOutputs = preparedOutputs;\n    }\n  }\n\n  runManager: CallbackManagerForChainRun | undefined;\n\n  intermediateSteps: AgentStep[] = [];\n\n  iterations = 0;\n\n  get nameToToolMap(): Record<string, ToolInterface> {\n    const toolMap = this.agentExecutor.tools.map((tool) => ({\n      [tool.name]: tool,\n    }));\n    return Object.assign({}, ...toolMap);\n  }\n\n  constructor(fields: AgentExecutorIteratorInput) {\n    super(fields);\n    this.agentExecutor = fields.agentExecutor;\n    this.inputs = fields.inputs;\n    this.callbacks = fields.callbacks;\n    this.tags = fields.tags;\n    this.metadata = fields.metadata;\n    this.runName = fields.runName;\n    this.runManager = fields.runManager;\n    this.config = fields.config;\n  }\n\n  /**\n   * Reset the iterator to its initial state, clearing intermediate steps,\n   * iterations, and the final output.\n   */\n  reset(): void {\n    this.intermediateSteps = [];\n    this.iterations = 0;\n    this._finalOutputs = undefined;\n  }\n\n  updateIterations(): void {\n    this.iterations += 1;\n  }\n\n  async *streamIterator() {\n    this.reset();\n\n    // Loop to handle iteration\n    while (true) {\n      try {\n        if (this.iterations === 0) {\n          await this.onFirstStep();\n        }\n\n        const result = await this._callNext();\n        yield result;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (\n          \"message\" in e &&\n          e.message.startsWith(\"Final outputs already reached: \")\n        ) {\n          if (!this.finalOutputs) {\n            throw e;\n          }\n          return this.finalOutputs;\n        }\n        if (this.runManager) {\n          await this.runManager.handleChainError(e);\n        }\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Perform any necessary setup for the first step\n   * of the asynchronous iterator.\n   */\n  async onFirstStep(): Promise<void> {\n    if (this.iterations === 0) {\n      const callbackManager = await CallbackManager.configure(\n        this.callbacks ?? this.config?.callbacks,\n        this.agentExecutor.callbacks,\n        this.tags ?? this.config?.tags,\n        this.agentExecutor.tags,\n        this.metadata ?? this.config?.metadata,\n        this.agentExecutor.metadata,\n        {\n          verbose: this.agentExecutor.verbose,\n        }\n      );\n      this.runManager = await callbackManager?.handleChainStart(\n        this.agentExecutor.toJSON(),\n        this.inputs,\n        this.config?.runId,\n        undefined,\n        this.tags ?? this.config?.tags,\n        this.metadata ?? this.config?.metadata,\n        this.runName ?? this.config?.runName\n      );\n      if (this.config !== undefined) {\n        delete this.config.runId;\n      }\n    }\n  }\n\n  /**\n   * Execute the next step in the chain using the\n   * AgentExecutor's _takeNextStep method.\n   */\n  async _executeNextStep(\n    runManager?: CallbackManagerForChainRun\n  ): Promise<AgentFinish | AgentStep[]> {\n    return this.agentExecutor._takeNextStep(\n      this.nameToToolMap,\n      this.inputs,\n      this.intermediateSteps,\n      runManager,\n      this.config\n    );\n  }\n\n  /**\n   * Process the output of the next step,\n   * handling AgentFinish and tool return cases.\n   */\n  async _processNextStepOutput(\n    nextStepOutput: AgentFinish | AgentStep[],\n    runManager?: CallbackManagerForChainRun\n  ): Promise<Record<string, string | AgentStep[]>> {\n    if (\"returnValues\" in nextStepOutput) {\n      const output = await this.agentExecutor._return(\n        nextStepOutput as AgentFinish,\n        this.intermediateSteps,\n        runManager\n      );\n      if (this.runManager) {\n        await this.runManager.handleChainEnd(output);\n      }\n      await this.setFinalOutputs(output);\n      return output;\n    }\n\n    this.intermediateSteps = this.intermediateSteps.concat(\n      nextStepOutput as AgentStep[]\n    );\n\n    let output: Record<string, string | AgentStep[]> = {};\n    if (Array.isArray(nextStepOutput) && nextStepOutput.length === 1) {\n      const nextStep = nextStepOutput[0];\n      const toolReturn = await this.agentExecutor._getToolReturn(nextStep);\n      if (toolReturn) {\n        output = await this.agentExecutor._return(\n          toolReturn,\n          this.intermediateSteps,\n          runManager\n        );\n        await this.runManager?.handleChainEnd(output);\n        await this.setFinalOutputs(output);\n      }\n    }\n    output = { intermediateSteps: nextStepOutput as AgentStep[] };\n    return output;\n  }\n\n  async _stop(): Promise<Record<string, unknown>> {\n    const output = await this.agentExecutor.agent.returnStoppedResponse(\n      this.agentExecutor.earlyStoppingMethod,\n      this.intermediateSteps,\n      this.inputs\n    );\n    const returnedOutput = await this.agentExecutor._return(\n      output,\n      this.intermediateSteps,\n      this.runManager\n    );\n    await this.setFinalOutputs(returnedOutput);\n    await this.runManager?.handleChainEnd(returnedOutput);\n    return returnedOutput;\n  }\n\n  async _callNext(): Promise<Record<string, unknown>> {\n    // final output already reached: stopiteration (final output)\n    if (this.finalOutputs) {\n      throw new Error(\n        `Final outputs already reached: ${JSON.stringify(\n          this.finalOutputs,\n          null,\n          2\n        )}`\n      );\n    }\n    // timeout/max iterations: stopiteration (stopped response)\n    if (!this.agentExecutor.shouldContinueGetter(this.iterations)) {\n      return this._stop();\n    }\n    const nextStepOutput = await this._executeNextStep(this.runManager);\n    const output = await this._processNextStepOutput(\n      nextStepOutput,\n      this.runManager\n    );\n    this.updateIterations();\n    return output;\n  }\n}\n\ntype ExtractToolType<T> = T extends { ToolType: infer ToolInterface }\n  ? ToolInterface\n  : StructuredToolInterface;\n\n/**\n * Interface defining the structure of input data for creating an\n * AgentExecutor. It extends ChainInputs and includes additional\n * properties specific to agent execution.\n */\nexport interface AgentExecutorInput extends ChainInputs {\n  agent:\n    | BaseSingleActionAgent\n    | BaseMultiActionAgent\n    | Runnable<\n        ChainValues & { steps?: AgentStep[] },\n        AgentAction[] | AgentAction | AgentFinish\n      >;\n  tools: ExtractToolType<this[\"agent\"]>[];\n  returnIntermediateSteps?: boolean;\n  maxIterations?: number;\n  earlyStoppingMethod?: StoppingMethod;\n  handleParsingErrors?:\n    | boolean\n    | string\n    | ((e: OutputParserException | ToolInputParsingException) => string);\n  handleToolRuntimeErrors?: (e: Error) => string;\n}\n\n// TODO: Type properly with { intermediateSteps?: AgentStep[] };\nexport type AgentExecutorOutput = ChainValues;\n\n/**\n * Tool that just returns the query.\n * Used for exception tracking.\n */\nexport class ExceptionTool extends Tool {\n  name = \"_Exception\";\n\n  description = \"Exception tool\";\n\n  async _call(query: string) {\n    return query;\n  }\n}\n\n/**\n * A chain managing an agent using tools.\n * @augments BaseChain\n * @example\n * ```typescript\n *\n * const executor = AgentExecutor.fromAgentAndTools({\n *   agent: async () => loadAgentFromLangchainHub(),\n *   tools: [new SerpAPI(), new Calculator()],\n *   returnIntermediateSteps: true,\n * });\n *\n * const result = await executor.invoke({\n *   input: `Who is Olivia Wilde's boyfriend? What is his current age raised to the 0.23 power?`,\n * });\n *\n * ```\n */\nexport class AgentExecutor extends BaseChain<ChainValues, AgentExecutorOutput> {\n  static lc_name() {\n    return \"AgentExecutor\";\n  }\n\n  get lc_namespace() {\n    return [\"langchain\", \"agents\", \"executor\"];\n  }\n\n  agent: BaseSingleActionAgent | BaseMultiActionAgent;\n\n  tools: this[\"agent\"][\"ToolType\"][];\n\n  returnIntermediateSteps = false;\n\n  maxIterations?: number = 15;\n\n  earlyStoppingMethod: StoppingMethod = \"force\";\n\n  // TODO: Update BaseChain implementation on breaking change to include this\n  returnOnlyOutputs = true;\n\n  /**\n   * How to handle errors raised by the agent's output parser.\n    Defaults to `False`, which raises the error.\n\n    If `true`, the error will be sent back to the LLM as an observation.\n    If a string, the string itself will be sent to the LLM as an observation.\n    If a callable function, the function will be called with the exception\n    as an argument, and the result of that function will be passed to the agent\n    as an observation.\n   */\n  handleParsingErrors:\n    | boolean\n    | string\n    | ((e: OutputParserException | ToolInputParsingException) => string) =\n    false;\n\n  handleToolRuntimeErrors?: (e: Error) => string;\n\n  get inputKeys() {\n    return this.agent.inputKeys;\n  }\n\n  get outputKeys() {\n    return this.agent.returnValues;\n  }\n\n  constructor(input: AgentExecutorInput) {\n    let agent: BaseSingleActionAgent | BaseMultiActionAgent;\n    let returnOnlyOutputs = true;\n    if (Runnable.isRunnable(input.agent)) {\n      if (AgentRunnableSequence.isAgentRunnableSequence(input.agent)) {\n        if (input.agent.singleAction) {\n          agent = new RunnableSingleActionAgent({\n            runnable: input.agent,\n            streamRunnable: input.agent.streamRunnable,\n          });\n        } else {\n          agent = new RunnableMultiActionAgent({\n            runnable: input.agent,\n            streamRunnable: input.agent.streamRunnable,\n          });\n        }\n      } else {\n        agent = new RunnableMultiActionAgent({ runnable: input.agent });\n      }\n      // TODO: Update BaseChain implementation on breaking change\n      returnOnlyOutputs = false;\n    } else {\n      if (isRunnableAgent(input.agent)) {\n        returnOnlyOutputs = false;\n      }\n      agent = input.agent;\n    }\n\n    super(input);\n    this.agent = agent;\n    this.tools = input.tools;\n    this.handleParsingErrors =\n      input.handleParsingErrors ?? this.handleParsingErrors;\n    this.handleToolRuntimeErrors = input.handleToolRuntimeErrors;\n    this.returnOnlyOutputs = returnOnlyOutputs;\n    if (this.agent._agentActionType() === \"multi\") {\n      for (const tool of this.tools) {\n        if (tool.returnDirect) {\n          throw new Error(\n            `Tool with return direct ${tool.name} not supported for multi-action agent.`\n          );\n        }\n      }\n    }\n    this.returnIntermediateSteps =\n      input.returnIntermediateSteps ?? this.returnIntermediateSteps;\n    this.maxIterations = input.maxIterations ?? this.maxIterations;\n    this.earlyStoppingMethod =\n      input.earlyStoppingMethod ?? this.earlyStoppingMethod;\n  }\n\n  /** Create from agent and a list of tools. */\n  static fromAgentAndTools(fields: AgentExecutorInput): AgentExecutor {\n    return new AgentExecutor(fields);\n  }\n\n  get shouldContinueGetter() {\n    return this.shouldContinue.bind(this);\n  }\n\n  /**\n   * Method that checks if the agent execution should continue based on the\n   * number of iterations.\n   * @param iterations The current number of iterations.\n   * @returns A boolean indicating whether the agent execution should continue.\n   */\n  private shouldContinue(iterations: number): boolean {\n    return this.maxIterations === undefined || iterations < this.maxIterations;\n  }\n\n  /** @ignore */\n  async _call(\n    inputs: ChainValues,\n    runManager?: CallbackManagerForChainRun,\n    config?: RunnableConfig\n  ): Promise<AgentExecutorOutput> {\n    const toolsByName = Object.fromEntries(\n      this.tools.map((t) => [t.name.toLowerCase(), t])\n    );\n    const steps: AgentStep[] = [];\n    let iterations = 0;\n\n    const getOutput = async (\n      finishStep: AgentFinish\n    ): Promise<AgentExecutorOutput> => {\n      const { returnValues } = finishStep;\n      const additional = await this.agent.prepareForOutput(returnValues, steps);\n\n      await runManager?.handleAgentEnd(finishStep);\n\n      let response;\n\n      if (this.returnIntermediateSteps) {\n        response = { ...returnValues, intermediateSteps: steps, ...additional };\n      } else {\n        response = { ...returnValues, ...additional };\n      }\n      if (!this.returnOnlyOutputs) {\n        response = { ...inputs, ...response };\n      }\n      return response;\n    };\n\n    while (this.shouldContinue(iterations)) {\n      let output;\n      try {\n        output = await this.agent.plan(\n          steps,\n          inputs,\n          runManager?.getChild(),\n          config\n        );\n      } catch (e) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (e instanceof OutputParserException) {\n          let observation;\n          let text = e.message;\n          if (this.handleParsingErrors === true) {\n            if (e.sendToLLM) {\n              observation = e.observation;\n              text = e.llmOutput ?? \"\";\n            } else {\n              observation = \"Invalid or incomplete response\";\n            }\n          } else if (typeof this.handleParsingErrors === \"string\") {\n            observation = this.handleParsingErrors;\n          } else if (typeof this.handleParsingErrors === \"function\") {\n            observation = this.handleParsingErrors(e);\n          } else {\n            throw e;\n          }\n          output = {\n            tool: \"_Exception\",\n            toolInput: observation,\n            log: text,\n          } as AgentAction;\n        } else {\n          throw e;\n        }\n      }\n      // Check if the agent has finished\n      if (\"returnValues\" in output) {\n        return getOutput(output);\n      }\n\n      let actions: AgentAction[];\n      if (Array.isArray(output)) {\n        actions = output as AgentAction[];\n      } else {\n        actions = [output as AgentAction];\n      }\n\n      const newSteps = await Promise.all(\n        actions.map(async (action) => {\n          await runManager?.handleAgentAction(action);\n          const tool =\n            action.tool === \"_Exception\"\n              ? new ExceptionTool()\n              : toolsByName[action.tool?.toLowerCase()];\n          let observation;\n          try {\n            observation = tool\n              ? await tool.invoke(\n                  action.toolInput,\n                  patchConfig(config, { callbacks: runManager?.getChild() })\n                )\n              : `${action.tool} is not a valid tool, try another one.`;\n            if (typeof observation !== \"string\") {\n              throw new Error(\n                \"Received unsupported non-string response from tool call.\"\n              );\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } catch (e: any) {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (e instanceof ToolInputParsingException) {\n              if (this.handleParsingErrors === true) {\n                observation =\n                  \"Invalid or incomplete tool input. Please try again.\";\n              } else if (typeof this.handleParsingErrors === \"string\") {\n                observation = this.handleParsingErrors;\n              } else if (typeof this.handleParsingErrors === \"function\") {\n                observation = this.handleParsingErrors(e);\n              } else {\n                throw e;\n              }\n              observation = await new ExceptionTool().call(\n                observation,\n                runManager?.getChild()\n              );\n              return { action, observation: observation ?? \"\" };\n            } else if (this.handleToolRuntimeErrors !== undefined) {\n              observation = this.handleToolRuntimeErrors(e);\n            }\n          }\n\n          return { action, observation: observation ?? \"\" };\n        })\n      );\n\n      steps.push(...newSteps);\n\n      const lastStep = steps[steps.length - 1];\n      const lastTool = toolsByName[lastStep.action.tool?.toLowerCase()];\n\n      if (lastTool?.returnDirect) {\n        return getOutput({\n          returnValues: { [this.agent.returnValues[0]]: lastStep.observation },\n          log: \"\",\n        });\n      }\n\n      iterations += 1;\n    }\n\n    const finish = await this.agent.returnStoppedResponse(\n      this.earlyStoppingMethod,\n      steps,\n      inputs\n    );\n\n    return getOutput(finish);\n  }\n\n  async _takeNextStep(\n    nameToolMap: Record<string, ToolInterface>,\n    inputs: ChainValues,\n    intermediateSteps: AgentStep[],\n    runManager?: CallbackManagerForChainRun,\n    config?: RunnableConfig\n  ): Promise<AgentFinish | AgentStep[]> {\n    let output;\n    try {\n      output = await this.agent.plan(\n        intermediateSteps,\n        inputs,\n        runManager?.getChild(),\n        config\n      );\n    } catch (e) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (e instanceof OutputParserException) {\n        let observation;\n        let text = e.message;\n        if (this.handleParsingErrors === true) {\n          if (e.sendToLLM) {\n            observation = e.observation;\n            text = e.llmOutput ?? \"\";\n          } else {\n            observation = \"Invalid or incomplete response\";\n          }\n        } else if (typeof this.handleParsingErrors === \"string\") {\n          observation = this.handleParsingErrors;\n        } else if (typeof this.handleParsingErrors === \"function\") {\n          observation = this.handleParsingErrors(e);\n        } else {\n          throw e;\n        }\n        output = {\n          tool: \"_Exception\",\n          toolInput: observation,\n          log: text,\n        } as AgentAction;\n      } else {\n        throw e;\n      }\n    }\n\n    if (\"returnValues\" in output) {\n      return output;\n    }\n\n    let actions: AgentAction[];\n    if (Array.isArray(output)) {\n      actions = output as AgentAction[];\n    } else {\n      actions = [output as AgentAction];\n    }\n\n    const result: AgentStep[] = [];\n    for (const agentAction of actions) {\n      let observation = \"\";\n      if (runManager) {\n        await runManager?.handleAgentAction(agentAction);\n      }\n      if (agentAction.tool in nameToolMap) {\n        const tool = nameToolMap[agentAction.tool];\n        try {\n          observation = await tool.call(\n            agentAction.toolInput,\n            runManager?.getChild()\n          );\n          if (typeof observation !== \"string\") {\n            throw new Error(\n              \"Received unsupported non-string response from tool call.\"\n            );\n          }\n        } catch (e) {\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          if (e instanceof ToolInputParsingException) {\n            if (this.handleParsingErrors === true) {\n              observation =\n                \"Invalid or incomplete tool input. Please try again.\";\n            } else if (typeof this.handleParsingErrors === \"string\") {\n              observation = this.handleParsingErrors;\n            } else if (typeof this.handleParsingErrors === \"function\") {\n              observation = this.handleParsingErrors(e);\n            } else {\n              throw e;\n            }\n            observation = await new ExceptionTool().call(\n              observation,\n              runManager?.getChild()\n            );\n          }\n        }\n      } else {\n        observation = `${\n          agentAction.tool\n        } is not a valid tool, try another available tool: ${Object.keys(\n          nameToolMap\n        ).join(\", \")}`;\n      }\n      result.push({\n        action: agentAction,\n        observation,\n      });\n    }\n    return result;\n  }\n\n  async _return(\n    output: AgentFinish,\n    intermediateSteps: AgentStep[],\n    runManager?: CallbackManagerForChainRun\n  ): Promise<AgentExecutorOutput> {\n    if (runManager) {\n      await runManager.handleAgentEnd(output);\n    }\n    const finalOutput: Record<string, unknown> = output.returnValues;\n    if (this.returnIntermediateSteps) {\n      finalOutput.intermediateSteps = intermediateSteps;\n    }\n    return finalOutput;\n  }\n\n  async _getToolReturn(nextStepOutput: AgentStep): Promise<AgentFinish | null> {\n    const { action, observation } = nextStepOutput;\n    const nameToolMap = Object.fromEntries(\n      this.tools.map((t) => [t.name.toLowerCase(), t])\n    );\n    const [returnValueKey = \"output\"] = this.agent.returnValues;\n    // Invalid tools won't be in the map, so we return False.\n    if (action.tool in nameToolMap) {\n      if (nameToolMap[action.tool].returnDirect) {\n        return {\n          returnValues: { [returnValueKey]: observation },\n          log: \"\",\n        };\n      }\n    }\n    return null;\n  }\n\n  _returnStoppedResponse(earlyStoppingMethod: StoppingMethod) {\n    if (earlyStoppingMethod === \"force\") {\n      return {\n        returnValues: {\n          output: \"Agent stopped due to iteration limit or time limit.\",\n        },\n        log: \"\",\n      } as AgentFinish;\n    }\n    throw new Error(\n      `Got unsupported early_stopping_method: ${earlyStoppingMethod}`\n    );\n  }\n\n  async *_streamIterator(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputs: Record<string, any>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<ChainValues> {\n    const agentExecutorIterator = new AgentExecutorIterator({\n      inputs,\n      agentExecutor: this,\n      config: options,\n      // TODO: Deprecate these other parameters\n      metadata: options?.metadata,\n      tags: options?.tags,\n      callbacks: options?.callbacks,\n    });\n    const iterator = agentExecutorIterator.streamIterator();\n    for await (const step of iterator) {\n      if (!step) {\n        continue;\n      }\n      yield step;\n    }\n  }\n\n  _chainType() {\n    return \"agent_executor\" as const;\n  }\n\n  serialize(): SerializedLLMChain {\n    throw new Error(\"Cannot serialize an AgentExecutor\");\n  }\n}\n"],"mappings":"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"}