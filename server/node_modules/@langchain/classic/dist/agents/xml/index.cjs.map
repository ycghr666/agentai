{"version":3,"file":"index.cjs","names":["BaseSingleActionAgent","XMLAgentOutputParser","ChatPromptTemplate","HumanMessagePromptTemplate","AGENT_INSTRUCTIONS","AIMessagePromptTemplate","LLMChain","renderTextDescription","AgentRunnableSequence","RunnablePassthrough","formatXml"],"sources":["../../../src/agents/xml/index.ts"],"sourcesContent":["import type {\n  BaseLanguageModel,\n  BaseLanguageModelInterface,\n} from \"@langchain/core/language_models/base\";\nimport type { ToolInterface } from \"@langchain/core/tools\";\nimport { RunnablePassthrough } from \"@langchain/core/runnables\";\nimport type { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { AgentStep, AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport {\n  AIMessagePromptTemplate,\n  ChatPromptTemplate,\n  HumanMessagePromptTemplate,\n} from \"@langchain/core/prompts\";\nimport { CallbackManager } from \"@langchain/core/callbacks/manager\";\nimport { LLMChain } from \"../../chains/llm_chain.js\";\nimport {\n  AgentArgs,\n  AgentRunnableSequence,\n  BaseSingleActionAgent,\n} from \"../agent.js\";\nimport { AGENT_INSTRUCTIONS } from \"./prompt.js\";\nimport { XMLAgentOutputParser } from \"./output_parser.js\";\nimport { renderTextDescription } from \"../../tools/render.js\";\nimport { formatXml } from \"../format_scratchpad/xml.js\";\n\n/**\n * Interface for the input to the XMLAgent class.\n */\nexport interface XMLAgentInput {\n  tools: ToolInterface[];\n  llmChain: LLMChain;\n}\n\n/**\n * Class that represents an agent that uses XML tags.\n */\nexport class XMLAgent extends BaseSingleActionAgent implements XMLAgentInput {\n  static lc_name() {\n    return \"XMLAgent\";\n  }\n\n  lc_namespace = [\"langchain\", \"agents\", \"xml\"];\n\n  tools: ToolInterface[];\n\n  llmChain: LLMChain;\n\n  outputParser: XMLAgentOutputParser = new XMLAgentOutputParser();\n\n  _agentType() {\n    return \"xml\" as const;\n  }\n\n  constructor(fields: XMLAgentInput) {\n    super(fields);\n    this.tools = fields.tools;\n    this.llmChain = fields.llmChain;\n  }\n\n  get inputKeys() {\n    return [\"input\"];\n  }\n\n  static createPrompt() {\n    return ChatPromptTemplate.fromMessages([\n      HumanMessagePromptTemplate.fromTemplate(AGENT_INSTRUCTIONS),\n      AIMessagePromptTemplate.fromTemplate(\"{intermediate_steps}\"),\n    ]);\n  }\n\n  /**\n   * Plans the next action or finish state of the agent based on the\n   * provided steps, inputs, and optional callback manager.\n   * @param steps The steps to consider in planning.\n   * @param inputs The inputs to consider in planning.\n   * @param callbackManager Optional CallbackManager to use in planning.\n   * @returns A Promise that resolves to an AgentAction or AgentFinish object representing the planned action or finish state.\n   */\n  async plan(\n    steps: AgentStep[],\n    inputs: ChainValues,\n    callbackManager?: CallbackManager\n  ): Promise<AgentAction | AgentFinish> {\n    let log = \"\";\n    for (const { action, observation } of steps) {\n      log += `<tool>${action.tool}</tool><tool_input>${action.toolInput}</tool_input><observation>${observation}</observation>`;\n    }\n    let tools = \"\";\n    for (const tool of this.tools) {\n      tools += `${tool.name}: ${tool.description}\\n`;\n    }\n    const _inputs = {\n      intermediate_steps: log,\n      tools,\n      question: inputs.input,\n      stop: [\"</tool_input>\", \"</final_answer>\"],\n    };\n    const response = await this.llmChain.call(_inputs, callbackManager);\n    return this.outputParser.parse(response[this.llmChain.outputKey]);\n  }\n\n  /**\n   * Creates an XMLAgent from a BaseLanguageModel and a list of tools.\n   * @param llm The BaseLanguageModel to use.\n   * @param tools The tools to be used by the agent.\n   * @param args Optional arguments for creating the agent.\n   * @returns An instance of XMLAgent.\n   */\n  static fromLLMAndTools(\n    llm: BaseLanguageModelInterface,\n    tools: ToolInterface[],\n    args?: XMLAgentInput & Pick<AgentArgs, \"callbacks\">\n  ) {\n    const prompt = XMLAgent.createPrompt();\n    const chain = new LLMChain({\n      prompt,\n      llm,\n      callbacks: args?.callbacks,\n    });\n    return new XMLAgent({\n      llmChain: chain,\n      tools,\n    });\n  }\n}\n\n/**\n * Params used by the createXmlAgent function.\n */\nexport type CreateXmlAgentParams = {\n  /** LLM to use for the agent. */\n  llm: BaseLanguageModelInterface;\n  /** Tools this agent has access to. */\n  tools: ToolInterface[];\n  /**\n   * The prompt to use. Must have input keys for\n   * `tools` and `agent_scratchpad`.\n   */\n  prompt: BasePromptTemplate;\n  /**\n   * Whether to invoke the underlying model in streaming mode,\n   * allowing streaming of intermediate steps. Defaults to true.\n   */\n  streamRunnable?: boolean;\n};\n\n/**\n * Create an agent that uses XML to format its logic.\n * @param params Params required to create the agent. Includes an LLM, tools, and prompt.\n * @returns A runnable sequence representing an agent. It takes as input all the same input\n *     variables as the prompt passed in does. It returns as output either an\n *     AgentAction or AgentFinish.\n *\n * @example\n * ```typescript\n * import { AgentExecutor, createXmlAgent } from \"langchain/agents\";\n * import { pull } from \"langchain/hub\";\n * import type { PromptTemplate } from \"@langchain/core/prompts\";\n *\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n *\n * // Define the tools the agent will have access to.\n * const tools = [...];\n *\n * // Get the prompt to use - you can modify this!\n * // If you want to see the prompt in full, you can at:\n * // https://smith.langchain.com/hub/hwchase17/xml-agent-convo\n * const prompt = await pull<PromptTemplate>(\"hwchase17/xml-agent-convo\");\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n * });\n *\n * const agent = await createXmlAgent({\n *   llm,\n *   tools,\n *   prompt,\n * });\n *\n * const agentExecutor = new AgentExecutor({\n *   agent,\n *   tools,\n * });\n *\n * const result = await agentExecutor.invoke({\n *   input: \"what is LangChain?\",\n * });\n *\n * // With chat history\n * const result2 = await agentExecutor.invoke({\n *   input: \"what's my name?\",\n *   // Notice that chat_history is a string, since this prompt is aimed at LLMs, not chat models\n *   chat_history: \"Human: Hi! My name is Cob\\nAI: Hello Cob! Nice to meet you\",\n * });\n * ```\n */\nexport async function createXmlAgent({\n  llm,\n  tools,\n  prompt,\n  streamRunnable,\n}: CreateXmlAgentParams) {\n  const missingVariables = [\"tools\", \"agent_scratchpad\"].filter(\n    (v) => !prompt.inputVariables.includes(v)\n  );\n  if (missingVariables.length > 0) {\n    throw new Error(\n      `Provided prompt is missing required input variables: ${JSON.stringify(\n        missingVariables\n      )}`\n    );\n  }\n  const partialedPrompt = await prompt.partial({\n    tools: renderTextDescription(tools),\n  });\n  // TODO: Add .bind to core runnable interface.\n  const llmWithStop = (llm as BaseLanguageModel).withConfig({\n    stop: [\"</tool_input>\", \"</final_answer>\"],\n  });\n  const agent = AgentRunnableSequence.fromRunnables(\n    [\n      RunnablePassthrough.assign({\n        agent_scratchpad: (input: { steps: AgentStep[] }) =>\n          formatXml(input.steps),\n      }),\n      partialedPrompt,\n      llmWithStop,\n      new XMLAgentOutputParser(),\n    ],\n    {\n      name: \"XMLAgent\",\n      streamRunnable,\n      singleAction: true,\n    }\n  );\n  return agent;\n}\n"],"mappings":";;;;;;;;;;;;;;AAqCA,IAAa,WAAb,MAAa,iBAAiBA,oCAA+C;CAC3E,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe;EAAC;EAAa;EAAU;EAAM;CAE7C;CAEA;CAEA,eAAqC,IAAIC,uDAAsB;CAE/D,aAAa;AACX,SAAO;;CAGT,YAAY,QAAuB;AACjC,QAAM,OAAO;AACb,OAAK,QAAQ,OAAO;AACpB,OAAK,WAAW,OAAO;;CAGzB,IAAI,YAAY;AACd,SAAO,CAAC,QAAQ;;CAGlB,OAAO,eAAe;AACpB,SAAOC,2CAAmB,aAAa,CACrCC,mDAA2B,aAAaC,kCAAmB,EAC3DC,gDAAwB,aAAa,uBAAuB,CAC7D,CAAC;;;;;;;;;;CAWJ,MAAM,KACJ,OACA,QACA,iBACoC;EACpC,IAAI,MAAM;AACV,OAAK,MAAM,EAAE,QAAQ,iBAAiB,MACpC,QAAO,SAAS,OAAO,KAAK,qBAAqB,OAAO,UAAU,4BAA4B,YAAY;EAE5G,IAAI,QAAQ;AACZ,OAAK,MAAM,QAAQ,KAAK,MACtB,UAAS,GAAG,KAAK,KAAK,IAAI,KAAK,YAAY;EAE7C,MAAM,UAAU;GACd,oBAAoB;GACpB;GACA,UAAU,OAAO;GACjB,MAAM,CAAC,iBAAiB,kBAAkB;GAC3C;EACD,MAAM,WAAW,MAAM,KAAK,SAAS,KAAK,SAAS,gBAAgB;AACnE,SAAO,KAAK,aAAa,MAAM,SAAS,KAAK,SAAS,WAAW;;;;;;;;;CAUnE,OAAO,gBACL,KACA,OACA,MACA;AAOA,SAAO,IAAI,SAAS;GAClB,UANY,IAAIC,2BAAS;IACzB,QAFa,SAAS,cAAc;IAGpC;IACA,WAAW,MAAM;IAClB,CAAC;GAGA;GACD,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0EN,eAAsB,eAAe,EACnC,KACA,OACA,QACA,kBACuB;CACvB,MAAM,mBAAmB,CAAC,SAAS,mBAAmB,CAAC,QACpD,MAAM,CAAC,OAAO,eAAe,SAAS,EAAE,CAC1C;AACD,KAAI,iBAAiB,SAAS,EAC5B,OAAM,IAAI,MACR,wDAAwD,KAAK,UAC3D,iBACD,GACF;CAEH,MAAM,kBAAkB,MAAM,OAAO,QAAQ,EAC3C,OAAOC,2CAAsB,MAAM,EACpC,CAAC;CAEF,MAAM,cAAe,IAA0B,WAAW,EACxD,MAAM,CAAC,iBAAiB,kBAAkB,EAC3C,CAAC;AAiBF,QAhBcC,oCAAsB,cAClC;EACEC,8CAAoB,OAAO,EACzB,mBAAmB,UACjBC,+CAAU,MAAM,MAAM,EACzB,CAAC;EACF;EACA;EACA,IAAIT,uDAAsB;EAC3B,EACD;EACE,MAAM;EACN;EACA,cAAc;EACf,CACF"}