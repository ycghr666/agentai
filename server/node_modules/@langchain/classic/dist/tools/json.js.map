{"version":3,"file":"json.js","names":[],"sources":["../../src/tools/json.ts"],"sourcesContent":["import jsonpointer from \"jsonpointer\";\nimport { Serializable } from \"@langchain/core/load/serializable\";\nimport { Tool, ToolParams } from \"@langchain/core/tools\";\n\nexport type Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [key: string]: Json }\n  | Json[];\n\nexport type JsonObject = { [key: string]: Json };\n\n/**\n * Represents a JSON object in the LangChain framework. Provides methods\n * to get keys and values from the JSON object.\n */\nexport class JsonSpec extends Serializable {\n  lc_namespace = [\"langchain\", \"tools\", \"json\"];\n\n  obj: JsonObject;\n\n  maxValueLength = 4000;\n\n  constructor(obj: JsonObject, max_value_length = 4000) {\n    super(...arguments);\n    this.obj = obj;\n    this.maxValueLength = max_value_length;\n  }\n\n  /**\n   * Retrieves all keys at a given path in the JSON object.\n   * @param input The path to the keys in the JSON object, provided as a string in JSON pointer syntax.\n   * @returns A string containing all keys at the given path, separated by commas.\n   */\n  public getKeys(input: string): string {\n    const pointer = jsonpointer.compile(input);\n    const res = pointer.get(this.obj) as Json;\n    if (typeof res === \"object\" && !Array.isArray(res) && res !== null) {\n      return Object.keys(res)\n        .map((i) => i.replaceAll(\"~\", \"~0\").replaceAll(\"/\", \"~1\"))\n        .join(\", \");\n    }\n\n    throw new Error(\n      `Value at ${input} is not a dictionary, get the value directly instead.`\n    );\n  }\n\n  /**\n   * Retrieves the value at a given path in the JSON object.\n   * @param input The path to the value in the JSON object, provided as a string in JSON pointer syntax.\n   * @returns The value at the given path in the JSON object, as a string. If the value is a large dictionary or exceeds the maximum length, a message is returned instead.\n   */\n  public getValue(input: string): string {\n    const pointer = jsonpointer.compile(input);\n    const res = pointer.get(this.obj) as Json;\n\n    if (res === null || res === undefined) {\n      throw new Error(`Value at ${input} is null or undefined.`);\n    }\n\n    const str = typeof res === \"object\" ? JSON.stringify(res) : res.toString();\n    if (\n      typeof res === \"object\" &&\n      !Array.isArray(res) &&\n      str.length > this.maxValueLength\n    ) {\n      return `Value is a large dictionary, should explore its keys directly.`;\n    }\n\n    if (str.length > this.maxValueLength) {\n      return `${str.slice(0, this.maxValueLength)}...`;\n    }\n    return str;\n  }\n}\n\nexport interface JsonToolFields extends ToolParams {\n  jsonSpec: JsonSpec;\n}\n\n/**\n * A tool in the LangChain framework that lists all keys at a given path\n * in a JSON object.\n */\nexport class JsonListKeysTool extends Tool {\n  static lc_name() {\n    return \"JsonListKeysTool\";\n  }\n\n  name = \"json_list_keys\";\n\n  jsonSpec: JsonSpec;\n\n  constructor(jsonSpec: JsonSpec);\n\n  constructor(fields: JsonToolFields);\n\n  constructor(fields: JsonSpec | JsonToolFields) {\n    if (!(\"jsonSpec\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { jsonSpec: fields };\n    }\n    super(fields);\n\n    this.jsonSpec = fields.jsonSpec;\n  }\n\n  /** @ignore */\n  async _call(input: string) {\n    try {\n      return this.jsonSpec.getKeys(input);\n    } catch (error) {\n      return `${error}`;\n    }\n  }\n\n  description = `Can be used to list all keys at a given path.\n    Before calling this you should be SURE that the path to this exists.\n    The input is a text representation of the path to the json as json pointer syntax (e.g. /key1/0/key2).`;\n}\n\n/**\n * A tool in the LangChain framework that retrieves the value at a given\n * path in a JSON object.\n */\nexport class JsonGetValueTool extends Tool {\n  static lc_name() {\n    return \"JsonGetValueTool\";\n  }\n\n  name = \"json_get_value\";\n\n  constructor(public jsonSpec: JsonSpec) {\n    super();\n  }\n\n  /** @ignore */\n  async _call(input: string) {\n    try {\n      return this.jsonSpec.getValue(input);\n    } catch (error) {\n      return `${error}`;\n    }\n  }\n\n  description = `Can be used to see value in string format at a given path.\n    Before calling this you should be SURE that the path to this exists.\n    The input is a text representation of the path to the json as json pointer syntax (e.g. /key1/0/key2).`;\n}\n"],"mappings":";;;;;;;;;AAkBA,IAAa,WAAb,cAA8B,aAAa;CACzC,eAAe;EAAC;EAAa;EAAS;EAAO;CAE7C;CAEA,iBAAiB;CAEjB,YAAY,KAAiB,mBAAmB,KAAM;AACpD,QAAM,GAAG,UAAU;AACnB,OAAK,MAAM;AACX,OAAK,iBAAiB;;;;;;;CAQxB,AAAO,QAAQ,OAAuB;EAEpC,MAAM,MADU,YAAY,QAAQ,MAAM,CACtB,IAAI,KAAK,IAAI;AACjC,MAAI,OAAO,QAAQ,YAAY,CAAC,MAAM,QAAQ,IAAI,IAAI,QAAQ,KAC5D,QAAO,OAAO,KAAK,IAAI,CACpB,KAAK,MAAM,EAAE,WAAW,KAAK,KAAK,CAAC,WAAW,KAAK,KAAK,CAAC,CACzD,KAAK,KAAK;AAGf,QAAM,IAAI,MACR,YAAY,MAAM,uDACnB;;;;;;;CAQH,AAAO,SAAS,OAAuB;EAErC,MAAM,MADU,YAAY,QAAQ,MAAM,CACtB,IAAI,KAAK,IAAI;AAEjC,MAAI,QAAQ,QAAQ,QAAQ,OAC1B,OAAM,IAAI,MAAM,YAAY,MAAM,wBAAwB;EAG5D,MAAM,MAAM,OAAO,QAAQ,WAAW,KAAK,UAAU,IAAI,GAAG,IAAI,UAAU;AAC1E,MACE,OAAO,QAAQ,YACf,CAAC,MAAM,QAAQ,IAAI,IACnB,IAAI,SAAS,KAAK,eAElB,QAAO;AAGT,MAAI,IAAI,SAAS,KAAK,eACpB,QAAO,GAAG,IAAI,MAAM,GAAG,KAAK,eAAe,CAAC;AAE9C,SAAO;;;;;;;AAYX,IAAa,mBAAb,cAAsC,KAAK;CACzC,OAAO,UAAU;AACf,SAAO;;CAGT,OAAO;CAEP;CAMA,YAAY,QAAmC;AAC7C,MAAI,EAAE,cAAc,QAElB,UAAS,EAAE,UAAU,QAAQ;AAE/B,QAAM,OAAO;AAEb,OAAK,WAAW,OAAO;;;CAIzB,MAAM,MAAM,OAAe;AACzB,MAAI;AACF,UAAO,KAAK,SAAS,QAAQ,MAAM;WAC5B,OAAO;AACd,UAAO,GAAG;;;CAId,cAAc;;;;;;;;AAShB,IAAa,mBAAb,cAAsC,KAAK;CACzC,OAAO,UAAU;AACf,SAAO;;CAGT,OAAO;CAEP,YAAY,AAAO,UAAoB;AACrC,SAAO;EADU;;;CAKnB,MAAM,MAAM,OAAe;AACzB,MAAI;AACF,UAAO,KAAK,SAAS,SAAS,MAAM;WAC7B,OAAO;AACd,UAAO,GAAG;;;CAId,cAAc"}