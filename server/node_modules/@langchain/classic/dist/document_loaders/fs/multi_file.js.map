{"version":3,"file":"multi_file.js","names":[],"sources":["../../../src/document_loaders/fs/multi_file.ts"],"sourcesContent":["import { extname, resolve } from \"node:path\";\nimport { stat } from \"node:fs/promises\";\nimport { Document } from \"@langchain/core/documents\";\nimport { BaseDocumentLoader } from \"@langchain/core/document_loaders/base\";\nimport { type LoadersMapping, UnknownHandling } from \"./directory.js\";\n\n/**\n * A document loader that loads documents from multiple files. It extends the\n * `BaseDocumentLoader` class and implements the `load()` method.\n * @example\n * ```typescript\n *\n * const multiFileLoader = new MultiFileLoader(\n *   [\"path/to/file1.pdf\", \"path/to/file2.txt\"],\n *   {\n *     \".pdf\": (path: string) => new PDFLoader(path),\n *   },\n * );\n *\n * const docs = await multiFileLoader.load();\n * console.log({ docs });\n *\n * ```\n */\nexport class MultiFileLoader extends BaseDocumentLoader {\n  constructor(\n    public filePaths: string[],\n    public loaders: LoadersMapping,\n    public unknown: UnknownHandling = UnknownHandling.Warn\n  ) {\n    super();\n\n    if (Object.keys(loaders).length === 0) {\n      throw new Error(\"Must provide at least one loader\");\n    }\n    for (const extension in loaders) {\n      if (Object.hasOwn(loaders, extension)) {\n        if (extension[0] !== \".\") {\n          throw new Error(`Extension must start with a dot: ${extension}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Loads the documents from the provided file paths. It checks if the file\n   * is a directory and ignores it. If a file is a file, it checks if there\n   * is a corresponding loader function for the file extension in the `loaders`\n   * mapping. If there is, it loads the documents. If there is no\n   * corresponding loader function and `unknown` is set to `Warn`, it logs a\n   * warning message. If `unknown` is set to `Error`, it throws an error.\n   * @returns A promise that resolves to an array of loaded documents.\n   */\n  public async load(): Promise<Document[]> {\n    const documents: Document[] = [];\n\n    for (const filePath of this.filePaths) {\n      const fullPath = resolve(filePath);\n      const fileStat = await stat(fullPath);\n\n      if (fileStat.isDirectory()) {\n        console.warn(`Ignoring directory: ${fullPath}`);\n        continue;\n      }\n\n      const loaderFactory = this.loaders[extname(fullPath)];\n      if (loaderFactory) {\n        const loader = loaderFactory(fullPath);\n        documents.push(...(await loader.load()));\n      } else {\n        switch (this.unknown) {\n          case UnknownHandling.Ignore:\n            break;\n          case UnknownHandling.Warn:\n            console.warn(`Unknown file type: ${fullPath}`);\n            break;\n          case UnknownHandling.Error:\n            throw new Error(`Unknown file type: ${fullPath}`);\n          default:\n            throw new Error(`Unknown unknown handling: ${this.unknown}`);\n        }\n      }\n    }\n\n    return documents;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,IAAa,kBAAb,cAAqC,mBAAmB;CACtD,YACE,AAAO,WACP,AAAO,SACP,AAAO,UAA2B,gBAAgB,MAClD;AACA,SAAO;EAJA;EACA;EACA;AAIP,MAAI,OAAO,KAAK,QAAQ,CAAC,WAAW,EAClC,OAAM,IAAI,MAAM,mCAAmC;AAErD,OAAK,MAAM,aAAa,QACtB,KAAI,OAAO,OAAO,SAAS,UAAU,EACnC;OAAI,UAAU,OAAO,IACnB,OAAM,IAAI,MAAM,oCAAoC,YAAY;;;;;;;;;;;;CAexE,MAAa,OAA4B;EACvC,MAAM,YAAwB,EAAE;AAEhC,OAAK,MAAM,YAAY,KAAK,WAAW;GACrC,MAAM,WAAW,QAAQ,SAAS;AAGlC,QAFiB,MAAM,KAAK,SAAS,EAExB,aAAa,EAAE;AAC1B,YAAQ,KAAK,uBAAuB,WAAW;AAC/C;;GAGF,MAAM,gBAAgB,KAAK,QAAQ,QAAQ,SAAS;AACpD,OAAI,eAAe;IACjB,MAAM,SAAS,cAAc,SAAS;AACtC,cAAU,KAAK,GAAI,MAAM,OAAO,MAAM,CAAE;SAExC,SAAQ,KAAK,SAAb;IACE,KAAK,gBAAgB,OACnB;IACF,KAAK,gBAAgB;AACnB,aAAQ,KAAK,sBAAsB,WAAW;AAC9C;IACF,KAAK,gBAAgB,MACnB,OAAM,IAAI,MAAM,sBAAsB,WAAW;IACnD,QACE,OAAM,IAAI,MAAM,6BAA6B,KAAK,UAAU;;;AAKpE,SAAO"}