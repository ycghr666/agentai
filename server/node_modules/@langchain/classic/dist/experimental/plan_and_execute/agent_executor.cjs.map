{"version":3,"file":"agent_executor.cjs","names":["BaseChain","ListStepContainer","LLMPlanner","LLMChain","getPlannerChatPrompt","PlanOutputParser","DEFAULT_STEP_EXECUTOR_HUMAN_CHAT_MESSAGE_TEMPLATE","StructuredChatAgent","ChainStepExecutor","AgentExecutor","ChatAgent"],"sources":["../../../src/experimental/plan_and_execute/agent_executor.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { Tool, DynamicStructuredTool } from \"@langchain/core/tools\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport { BaseChain, ChainInputs } from \"../../chains/base.js\";\nimport {\n  BasePlanner,\n  BaseStepContainer,\n  BaseStepExecutor,\n  ListStepContainer,\n  LLMPlanner,\n  ChainStepExecutor,\n} from \"./base.js\";\nimport { AgentExecutor } from \"../../agents/executor.js\";\nimport {\n  DEFAULT_STEP_EXECUTOR_HUMAN_CHAT_MESSAGE_TEMPLATE,\n  getPlannerChatPrompt,\n} from \"./prompt.js\";\nimport { LLMChain } from \"../../chains/llm_chain.js\";\nimport { PlanOutputParser } from \"./outputParser.js\";\nimport { ChatAgent } from \"../../agents/chat/index.js\";\nimport { StructuredChatAgent } from \"../../agents/index.js\";\nimport { SerializedLLMChain } from \"../../chains/serde.js\";\n\n/**\n * A utility function to distiguish a dynamicstructuredtool over other tools.\n * @param tool the tool to test\n * @returns bool\n */\nexport function isDynamicStructuredTool(\n  tool: Tool | DynamicStructuredTool\n): tool is DynamicStructuredTool {\n  // We check for the existence of the static lc_name method in the object's constructor\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (tool.constructor as any).lc_name === \"function\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (tool.constructor as any).lc_name() === \"DynamicStructuredTool\"\n  );\n}\n\n/**\n * Interface for the input to the PlanAndExecuteAgentExecutor class. It\n * extends ChainInputs and includes additional properties for the planner,\n * step executor, step container, and input and output keys.\n */\nexport interface PlanAndExecuteAgentExecutorInput extends ChainInputs {\n  planner: BasePlanner;\n  stepExecutor: BaseStepExecutor;\n  stepContainer?: BaseStepContainer;\n  inputKey?: string;\n  outputKey?: string;\n}\n\n/**\n * Class representing a plan-and-execute agent executor. This agent\n * decides on the full sequence of actions upfront, then executes them all\n * without updating the plan. This is suitable for complex or long-running\n * tasks that require maintaining long-term objectives and focus.\n */\nexport class PlanAndExecuteAgentExecutor extends BaseChain {\n  static lc_name() {\n    return \"PlanAndExecuteAgentExecutor\";\n  }\n\n  private planner: BasePlanner;\n\n  private stepExecutor: BaseStepExecutor;\n\n  private stepContainer: BaseStepContainer = new ListStepContainer();\n\n  private inputKey = \"input\";\n\n  private outputKey = \"output\";\n\n  constructor(input: PlanAndExecuteAgentExecutorInput) {\n    super(input);\n    this.planner = input.planner;\n    this.stepExecutor = input.stepExecutor;\n    this.stepContainer = input.stepContainer ?? this.stepContainer;\n    this.inputKey = input.inputKey ?? this.inputKey;\n    this.outputKey = input.outputKey ?? this.outputKey;\n  }\n\n  get inputKeys() {\n    return [this.inputKey];\n  }\n\n  get outputKeys() {\n    return [this.outputKey];\n  }\n\n  /**\n   * Static method that returns a default planner for the agent. It creates\n   * a new LLMChain with a given LLM and a fixed prompt, and uses it to\n   * create a new LLMPlanner with a PlanOutputParser.\n   * @param llm The Large Language Model (LLM) used to generate responses.\n   * @returns A new LLMPlanner instance.\n   */\n\n  static async getDefaultPlanner({\n    llm,\n    tools,\n  }: {\n    llm: BaseLanguageModelInterface;\n    tools: Tool[] | DynamicStructuredTool[];\n  }) {\n    const plannerLlmChain = new LLMChain({\n      llm,\n      prompt: await getPlannerChatPrompt(tools),\n    });\n    return new LLMPlanner(plannerLlmChain, new PlanOutputParser());\n  }\n\n  /**\n   * Static method that returns a default step executor for the agent. It\n   * creates a new ChatAgent from a given LLM and a set of tools, and uses\n   * it to create a new ChainStepExecutor.\n   * @param llm The Large Language Model (LLM) used to generate responses.\n   * @param tools The set of tools used by the agent.\n   * @param humanMessageTemplate The template for human messages. If not provided, a default template is used.\n   * @returns A new ChainStepExecutor instance.\n   */\n  static getDefaultStepExecutor({\n    llm,\n    tools,\n    humanMessageTemplate = DEFAULT_STEP_EXECUTOR_HUMAN_CHAT_MESSAGE_TEMPLATE,\n  }: {\n    llm: BaseLanguageModelInterface;\n    tools: Tool[] | DynamicStructuredTool[];\n    humanMessageTemplate?: string;\n  }) {\n    let agent;\n\n    if (tools.length > 0 && isDynamicStructuredTool(tools[0])) {\n      agent = StructuredChatAgent.fromLLMAndTools(llm, tools, {\n        humanMessageTemplate,\n        inputVariables: [\"previous_steps\", \"current_step\", \"agent_scratchpad\"],\n      });\n      return new ChainStepExecutor(\n        AgentExecutor.fromAgentAndTools({\n          agent,\n          tools,\n        })\n      );\n    }\n\n    agent = ChatAgent.fromLLMAndTools(llm, tools as Tool[], {\n      humanMessageTemplate,\n    });\n    return new ChainStepExecutor(\n      AgentExecutor.fromAgentAndTools({\n        agent,\n        tools,\n      })\n    );\n  }\n\n  /**\n   * Static method that creates a new PlanAndExecuteAgentExecutor from a\n   * given LLM, a set of tools, and optionally a human message template. It\n   * uses the getDefaultPlanner and getDefaultStepExecutor methods to create\n   * the planner and step executor for the new agent executor.\n   * @param llm The Large Language Model (LLM) used to generate responses.\n   * @param tools The set of tools used by the agent.\n   * @param humanMessageTemplate The template for human messages. If not provided, a default template is used.\n   * @returns A new PlanAndExecuteAgentExecutor instance.\n   */\n  static async fromLLMAndTools({\n    llm,\n    tools,\n    humanMessageTemplate,\n  }: {\n    llm: BaseLanguageModelInterface;\n    tools: Tool[] | DynamicStructuredTool[];\n    humanMessageTemplate?: string;\n  } & Omit<PlanAndExecuteAgentExecutorInput, \"planner\" | \"stepExecutor\">) {\n    const executor = new PlanAndExecuteAgentExecutor({\n      planner: await PlanAndExecuteAgentExecutor.getDefaultPlanner({\n        llm,\n        tools,\n      }),\n      stepExecutor: PlanAndExecuteAgentExecutor.getDefaultStepExecutor({\n        llm,\n        tools,\n        humanMessageTemplate,\n      }),\n    });\n    return executor;\n  }\n\n  /** @ignore */\n  async _call(\n    inputs: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<ChainValues> {\n    const plan = await this.planner.plan(inputs.input, runManager?.getChild());\n    if (!plan.steps?.length) {\n      throw new Error(\n        \"Could not create and parse a plan to answer your question - please try again.\"\n      );\n    }\n    plan.steps[plan.steps.length - 1].text +=\n      ` The original question was: ${inputs.input}.`;\n    for (const step of plan.steps) {\n      const newInputs = {\n        ...inputs,\n        previous_steps: JSON.stringify(this.stepContainer.getSteps()),\n        current_step: step.text,\n      };\n      const response = await this.stepExecutor.step(\n        newInputs,\n        runManager?.getChild()\n      );\n      this.stepContainer.addStep(step, response);\n    }\n    return { [this.outputKey]: this.stepContainer.getFinalResponse() };\n  }\n\n  _chainType() {\n    return \"agent_executor\" as const;\n  }\n\n  serialize(): SerializedLLMChain {\n    throw new Error(\"Cannot serialize an AgentExecutor\");\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;AA6BA,SAAgB,wBACd,MAC+B;AAE/B,QAEE,OAAQ,KAAK,YAAoB,YAAY,cAE5C,KAAK,YAAoB,SAAS,KAAK;;;;;;;;AAuB5C,IAAa,8BAAb,MAAa,oCAAoCA,uBAAU;CACzD,OAAO,UAAU;AACf,SAAO;;CAGT,AAAQ;CAER,AAAQ;CAER,AAAQ,gBAAmC,IAAIC,kCAAmB;CAElE,AAAQ,WAAW;CAEnB,AAAQ,YAAY;CAEpB,YAAY,OAAyC;AACnD,QAAM,MAAM;AACZ,OAAK,UAAU,MAAM;AACrB,OAAK,eAAe,MAAM;AAC1B,OAAK,gBAAgB,MAAM,iBAAiB,KAAK;AACjD,OAAK,WAAW,MAAM,YAAY,KAAK;AACvC,OAAK,YAAY,MAAM,aAAa,KAAK;;CAG3C,IAAI,YAAY;AACd,SAAO,CAAC,KAAK,SAAS;;CAGxB,IAAI,aAAa;AACf,SAAO,CAAC,KAAK,UAAU;;;;;;;;;CAWzB,aAAa,kBAAkB,EAC7B,KACA,SAIC;AAKD,SAAO,IAAIC,0BAJa,IAAIC,2BAAS;GACnC;GACA,QAAQ,MAAMC,oCAAqB,MAAM;GAC1C,CAAC,EACqC,IAAIC,uCAAkB,CAAC;;;;;;;;;;;CAYhE,OAAO,uBAAuB,EAC5B,KACA,OACA,uBAAuBC,oEAKtB;EACD,IAAI;AAEJ,MAAI,MAAM,SAAS,KAAK,wBAAwB,MAAM,GAAG,EAAE;AACzD,WAAQC,oCAAoB,gBAAgB,KAAK,OAAO;IACtD;IACA,gBAAgB;KAAC;KAAkB;KAAgB;KAAmB;IACvE,CAAC;AACF,UAAO,IAAIC,iCACTC,+BAAc,kBAAkB;IAC9B;IACA;IACD,CAAC,CACH;;AAGH,UAAQC,wBAAU,gBAAgB,KAAK,OAAiB,EACtD,sBACD,CAAC;AACF,SAAO,IAAIF,iCACTC,+BAAc,kBAAkB;GAC9B;GACA;GACD,CAAC,CACH;;;;;;;;;;;;CAaH,aAAa,gBAAgB,EAC3B,KACA,OACA,wBAKsE;AAYtE,SAXiB,IAAI,4BAA4B;GAC/C,SAAS,MAAM,4BAA4B,kBAAkB;IAC3D;IACA;IACD,CAAC;GACF,cAAc,4BAA4B,uBAAuB;IAC/D;IACA;IACA;IACD,CAAC;GACH,CAAC;;;CAKJ,MAAM,MACJ,QACA,YACsB;EACtB,MAAM,OAAO,MAAM,KAAK,QAAQ,KAAK,OAAO,OAAO,YAAY,UAAU,CAAC;AAC1E,MAAI,CAAC,KAAK,OAAO,OACf,OAAM,IAAI,MACR,gFACD;AAEH,OAAK,MAAM,KAAK,MAAM,SAAS,GAAG,QAChC,+BAA+B,OAAO,MAAM;AAC9C,OAAK,MAAM,QAAQ,KAAK,OAAO;GAC7B,MAAM,YAAY;IAChB,GAAG;IACH,gBAAgB,KAAK,UAAU,KAAK,cAAc,UAAU,CAAC;IAC7D,cAAc,KAAK;IACpB;GACD,MAAM,WAAW,MAAM,KAAK,aAAa,KACvC,WACA,YAAY,UAAU,CACvB;AACD,QAAK,cAAc,QAAQ,MAAM,SAAS;;AAE5C,SAAO,GAAG,KAAK,YAAY,KAAK,cAAc,kBAAkB,EAAE;;CAGpE,aAAa;AACX,SAAO;;CAGT,YAAgC;AAC9B,QAAM,IAAI,MAAM,oCAAoC"}