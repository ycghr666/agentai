{"version":3,"file":"agent.js","names":[],"sources":["../../../src/experimental/babyagi/agent.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport type { VectorStoreInterface } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport { BaseChain, ChainInputs } from \"../../chains/base.js\";\nimport { SerializedBaseChain } from \"../../chains/serde.js\";\nimport { Optional } from \"../../types/type-utils.js\";\nimport { TaskCreationChain } from \"./task_creation.js\";\nimport { TaskExecutionChain } from \"./task_execution.js\";\nimport { TaskPrioritizationChain } from \"./task_prioritization.js\";\n\n/**\n * Interface defining the structure of a task. A task has a `taskID` and a\n * `taskName`.\n */\nexport interface Task {\n  taskID: string;\n  taskName: string;\n}\n\n/**\n * Interface defining the structure of the inputs for the `BabyAGI` class.\n * It extends the `ChainInputs` interface, omitting the 'memory' and\n * 'callbackManager' properties, and adds properties specific to\n * `BabyAGI`.\n */\nexport interface BabyAGIInputs extends Omit<\n  ChainInputs,\n  \"memory\" | \"callbackManager\"\n> {\n  creationChain: BaseChain;\n  prioritizationChain: BaseChain;\n  executionChain: BaseChain;\n  vectorstore: VectorStoreInterface;\n  maxIterations?: number;\n}\n\n/**\n * Class responsible for managing tasks, including their creation,\n * prioritization, and execution. It uses three chains for these\n * operations: `creationChain`, `prioritizationChain`, and\n * `executionChain`.\n * @example\n * ```typescript\n * const babyAGI = BabyAGI.fromLLM({\n *   llm: new OpenAI({ temperature: 0 }),\n *   vectorstore: new MemoryVectorStore(new OpenAIEmbeddings()),\n *   maxIterations: 3,\n * });\n *\n * const result = await babyAGI.call({\n *   objective: \"Write a weather report for SF today\",\n * });\n * ```\n */\nexport class BabyAGI extends BaseChain implements BabyAGIInputs {\n  static lc_name() {\n    return \"BabyAGI\";\n  }\n\n  taskList: Task[];\n\n  creationChain: BaseChain;\n\n  prioritizationChain: BaseChain;\n\n  executionChain: BaseChain;\n\n  taskIDCounter: number;\n\n  vectorstore: VectorStoreInterface;\n\n  maxIterations: number;\n\n  constructor({\n    creationChain,\n    prioritizationChain,\n    executionChain,\n    vectorstore,\n    maxIterations = 100,\n    verbose,\n    callbacks,\n  }: BabyAGIInputs) {\n    super(undefined, verbose, callbacks);\n    this.taskList = [];\n    this.creationChain = creationChain;\n    this.prioritizationChain = prioritizationChain;\n    this.executionChain = executionChain;\n    this.taskIDCounter = 1;\n    this.vectorstore = vectorstore;\n    this.maxIterations = maxIterations;\n  }\n\n  _chainType() {\n    return \"BabyAGI\" as const;\n  }\n\n  get inputKeys() {\n    return [\"objective\", \"firstTask\"];\n  }\n\n  get outputKeys() {\n    return [];\n  }\n\n  /**\n   * Adds a task to the task list.\n   * @param task The task to be added.\n   * @returns Promise resolving to void.\n   */\n  async addTask(task: Task) {\n    this.taskList.push(task);\n  }\n\n  /**\n   * Prints the current task list to the console.\n   * @returns void\n   */\n  printTaskList() {\n    console.log(\"\\x1b[95m\\x1b[1m\\n*****TASK LIST*****\\n\\x1b[0m\\x1b[0m\");\n    for (const t of this.taskList) {\n      console.log(`${t.taskID}: ${t.taskName}`);\n    }\n  }\n\n  /**\n   * Prints the next task to the console.\n   * @param task The next task to be printed.\n   * @returns void\n   */\n  printNextTask(task: Task) {\n    console.log(\"\\x1b[92m\\x1b[1m\\n*****NEXT TASK*****\\n\\x1b[0m\\x1b[0m\");\n    console.log(`${task.taskID}: ${task.taskName}`);\n  }\n\n  /**\n   * Prints the result of a task to the console.\n   * @param result The result of the task.\n   * @returns void\n   */\n  printTaskResult(result: string) {\n    console.log(\"\\x1b[93m\\x1b[1m\\n*****TASK RESULT*****\\n\\x1b[0m\\x1b[0m\");\n    console.log(result.trim());\n  }\n\n  /**\n   * Generates the next tasks based on the result of the previous task, the\n   * task description, and the objective.\n   * @param result The result of the previous task.\n   * @param task_description The description of the task.\n   * @param objective The objective of the task.\n   * @param runManager Optional CallbackManagerForChainRun instance.\n   * @returns Promise resolving to an array of tasks without taskID.\n   */\n  async getNextTasks(\n    result: string,\n    task_description: string,\n    objective: string,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<Optional<Task, \"taskID\">[]> {\n    const taskNames = this.taskList.map((t) => t.taskName);\n    const incomplete_tasks = taskNames.join(\", \");\n    const { [this.creationChain.outputKeys[0]]: text } =\n      await this.creationChain.call(\n        {\n          result,\n          task_description,\n          incomplete_tasks,\n          objective,\n        },\n        runManager?.getChild()\n      );\n    const newTasks = (text as string).split(\"\\n\");\n    return newTasks\n      .filter((taskName) => taskName.trim())\n      .map((taskName) => ({ taskName }));\n  }\n\n  /**\n   * Prioritizes the tasks based on the current task ID and the objective.\n   * @param thisTaskID The ID of the current task.\n   * @param objective The objective of the task.\n   * @param runManager Optional CallbackManagerForChainRun instance.\n   * @returns Promise resolving to an array of prioritized tasks.\n   */\n  async prioritizeTasks(\n    thisTaskID: number,\n    objective: string,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    const taskNames = this.taskList.map((t) => t.taskName);\n    const nextTaskID = thisTaskID + 1;\n    const { [this.prioritizationChain.outputKeys[0]]: text } =\n      await this.prioritizationChain.call(\n        {\n          task_names: taskNames.join(\", \"),\n          next_task_id: String(nextTaskID),\n          objective,\n        },\n        runManager?.getChild()\n      );\n    const newTasks = (text as string).trim().split(\"\\n\");\n    const prioritizedTaskList = [];\n    for (const taskString of newTasks) {\n      const taskParts = taskString.trim().split(\".\", 2);\n      if (taskParts.length === 2) {\n        const taskID = taskParts[0].trim();\n        const taskName = taskParts[1].trim();\n        prioritizedTaskList.push({ taskID, taskName });\n      }\n    }\n    return prioritizedTaskList;\n  }\n\n  /**\n   * Retrieves the top tasks that are most similar to the given query.\n   * @param query The query to search for.\n   * @param k The number of top tasks to retrieve.\n   * @returns Promise resolving to an array of top tasks.\n   */\n  async getTopTasks(query: string, k = 5) {\n    const results = await this.vectorstore.similaritySearch(query, k);\n    if (!results) {\n      return [];\n    }\n    return results.map((item) => String(item.metadata.task));\n  }\n\n  /**\n   * Executes a task based on the objective and the task description.\n   * @param objective The objective of the task.\n   * @param task The task to be executed.\n   * @param runManager Optional CallbackManagerForChainRun instance.\n   * @returns Promise resolving to the result of the task execution as a string.\n   */\n  async executeTask(\n    objective: string,\n    task: string,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    const context = await this.getTopTasks(objective);\n    const { [this.executionChain.outputKeys[0]]: text } =\n      await this.executionChain.call(\n        {\n          objective,\n          context: context.join(\"\\n\"),\n          task,\n        },\n        runManager?.getChild()\n      );\n    return text as string;\n  }\n\n  async _call(\n    { objective, firstTask = \"Make a todo list\" }: ChainValues,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    this.taskList = [];\n    this.taskIDCounter = 1;\n    await this.addTask({ taskID: \"1\", taskName: firstTask });\n\n    let numIters = 0;\n    while (numIters < this.maxIterations && this.taskList.length > 0) {\n      this.printTaskList();\n\n      const task = this.taskList.shift()!;\n      this.printNextTask(task);\n\n      const result = await this.executeTask(\n        objective,\n        task.taskName,\n        runManager\n      );\n      const thisTaskID = parseInt(task.taskID, 10);\n      this.printTaskResult(result);\n\n      await this.vectorstore.addDocuments([\n        new Document({\n          pageContent: result,\n          metadata: { task: task.taskName },\n        }),\n      ]);\n\n      const newTasks = await this.getNextTasks(\n        result,\n        task.taskName,\n        objective,\n        runManager\n      );\n      for (const newTask of newTasks) {\n        this.taskIDCounter += 1;\n        newTask.taskID = this.taskIDCounter.toFixed();\n        await this.addTask(newTask as Task);\n      }\n      this.taskList = await this.prioritizeTasks(\n        thisTaskID,\n        objective,\n        runManager\n      );\n\n      numIters += 1;\n    }\n    return {};\n  }\n\n  serialize(): SerializedBaseChain {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  /**\n   * Static method to create a new BabyAGI instance from a\n   * BaseLanguageModel.\n   * @param llm BaseLanguageModel instance used to generate a new BabyAGI instance.\n   * @param vectorstore VectorStore instance used to store and retrieve vectors.\n   * @param executionChain Optional BaseChain instance used to execute tasks.\n   * @param verbose Optional boolean indicating whether to log verbose output.\n   * @param callbacks Optional callbacks to be used during the execution of tasks.\n   * @param rest Optional additional parameters.\n   * @returns A new instance of BabyAGI.\n   */\n  static fromLLM({\n    llm,\n    vectorstore,\n    executionChain,\n    verbose,\n    callbacks,\n    ...rest\n  }: Optional<\n    BabyAGIInputs,\n    \"executionChain\" | \"creationChain\" | \"prioritizationChain\"\n  > & { llm: BaseLanguageModelInterface }) {\n    const creationChain = TaskCreationChain.fromLLM({\n      llm,\n      verbose,\n      callbacks,\n    });\n    const prioritizationChain = TaskPrioritizationChain.fromLLM({\n      llm,\n      verbose,\n      callbacks,\n    });\n    return new BabyAGI({\n      creationChain,\n      prioritizationChain,\n      executionChain:\n        executionChain ||\n        TaskExecutionChain.fromLLM({ llm, verbose, callbacks }),\n      vectorstore,\n      verbose,\n      callbacks,\n      ...rest,\n    });\n  }\n}\n"],"mappings":"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"}