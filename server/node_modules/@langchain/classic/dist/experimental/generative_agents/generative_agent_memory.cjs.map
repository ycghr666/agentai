{"version":3,"file":"generative_agent_memory.cjs","names":["BaseChain","LLMChain","Document","PromptTemplate","BaseMemory"],"sources":["../../../src/experimental/generative_agents/generative_agent_memory.ts"],"sourcesContent":["import type { BaseLanguageModelInterface } from \"@langchain/core/language_models/base\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\nimport { Document } from \"@langchain/core/documents\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\nimport { BaseMemory, InputValues, OutputValues } from \"@langchain/core/memory\";\nimport {\n  CallbackManagerForChainRun,\n  Callbacks,\n} from \"@langchain/core/callbacks/manager\";\nimport { TimeWeightedVectorStoreRetriever } from \"../../retrievers/time_weighted.js\";\nimport { BaseChain } from \"../../chains/base.js\";\nimport { LLMChain } from \"../../chains/llm_chain.js\";\n\nexport type GenerativeAgentMemoryConfig = {\n  reflectionThreshold?: number;\n  importanceWeight?: number;\n  verbose?: boolean;\n  maxTokensLimit?: number;\n};\n\n/**\n * Class that manages the memory of a generative agent in LangChain. It\n * extends the `BaseChain` class and has methods for adding observations\n * or memories to the agent's memory, scoring the importance of a memory,\n * reflecting on recent events to add synthesized memories, and generating\n * insights on a topic of reflection based on pertinent memories.\n */\nclass GenerativeAgentMemoryChain extends BaseChain {\n  static lc_name() {\n    return \"GenerativeAgentMemoryChain\";\n  }\n\n  reflecting = false;\n\n  reflectionThreshold?: number;\n\n  importanceWeight = 0.15;\n\n  memoryRetriever: TimeWeightedVectorStoreRetriever;\n\n  llm: BaseLanguageModelInterface;\n\n  verbose = false;\n\n  private aggregateImportance = 0.0;\n\n  constructor(\n    llm: BaseLanguageModelInterface,\n    memoryRetriever: TimeWeightedVectorStoreRetriever,\n    config: Omit<GenerativeAgentMemoryConfig, \"maxTokensLimit\">\n  ) {\n    super();\n    this.llm = llm;\n    this.memoryRetriever = memoryRetriever;\n    this.reflectionThreshold = config.reflectionThreshold;\n    this.importanceWeight = config.importanceWeight ?? this.importanceWeight;\n    this.verbose = config.verbose ?? this.verbose;\n  }\n\n  _chainType(): string {\n    return \"generative_agent_memory\";\n  }\n\n  get inputKeys(): string[] {\n    return [\"memory_content\", \"now\", \"memory_metadata\"];\n  }\n\n  get outputKeys(): string[] {\n    return [\"output\"];\n  }\n\n  /**\n   * Method that creates a new LLMChain with the given prompt.\n   * @param prompt The PromptTemplate to use for the new LLMChain.\n   * @returns A new LLMChain instance.\n   */\n  chain(prompt: PromptTemplate): LLMChain {\n    const chain = new LLMChain({\n      llm: this.llm,\n      prompt,\n      verbose: this.verbose,\n      outputKey: \"output\",\n    });\n    return chain;\n  }\n\n  async _call(values: ChainValues, runManager?: CallbackManagerForChainRun) {\n    const { memory_content: memoryContent, now } = values;\n    // add an observation or memory to the agent's memory\n    const importanceScore = await this.scoreMemoryImportance(\n      memoryContent,\n      runManager\n    );\n    this.aggregateImportance += importanceScore;\n    const document = new Document({\n      pageContent: memoryContent,\n      metadata: {\n        importance: importanceScore,\n        ...values.memory_metadata,\n      },\n    });\n    await this.memoryRetriever.addDocuments([document]);\n    // after an agent has processed a certain amount of memories (as measured by aggregate importance),\n    // it is time to pause and reflect on recent events to add more synthesized memories to the agent's\n    // memory stream.\n    if (\n      this.reflectionThreshold !== undefined &&\n      this.aggregateImportance > this.reflectionThreshold &&\n      !this.reflecting\n    ) {\n      console.log(\"Reflecting on current memories...\");\n      this.reflecting = true;\n      await this.pauseToReflect(now, runManager);\n      this.aggregateImportance = 0.0;\n      this.reflecting = false;\n    }\n    return { output: importanceScore };\n  }\n\n  /**\n   * Method that pauses the agent to reflect on recent events and generate\n   * new insights.\n   * @param now The current date.\n   * @param runManager The CallbackManagerForChainRun to use for the reflection.\n   * @returns An array of new insights as strings.\n   */\n  async pauseToReflect(\n    now?: Date,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<string[]> {\n    if (this.verbose) {\n      console.log(\"Pausing to reflect...\");\n    }\n    const newInsights: string[] = [];\n    const topics = await this.getTopicsOfReflection(50, runManager);\n    for (const topic of topics) {\n      const insights = await this.getInsightsOnTopic(topic, now, runManager);\n      for (const insight of insights) {\n        // add memory\n        await this.call(\n          {\n            memory_content: insight,\n            now,\n            memory_metadata: {\n              source: \"reflection_insight\",\n            },\n          },\n          runManager?.getChild(\"reflection_insight_memory\")\n        );\n      }\n      newInsights.push(...insights);\n    }\n    return newInsights;\n  }\n\n  /**\n   * Method that scores the importance of a given memory.\n   * @param memoryContent The content of the memory to score.\n   * @param runManager The CallbackManagerForChainRun to use for scoring.\n   * @returns The importance score of the memory as a number.\n   */\n  async scoreMemoryImportance(\n    memoryContent: string,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<number> {\n    // score the absolute importance of a given memory\n    const prompt = PromptTemplate.fromTemplate(\n      \"On the scale of 1 to 10, where 1 is purely mundane\" +\n        \" (e.g., brushing teeth, making bed) and 10 is\" +\n        \" extremely poignant (e.g., a break up, college\" +\n        \" acceptance), rate the likely poignancy of the\" +\n        \" following piece of memory. Respond with a single integer.\" +\n        \"\\nMemory: {memory_content}\" +\n        \"\\nRating: \"\n    );\n    const score = await this.chain(prompt).run(\n      memoryContent,\n      runManager?.getChild(\"determine_importance\")\n    );\n\n    const strippedScore = score.trim();\n\n    if (this.verbose) {\n      console.log(\"Importance score:\", strippedScore);\n    }\n    const match = strippedScore.match(/^\\D*(\\d+)/);\n    if (match) {\n      const capturedNumber = parseFloat(match[1]);\n      const result = (capturedNumber / 10) * this.importanceWeight;\n      return result;\n    } else {\n      return 0.0;\n    }\n  }\n\n  /**\n   * Method that retrieves the topics of reflection based on the last K\n   * memories.\n   * @param lastK The number of most recent memories to consider for generating topics.\n   * @param runManager The CallbackManagerForChainRun to use for retrieving topics.\n   * @returns An array of topics of reflection as strings.\n   */\n  async getTopicsOfReflection(\n    lastK: number,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<string[]> {\n    const prompt = PromptTemplate.fromTemplate(\n      \"{observations}\\n\\n\" +\n        \"Given only the information above, what are the 3 most salient\" +\n        \" high-level questions we can answer about the subjects in\" +\n        \" the statements? Provide each question on a new line.\\n\\n\"\n    );\n\n    const observations = this.memoryRetriever.getMemoryStream().slice(-lastK);\n    const observationStr = observations\n      .map((o: { pageContent: string }) => o.pageContent)\n      .join(\"\\n\");\n    const result = await this.chain(prompt).run(\n      observationStr,\n      runManager?.getChild(\"reflection_topics\")\n    );\n    return GenerativeAgentMemoryChain.parseList(result);\n  }\n\n  /**\n   * Method that generates insights on a given topic of reflection based on\n   * pertinent memories.\n   * @param topic The topic of reflection.\n   * @param now The current date.\n   * @param runManager The CallbackManagerForChainRun to use for generating insights.\n   * @returns An array of insights as strings.\n   */\n  async getInsightsOnTopic(\n    topic: string,\n    now?: Date,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<string[]> {\n    // generate insights on a topic of reflection, based on pertinent memories\n    const prompt = PromptTemplate.fromTemplate(\n      \"Statements about {topic}\\n\" +\n        \"{related_statements}\\n\\n\" +\n        \"What 5 high-level insights can you infer from the above statements?\" +\n        \" (example format: insight (because of 1, 5, 3))\"\n    );\n\n    const relatedMemories = await this.fetchMemories(topic, now, runManager);\n    const relatedStatements: string = relatedMemories\n      .map((memory, index) => `${index + 1}. ${memory.pageContent}`)\n      .join(\"\\n\");\n    const result = await this.chain(prompt).call(\n      {\n        topic,\n        related_statements: relatedStatements,\n      },\n      runManager?.getChild(\"reflection_insights\")\n    );\n    return GenerativeAgentMemoryChain.parseList(result.output); // added output\n  }\n\n  /**\n   * Method that parses a newline-separated string into a list of strings.\n   * @param text The newline-separated string to parse.\n   * @returns An array of strings.\n   */\n  static parseList(text: string): string[] {\n    // parse a newine seperates string into a list of strings\n    return text.split(\"\\n\").map((s) => s.trim());\n  }\n\n  // TODO: Mock \"now\" to simulate different times\n  /**\n   * Method that fetches memories related to a given observation.\n   * @param observation The observation to fetch memories for.\n   * @param _now The current date.\n   * @param runManager The CallbackManagerForChainRun to use for fetching memories.\n   * @returns An array of Document instances representing the fetched memories.\n   */\n  async fetchMemories(\n    observation: string,\n    _now?: Date,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<Document[]> {\n    return this.memoryRetriever.invoke(\n      observation,\n      runManager?.getChild(\"memory_retriever\")\n    );\n  }\n}\n\n/**\n * Class that manages the memory of a generative agent in LangChain. It\n * extends the `BaseMemory` class and has methods for adding a memory,\n * formatting memories, getting memories until a token limit is reached,\n * loading memory variables, saving the context of a model run to memory,\n * and clearing memory contents.\n * @example\n * ```typescript\n * const createNewMemoryRetriever = async () => {\n *   const vectorStore = new MemoryVectorStore(new OpenAIEmbeddings());\n *   const retriever = new TimeWeightedVectorStoreRetriever({\n *     vectorStore,\n *     otherScoreKeys: [\"importance\"],\n *     k: 15,\n *   });\n *   return retriever;\n * };\n * const tommiesMemory = new GenerativeAgentMemory(\n *   llm,\n *   await createNewMemoryRetriever(),\n *   { reflectionThreshold: 8 },\n * );\n * const summary = await tommiesMemory.getSummary();\n * ```\n */\nexport class GenerativeAgentMemory extends BaseMemory {\n  llm: BaseLanguageModelInterface;\n\n  memoryRetriever: TimeWeightedVectorStoreRetriever;\n\n  verbose: boolean;\n\n  reflectionThreshold?: number;\n\n  private maxTokensLimit = 1200;\n\n  queriesKey = \"queries\";\n\n  mostRecentMemoriesTokenKey = \"recent_memories_token\";\n\n  addMemoryKey = \"addMemory\";\n\n  relevantMemoriesKey = \"relevant_memories\";\n\n  relevantMemoriesSimpleKey = \"relevant_memories_simple\";\n\n  mostRecentMemoriesKey = \"most_recent_memories\";\n\n  nowKey = \"now\";\n\n  memoryChain: GenerativeAgentMemoryChain;\n\n  constructor(\n    llm: BaseLanguageModelInterface,\n    memoryRetriever: TimeWeightedVectorStoreRetriever,\n    config?: GenerativeAgentMemoryConfig\n  ) {\n    super();\n    this.llm = llm;\n    this.memoryRetriever = memoryRetriever;\n    this.verbose = config?.verbose ?? this.verbose;\n    this.reflectionThreshold =\n      config?.reflectionThreshold ?? this.reflectionThreshold;\n    this.maxTokensLimit = config?.maxTokensLimit ?? this.maxTokensLimit;\n    this.memoryChain = new GenerativeAgentMemoryChain(llm, memoryRetriever, {\n      reflectionThreshold: config?.reflectionThreshold,\n      importanceWeight: config?.importanceWeight,\n    });\n  }\n\n  /**\n   * Method that returns the key for relevant memories.\n   * @returns The key for relevant memories as a string.\n   */\n  getRelevantMemoriesKey(): string {\n    return this.relevantMemoriesKey;\n  }\n\n  /**\n   * Method that returns the key for the most recent memories token.\n   * @returns The key for the most recent memories token as a string.\n   */\n  getMostRecentMemoriesTokenKey(): string {\n    return this.mostRecentMemoriesTokenKey;\n  }\n\n  /**\n   * Method that returns the key for adding a memory.\n   * @returns The key for adding a memory as a string.\n   */\n  getAddMemoryKey(): string {\n    return this.addMemoryKey;\n  }\n\n  /**\n   * Method that returns the key for the current time.\n   * @returns The key for the current time as a string.\n   */\n  getCurrentTimeKey(): string {\n    return this.nowKey;\n  }\n\n  get memoryKeys(): string[] {\n    // Return an array of memory keys\n    return [this.relevantMemoriesKey, this.mostRecentMemoriesKey];\n  }\n\n  /**\n   * Method that adds a memory to the agent's memory.\n   * @param memoryContent The content of the memory to add.\n   * @param now The current date.\n   * @param metadata The metadata for the memory.\n   * @param callbacks The Callbacks to use for adding the memory.\n   * @returns The result of the memory addition.\n   */\n  async addMemory(\n    memoryContent: string,\n    now?: Date,\n    metadata?: Record<string, unknown>,\n    callbacks?: Callbacks\n  ) {\n    return this.memoryChain.call(\n      { memory_content: memoryContent, now, memory_metadata: metadata },\n      callbacks\n    );\n  }\n\n  /**\n   * Method that formats the given relevant memories in detail.\n   * @param relevantMemories The relevant memories to format.\n   * @returns The formatted memories as a string.\n   */\n  formatMemoriesDetail(relevantMemories: Document[]): string {\n    if (!relevantMemories.length) {\n      return \"No relevant information.\";\n    }\n    const contentStrings = new Set();\n    const content = [];\n    for (const memory of relevantMemories) {\n      if (memory.pageContent in contentStrings) {\n        continue;\n      }\n      contentStrings.add(memory.pageContent);\n      const createdTime = memory.metadata.created_at.toLocaleString(\"en-US\", {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\",\n        hour: \"numeric\",\n        minute: \"numeric\",\n        hour12: true,\n      });\n      content.push(`${createdTime}: ${memory.pageContent.trim()}`);\n    }\n    const joinedContent = content.map((mem) => `${mem}`).join(\"\\n\");\n    return joinedContent;\n  }\n\n  /**\n   * Method that formats the given relevant memories in a simple manner.\n   * @param relevantMemories The relevant memories to format.\n   * @returns The formatted memories as a string.\n   */\n  formatMemoriesSimple(relevantMemories: Document[]): string {\n    const joinedContent = relevantMemories\n      .map((mem) => `${mem.pageContent}`)\n      .join(\"; \");\n    return joinedContent;\n  }\n\n  /**\n   * Method that retrieves memories until a token limit is reached.\n   * @param consumedTokens The number of tokens consumed so far.\n   * @returns The memories as a string.\n   */\n  async getMemoriesUntilLimit(consumedTokens: number): Promise<string> {\n    // reduce the number of tokens in the documents\n    const result = [];\n    for (const doc of this.memoryRetriever\n      .getMemoryStream()\n      .slice()\n      .reverse()) {\n      if (consumedTokens >= this.maxTokensLimit) {\n        if (this.verbose) {\n          console.log(\"Exceeding max tokens for LLM, filtering memories\");\n        }\n        break;\n      }\n      // eslint-disable-next-line no-param-reassign\n      consumedTokens += await this.llm.getNumTokens(doc.pageContent);\n      if (consumedTokens < this.maxTokensLimit) {\n        result.push(doc);\n      }\n    }\n    return this.formatMemoriesSimple(result);\n  }\n\n  get memoryVariables(): string[] {\n    // input keys this memory class will load dynamically\n    return [];\n  }\n\n  /**\n   * Method that loads memory variables based on the given inputs.\n   * @param inputs The inputs to use for loading memory variables.\n   * @returns An object containing the loaded memory variables.\n   */\n  async loadMemoryVariables(\n    inputs: InputValues\n  ): Promise<Record<string, string>> {\n    const queries = inputs[this.queriesKey];\n    const now = inputs[this.nowKey];\n    if (queries !== undefined) {\n      const relevantMemories = (\n        await Promise.all(\n          queries.map((query: string) =>\n            this.memoryChain.fetchMemories(query, now)\n          )\n        )\n      ).flat();\n      return {\n        [this.relevantMemoriesKey]: this.formatMemoriesDetail(relevantMemories),\n        [this.relevantMemoriesSimpleKey]:\n          this.formatMemoriesSimple(relevantMemories),\n      };\n    }\n    const mostRecentMemoriesToken = inputs[this.mostRecentMemoriesTokenKey];\n    if (mostRecentMemoriesToken !== undefined) {\n      return {\n        [this.mostRecentMemoriesKey]: await this.getMemoriesUntilLimit(\n          mostRecentMemoriesToken\n        ),\n      };\n    }\n    return {};\n  }\n\n  /**\n   * Method that saves the context of a model run to memory.\n   * @param _inputs The inputs of the model run.\n   * @param outputs The outputs of the model run.\n   * @returns Nothing.\n   */\n  async saveContext(\n    _inputs: InputValues,\n    outputs: OutputValues\n  ): Promise<void> {\n    // save the context of this model run to memory\n    const mem = outputs[this.addMemoryKey];\n    const now = outputs[this.nowKey];\n    if (mem) {\n      await this.addMemory(mem, now, {});\n    }\n  }\n\n  /**\n   * Method that clears the memory contents.\n   * @returns Nothing.\n   */\n  clear(): void {\n    // TODO: clear memory contents\n  }\n}\n"],"mappings":"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"}